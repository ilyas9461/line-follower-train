CCS PCH C Compiler, Version 5.076, 5967               22-Oca-20 14:37

               Filename:   D:\EasyPICV6\CCS_PIC_C\Proje_tren_cizgi_izleyen\kiCad\source\lfr_tren_45k22.X\build\default\production\lfr_tren.lst

               ROM used:   15336 bytes (47%)
                           Largest free fragment is 17428
               RAM used:   755 (49%) at main() level
                           800 (52%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   33A0
*
0008:  NOP   
000A:  NOP   
000C:  NOP   
000E:  NOP   
0010:  NOP   
0012:  NOP   
0014:  NOP   
0016:  NOP   
0018:  MOVWF  04
001A:  MOVFF  FD8,05
001E:  MOVFF  FE0,06
0022:  MOVLB  0
0024:  MOVFF  FE9,0C
0028:  MOVFF  FEA,07
002C:  MOVFF  FE1,08
0030:  MOVFF  FE2,09
0034:  MOVFF  FD9,0A
0038:  MOVFF  FDA,0B
003C:  MOVFF  FF3,12
0040:  MOVFF  FF4,13
0044:  MOVFF  FFA,14
0048:  MOVFF  FF5,15
004C:  MOVFF  FF6,16
0050:  MOVFF  FF7,17
0054:  MOVFF  00,0E
0058:  MOVFF  01,0F
005C:  MOVFF  02,10
0060:  MOVFF  03,11
0064:  BTFSS  FF2.5
0066:  GOTO   0070
006A:  BTFSC  FF2.2
006C:  GOTO   045C
0070:  MOVFF  0E,00
0074:  MOVFF  0F,01
0078:  MOVFF  10,02
007C:  MOVFF  11,03
0080:  MOVFF  0C,FE9
0084:  MOVFF  07,FEA
0088:  BSF    07.7
008A:  MOVFF  08,FE1
008E:  MOVFF  09,FE2
0092:  MOVFF  0A,FD9
0096:  MOVFF  0B,FDA
009A:  MOVFF  12,FF3
009E:  MOVFF  13,FF4
00A2:  MOVFF  14,FFA
00A6:  MOVFF  15,FF5
00AA:  MOVFF  16,FF6
00AE:  MOVFF  17,FF7
00B2:  MOVF   04,W
00B4:  MOVFF  06,FE0
00B8:  MOVFF  05,FD8
00BC:  RETFIE 0
.................... /*  
....................  * File:   lfr_tren.c 
....................  * Author: ilyas 
....................  *TCRT 5000 sensörlü 
....................  * Created on 31 Temmuz 2019 Çarþamba, 08:50 
....................  */ 
....................  
.................... #include "lfr_tren.h" 
.................... /*  
....................  * File:   lfr_tren.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 31 Temmuz 2019 Çarþamba, 08:51 
....................  */ 
....................  
.................... #ifndef LFR_TREN_H 
.................... #define   LFR_TREN_H 
....................  
.................... #ifdef   __cplusplus 
.................... extern "C" { 
.................... #endif 
....................     #include <18F45K22.h> 
.................... //////////// Standard Header file for the PIC18F45K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F45K22 
00BE:  DATA 2D,2D
00C0:  DATA 3E,20
00C2:  DATA 41,53
00C4:  DATA 49,52
00C6:  DATA 49,20
00C8:  DATA 49,53
00CA:  DATA 49,4B
00CC:  DATA 3A,25
00CE:  DATA 75,0D
00D0:  DATA 0A,00
00D2:  DATA 2D,2D
00D4:  DATA 3E,20
00D6:  DATA 4E,6F
00D8:  DATA 72,6D
00DA:  DATA 61,6C
00DC:  DATA 20,49
00DE:  DATA 53,49
00E0:  DATA 4B,3A
00E2:  DATA 25,75
00E4:  DATA 0D,0A
00E6:  DATA 00,00
00E8:  DATA 70,6F
00EA:  DATA 73,3A
00EC:  DATA 25,6C
00EE:  DATA 75,09
00F0:  DATA 6B,6F
00F2:  DATA 6E,74
00F4:  DATA 3A,25
00F6:  DATA 6C,64
00F8:  DATA 0D,0A
00FA:  DATA 00,00
*
04B6:  MOVLB  2
04B8:  MOVF   xFA,W
04BA:  ANDLW  07
04BC:  MOVWF  00
04BE:  RRCF   xFA,W
04C0:  MOVWF  01
04C2:  RRCF   01,F
04C4:  RRCF   01,F
04C6:  MOVLW  1F
04C8:  ANDWF  01,F
04CA:  MOVF   01,W
04CC:  ADDWF  xFC,W
04CE:  MOVWF  FE9
04D0:  MOVLW  00
04D2:  ADDWFC xFD,W
04D4:  MOVWF  FEA
04D6:  CLRF   01
04D8:  INCF   01,F
04DA:  INCF   00,F
04DC:  BRA    04E0
04DE:  RLCF   01,F
04E0:  DECFSZ 00,F
04E2:  BRA    04DE
04E4:  MOVF   xFB,F
04E6:  BZ    04EE
04E8:  MOVF   01,W
04EA:  IORWF  FEF,F
04EC:  BRA    04F4
04EE:  COMF   01,F
04F0:  MOVF   01,W
04F2:  ANDWF  FEF,F
04F4:  MOVLB  0
04F6:  RETURN 0
*
06DC:  TSTFSZ 01
06DE:  BRA    06E6
06E0:  TSTFSZ 02
06E2:  BRA    06E8
06E4:  BRA    06F4
06E6:  INCF   02,F
06E8:  MOVFF  00,FEE
06EC:  DECFSZ 01,F
06EE:  BRA    06E8
06F0:  DECFSZ 02,F
06F2:  BRA    06E8
06F4:  RETURN 0
*
0966:  MOVLB  2
0968:  CLRF   xFB
096A:  CLRF   xFC
096C:  MOVLW  01
096E:  MOVWF  xFD
0970:  CLRF   FDA
0972:  CLRF   FD9
0974:  MOVLW  02
0976:  MOVLB  3
0978:  MOVWF  x00
097A:  MOVLW  F3
097C:  MOVLB  2
097E:  MOVWF  xFF
0980:  MOVLW  02
0982:  MOVWF  FEA
0984:  MOVLW  F7
0986:  MOVWF  FE9
0988:  MOVFF  300,FE2
098C:  MOVFF  2FF,FE1
0990:  MOVFF  2FD,2FE
0994:  BCF    FD8.0
0996:  MOVF   FE5,W
0998:  MULWF  FEE
099A:  MOVF   FF3,W
099C:  ADDWFC xFB,F
099E:  MOVF   FF4,W
09A0:  ADDWFC xFC,F
09A2:  DECFSZ xFE,F
09A4:  BRA    0994
09A6:  MOVFF  2FB,FDE
09AA:  MOVFF  2FC,2FB
09AE:  CLRF   xFC
09B0:  BTFSC  FD8.0
09B2:  INCF   xFC,F
09B4:  INCF   xFF,F
09B6:  BTFSS  FD8.2
09B8:  BRA    09C0
09BA:  MOVLB  3
09BC:  INCF   x00,F
09BE:  MOVLB  2
09C0:  INCF   xFD,F
09C2:  MOVF   xFD,W
09C4:  SUBLW  05
09C6:  BNZ   0980
09C8:  MOVLB  0
09CA:  GOTO   0A3A (RETURN)
09CE:  CLRF   01
09D0:  CLRF   02
09D2:  CLRF   00
09D4:  CLRF   03
09D6:  MOVLB  2
09D8:  MOVF   xF9,W
09DA:  BNZ   09E0
09DC:  MOVF   xF8,W
09DE:  BZ    0A10
09E0:  MOVLW  10
09E2:  MOVWF  xFA
09E4:  BCF    FD8.0
09E6:  RLCF   xF6,F
09E8:  RLCF   xF7,F
09EA:  RLCF   00,F
09EC:  RLCF   03,F
09EE:  MOVF   xF9,W
09F0:  SUBWF  03,W
09F2:  BNZ   09F8
09F4:  MOVF   xF8,W
09F6:  SUBWF  00,W
09F8:  BNC   0A08
09FA:  MOVF   xF8,W
09FC:  SUBWF  00,F
09FE:  BTFSS  FD8.0
0A00:  DECF   03,F
0A02:  MOVF   xF9,W
0A04:  SUBWF  03,F
0A06:  BSF    FD8.0
0A08:  RLCF   01,F
0A0A:  RLCF   02,F
0A0C:  DECFSZ xFA,F
0A0E:  BRA    09E4
0A10:  MOVLB  0
0A12:  RETURN 0
*
0BC2:  MOVLB  3
0BC4:  MOVF   x08,W
0BC6:  XORWF  x0A,W
0BC8:  ANDLW  80
0BCA:  MOVWF  x0C
0BCC:  BTFSS  x08.7
0BCE:  BRA    0BDA
0BD0:  COMF   x07,F
0BD2:  COMF   x08,F
0BD4:  INCF   x07,F
0BD6:  BTFSC  FD8.2
0BD8:  INCF   x08,F
0BDA:  BTFSS  x0A.7
0BDC:  BRA    0BE8
0BDE:  COMF   x09,F
0BE0:  COMF   x0A,F
0BE2:  INCF   x09,F
0BE4:  BTFSC  FD8.2
0BE6:  INCF   x0A,F
0BE8:  CLRF   01
0BEA:  CLRF   02
0BEC:  CLRF   00
0BEE:  CLRF   03
0BF0:  MOVF   x0A,W
0BF2:  BNZ   0BF8
0BF4:  MOVF   x09,W
0BF6:  BZ    0C28
0BF8:  MOVLW  10
0BFA:  MOVWF  x0B
0BFC:  BCF    FD8.0
0BFE:  RLCF   x07,F
0C00:  RLCF   x08,F
0C02:  RLCF   00,F
0C04:  RLCF   03,F
0C06:  MOVF   x0A,W
0C08:  SUBWF  03,W
0C0A:  BNZ   0C10
0C0C:  MOVF   x09,W
0C0E:  SUBWF  00,W
0C10:  BNC   0C20
0C12:  MOVF   x09,W
0C14:  SUBWF  00,F
0C16:  BTFSS  FD8.0
0C18:  DECF   03,F
0C1A:  MOVF   x0A,W
0C1C:  SUBWF  03,F
0C1E:  BSF    FD8.0
0C20:  RLCF   01,F
0C22:  RLCF   02,F
0C24:  DECFSZ x0B,F
0C26:  BRA    0BFC
0C28:  BTFSS  x0C.7
0C2A:  BRA    0C36
0C2C:  COMF   01,F
0C2E:  COMF   02,F
0C30:  INCF   01,F
0C32:  BTFSC  FD8.2
0C34:  INCF   02,F
0C36:  MOVLB  0
0C38:  RETURN 0
*
166A:  BTFSC  FD8.1
166C:  BRA    1676
166E:  MOVLW  03
1670:  MOVWF  FEA
1672:  MOVLW  05
1674:  MOVWF  FE9
1676:  CLRF   00
1678:  CLRF   01
167A:  CLRF   02
167C:  CLRF   03
167E:  MOVLB  3
1680:  CLRF   x05
1682:  CLRF   x06
1684:  CLRF   x07
1686:  CLRF   x08
1688:  MOVF   x04,W
168A:  IORWF  x03,W
168C:  IORWF  x02,W
168E:  IORWF  x01,W
1690:  BZ    16EE
1692:  MOVLW  20
1694:  MOVWF  x09
1696:  BCF    FD8.0
1698:  MOVLB  2
169A:  RLCF   xFD,F
169C:  RLCF   xFE,F
169E:  RLCF   xFF,F
16A0:  MOVLB  3
16A2:  RLCF   x00,F
16A4:  RLCF   x05,F
16A6:  RLCF   x06,F
16A8:  RLCF   x07,F
16AA:  RLCF   x08,F
16AC:  MOVF   x04,W
16AE:  SUBWF  x08,W
16B0:  BNZ   16C2
16B2:  MOVF   x03,W
16B4:  SUBWF  x07,W
16B6:  BNZ   16C2
16B8:  MOVF   x02,W
16BA:  SUBWF  x06,W
16BC:  BNZ   16C2
16BE:  MOVF   x01,W
16C0:  SUBWF  x05,W
16C2:  BNC   16E2
16C4:  MOVF   x01,W
16C6:  SUBWF  x05,F
16C8:  MOVF   x02,W
16CA:  BTFSS  FD8.0
16CC:  INCFSZ x02,W
16CE:  SUBWF  x06,F
16D0:  MOVF   x03,W
16D2:  BTFSS  FD8.0
16D4:  INCFSZ x03,W
16D6:  SUBWF  x07,F
16D8:  MOVF   x04,W
16DA:  BTFSS  FD8.0
16DC:  INCFSZ x04,W
16DE:  SUBWF  x08,F
16E0:  BSF    FD8.0
16E2:  RLCF   00,F
16E4:  RLCF   01,F
16E6:  RLCF   02,F
16E8:  RLCF   03,F
16EA:  DECFSZ x09,F
16EC:  BRA    1696
16EE:  MOVFF  305,FEF
16F2:  MOVFF  306,FEC
16F6:  MOVFF  307,FEC
16FA:  MOVFF  308,FEC
16FE:  MOVLB  0
1700:  RETURN 0
*
1A6E:  TBLRD*+
1A70:  MOVFF  FF6,2F1
1A74:  MOVFF  FF7,2F2
1A78:  MOVF   FF5,W
1A7A:  BTFSS  FA4.4
1A7C:  BRA    1A7A
1A7E:  MOVWF  F73
1A80:  MOVFF  2F1,FF6
1A84:  MOVFF  2F2,FF7
1A88:  MOVLB  2
1A8A:  DECFSZ xF0,F
1A8C:  BRA    1A90
1A8E:  BRA    1A94
1A90:  MOVLB  0
1A92:  BRA    1A6E
1A94:  MOVLB  0
1A96:  RETURN 0
1A98:  MOVLB  2
1A9A:  MOVF   xF3,W
1A9C:  CLRF   01
1A9E:  SUBWF  xF2,W
1AA0:  BC    1AA8
1AA2:  MOVFF  2F2,00
1AA6:  BRA    1AC0
1AA8:  CLRF   00
1AAA:  MOVLW  08
1AAC:  MOVWF  xF4
1AAE:  RLCF   xF2,F
1AB0:  RLCF   00,F
1AB2:  MOVF   xF3,W
1AB4:  SUBWF  00,W
1AB6:  BTFSC  FD8.0
1AB8:  MOVWF  00
1ABA:  RLCF   01,F
1ABC:  DECFSZ xF4,F
1ABE:  BRA    1AAE
1AC0:  MOVLB  0
1AC2:  RETURN 0
1AC4:  MOVF   01,W
1AC6:  MOVFF  2F0,2F2
1ACA:  MOVLW  64
1ACC:  MOVLB  2
1ACE:  MOVWF  xF3
1AD0:  MOVLB  0
1AD2:  RCALL  1A98
1AD4:  MOVFF  00,2F0
1AD8:  MOVF   01,W
1ADA:  MOVLW  30
1ADC:  BNZ   1AEE
1ADE:  MOVLB  2
1AE0:  BTFSS  xF1.1
1AE2:  BRA    1B00
1AE4:  BTFSC  xF1.3
1AE6:  BRA    1B00
1AE8:  BTFSC  xF1.4
1AEA:  MOVLW  20
1AEC:  BRA    1AF6
1AEE:  MOVLB  2
1AF0:  BCF    xF1.3
1AF2:  BCF    xF1.4
1AF4:  BSF    xF1.0
1AF6:  ADDWF  01,F
1AF8:  MOVF   01,W
1AFA:  BTFSS  FA4.4
1AFC:  BRA    1AFA
1AFE:  MOVWF  F73
1B00:  MOVFF  2F0,2F2
1B04:  MOVLW  0A
1B06:  MOVWF  xF3
1B08:  MOVLB  0
1B0A:  RCALL  1A98
1B0C:  MOVFF  00,2F0
1B10:  MOVF   01,W
1B12:  MOVLW  30
1B14:  BNZ   1B26
1B16:  MOVLB  2
1B18:  BTFSC  xF1.3
1B1A:  BRA    1B32
1B1C:  BTFSS  xF1.0
1B1E:  BRA    1B32
1B20:  BTFSC  xF1.4
1B22:  MOVLW  20
1B24:  MOVLB  0
1B26:  ADDWF  01,F
1B28:  MOVF   01,W
1B2A:  BTFSS  FA4.4
1B2C:  BRA    1B2A
1B2E:  MOVWF  F73
1B30:  MOVLB  2
1B32:  MOVLW  30
1B34:  ADDWF  xF0,F
1B36:  MOVF   xF0,W
1B38:  BTFSS  FA4.4
1B3A:  BRA    1B38
1B3C:  MOVWF  F73
1B3E:  MOVLB  0
1B40:  RETURN 0
*
20A0:  MOVLB  2
20A2:  MOVF   xFB,W
20A4:  MULWF  xFD
20A6:  MOVFF  FF3,00
20AA:  MOVFF  FF4,01
20AE:  CLRF   02
20B0:  CLRF   03
20B2:  MULWF  xFE
20B4:  MOVF   FF3,W
20B6:  ADDWF  01,F
20B8:  MOVF   FF4,W
20BA:  ADDWFC 02,F
20BC:  MOVLW  00
20BE:  ADDWFC 03,F
20C0:  MOVF   xFC,W
20C2:  MULWF  xFD
20C4:  MOVF   FF3,W
20C6:  ADDWF  01,F
20C8:  MOVF   FF4,W
20CA:  ADDWFC 02,F
20CC:  MOVLW  00
20CE:  ADDWFC 03,F
20D0:  MOVF   xFC,W
20D2:  MULWF  xFE
20D4:  MOVF   FF3,W
20D6:  ADDWF  02,F
20D8:  MOVF   FF4,W
20DA:  ADDWFC 03,F
20DC:  MOVLB  0
20DE:  RETURN 0
20E0:  MOVLB  2
20E2:  MOVF   xF7,W
20E4:  MULWF  xF9
20E6:  MOVFF  FF3,01
20EA:  MOVFF  FF4,00
20EE:  MULWF  xFA
20F0:  MOVF   FF3,W
20F2:  ADDWF  00,F
20F4:  MOVF   xF8,W
20F6:  MULWF  xF9
20F8:  MOVF   FF3,W
20FA:  ADDWFC 00,W
20FC:  MOVWF  02
20FE:  MOVLB  0
2100:  GOTO   21CA (RETURN)
*
2216:  MOVLW  8E
2218:  MOVWF  00
221A:  MOVFF  30A,01
221E:  MOVFF  309,02
2222:  CLRF   03
2224:  MOVF   01,F
2226:  BNZ   223A
2228:  MOVFF  02,01
222C:  CLRF   02
222E:  MOVLW  08
2230:  SUBWF  00,F
2232:  MOVF   01,F
2234:  BNZ   223A
2236:  CLRF   00
2238:  BRA    224A
223A:  BCF    FD8.0
223C:  BTFSC  01.7
223E:  BRA    2248
2240:  RLCF   02,F
2242:  RLCF   01,F
2244:  DECF   00,F
2246:  BRA    223A
2248:  BCF    01.7
224A:  RETURN 0
224C:  MOVLB  3
224E:  MOVF   x09,W
2250:  BTFSC  FD8.2
2252:  BRA    239E
2254:  MOVWF  x15
2256:  MOVF   x0D,W
2258:  BTFSC  FD8.2
225A:  BRA    239E
225C:  SUBWF  x15,F
225E:  BNC   226A
2260:  MOVLW  7F
2262:  ADDWF  x15,F
2264:  BTFSC  FD8.0
2266:  BRA    239E
2268:  BRA    2276
226A:  MOVLW  81
226C:  SUBWF  x15,F
226E:  BTFSS  FD8.0
2270:  BRA    239E
2272:  BTFSC  FD8.2
2274:  BRA    239E
2276:  MOVFF  315,00
227A:  CLRF   01
227C:  CLRF   02
227E:  CLRF   03
2280:  CLRF   x14
2282:  MOVFF  30A,313
2286:  BSF    x13.7
2288:  MOVFF  30B,312
228C:  MOVFF  30C,311
2290:  MOVLW  19
2292:  MOVWF  x15
2294:  MOVF   x10,W
2296:  SUBWF  x11,F
2298:  BC    22B4
229A:  MOVLW  01
229C:  SUBWF  x12,F
229E:  BC    22B4
22A0:  SUBWF  x13,F
22A2:  BC    22B4
22A4:  SUBWF  x14,F
22A6:  BC    22B4
22A8:  INCF   x14,F
22AA:  INCF   x13,F
22AC:  INCF   x12,F
22AE:  MOVF   x10,W
22B0:  ADDWF  x11,F
22B2:  BRA    2304
22B4:  MOVF   x0F,W
22B6:  SUBWF  x12,F
22B8:  BC    22DE
22BA:  MOVLW  01
22BC:  SUBWF  x13,F
22BE:  BC    22DE
22C0:  SUBWF  x14,F
22C2:  BC    22DE
22C4:  INCF   x14,F
22C6:  INCF   x13,F
22C8:  MOVF   x0F,W
22CA:  ADDWF  x12,F
22CC:  MOVF   x10,W
22CE:  ADDWF  x11,F
22D0:  BNC   2304
22D2:  INCF   x12,F
22D4:  BNZ   2304
22D6:  INCF   x13,F
22D8:  BNZ   2304
22DA:  INCF   x14,F
22DC:  BRA    2304
22DE:  MOVF   x0E,W
22E0:  IORLW  80
22E2:  SUBWF  x13,F
22E4:  BC    2302
22E6:  MOVLW  01
22E8:  SUBWF  x14,F
22EA:  BC    2302
22EC:  INCF   x14,F
22EE:  MOVF   x0E,W
22F0:  IORLW  80
22F2:  ADDWF  x13,F
22F4:  MOVF   x0F,W
22F6:  ADDWF  x12,F
22F8:  BNC   22CC
22FA:  INCF   x13,F
22FC:  BNZ   22CC
22FE:  INCF   x14,F
2300:  BRA    22CC
2302:  BSF    03.0
2304:  DECFSZ x15,F
2306:  BRA    230A
2308:  BRA    2320
230A:  BCF    FD8.0
230C:  RLCF   x11,F
230E:  RLCF   x12,F
2310:  RLCF   x13,F
2312:  RLCF   x14,F
2314:  BCF    FD8.0
2316:  RLCF   03,F
2318:  RLCF   02,F
231A:  RLCF   01,F
231C:  RLCF   x16,F
231E:  BRA    2294
2320:  BTFSS  x16.0
2322:  BRA    2330
2324:  BCF    FD8.0
2326:  RRCF   01,F
2328:  RRCF   02,F
232A:  RRCF   03,F
232C:  RRCF   x16,F
232E:  BRA    2334
2330:  DECF   00,F
2332:  BZ    239E
2334:  BTFSC  x16.7
2336:  BRA    2374
2338:  BCF    FD8.0
233A:  RLCF   x11,F
233C:  RLCF   x12,F
233E:  RLCF   x13,F
2340:  RLCF   x14,F
2342:  MOVF   x10,W
2344:  SUBWF  x11,F
2346:  BC    2356
2348:  MOVLW  01
234A:  SUBWF  x12,F
234C:  BC    2356
234E:  SUBWF  x13,F
2350:  BC    2356
2352:  SUBWF  x14,F
2354:  BNC   238A
2356:  MOVF   x0F,W
2358:  SUBWF  x12,F
235A:  BC    2366
235C:  MOVLW  01
235E:  SUBWF  x13,F
2360:  BC    2366
2362:  SUBWF  x14,F
2364:  BNC   238A
2366:  MOVF   x0E,W
2368:  IORLW  80
236A:  SUBWF  x13,F
236C:  BC    2374
236E:  MOVLW  01
2370:  SUBWF  x14,F
2372:  BNC   238A
2374:  INCF   03,F
2376:  BNZ   238A
2378:  INCF   02,F
237A:  BNZ   238A
237C:  INCF   01,F
237E:  BNZ   238A
2380:  INCF   00,F
2382:  BZ    239E
2384:  RRCF   01,F
2386:  RRCF   02,F
2388:  RRCF   03,F
238A:  MOVFF  30A,315
238E:  MOVF   x0E,W
2390:  XORWF  x15,F
2392:  BTFSS  x15.7
2394:  BRA    239A
2396:  BSF    01.7
2398:  BRA    23A6
239A:  BCF    01.7
239C:  BRA    23A6
239E:  CLRF   00
23A0:  CLRF   01
23A2:  CLRF   02
23A4:  CLRF   03
23A6:  MOVLB  0
23A8:  RETURN 0
23AA:  MOVLW  8E
23AC:  MOVWF  00
23AE:  MOVFF  306,01
23B2:  MOVFF  305,02
23B6:  CLRF   03
23B8:  BTFSS  01.7
23BA:  BRA    23C6
23BC:  COMF   01,F
23BE:  COMF   02,F
23C0:  INCF   02,F
23C2:  BNZ   23C6
23C4:  INCF   01,F
23C6:  MOVF   01,F
23C8:  BNZ   23DC
23CA:  MOVFF  02,01
23CE:  CLRF   02
23D0:  MOVLW  08
23D2:  SUBWF  00,F
23D4:  MOVF   01,F
23D6:  BNZ   23DC
23D8:  CLRF   00
23DA:  BRA    23F8
23DC:  BCF    FD8.0
23DE:  BTFSC  01.7
23E0:  BRA    23EA
23E2:  RLCF   02,F
23E4:  RLCF   01,F
23E6:  DECF   00,F
23E8:  BRA    23DC
23EA:  MOVLB  3
23EC:  BTFSS  x06.7
23EE:  BRA    23F4
23F0:  MOVLB  0
23F2:  BRA    23F8
23F4:  BCF    01.7
23F6:  MOVLB  0
23F8:  RETURN 0
23FA:  MOVLB  3
23FC:  MOVF   x09,W
23FE:  BTFSC  FD8.2
2400:  BRA    24E4
2402:  MOVWF  00
2404:  MOVF   x0D,W
2406:  BTFSC  FD8.2
2408:  BRA    24E4
240A:  ADDWF  00,F
240C:  BNC   2416
240E:  MOVLW  81
2410:  ADDWF  00,F
2412:  BC    24E4
2414:  BRA    241E
2416:  MOVLW  7F
2418:  SUBWF  00,F
241A:  BNC   24E4
241C:  BZ    24E4
241E:  MOVFF  30A,311
2422:  MOVF   x0E,W
2424:  XORWF  x11,F
2426:  BSF    x0A.7
2428:  BSF    x0E.7
242A:  MOVF   x0C,W
242C:  MULWF  x10
242E:  MOVFF  FF4,313
2432:  MOVF   x0B,W
2434:  MULWF  x0F
2436:  MOVFF  FF4,03
243A:  MOVFF  FF3,312
243E:  MULWF  x10
2440:  MOVF   FF3,W
2442:  ADDWF  x13,F
2444:  MOVF   FF4,W
2446:  ADDWFC x12,F
2448:  MOVLW  00
244A:  ADDWFC 03,F
244C:  MOVF   x0C,W
244E:  MULWF  x0F
2450:  MOVF   FF3,W
2452:  ADDWF  x13,F
2454:  MOVF   FF4,W
2456:  ADDWFC x12,F
2458:  MOVLW  00
245A:  CLRF   02
245C:  ADDWFC 03,F
245E:  ADDWFC 02,F
2460:  MOVF   x0A,W
2462:  MULWF  x10
2464:  MOVF   FF3,W
2466:  ADDWF  x12,F
2468:  MOVF   FF4,W
246A:  ADDWFC 03,F
246C:  MOVLW  00
246E:  ADDWFC 02,F
2470:  MOVF   x0A,W
2472:  MULWF  x0F
2474:  MOVF   FF3,W
2476:  ADDWF  03,F
2478:  MOVF   FF4,W
247A:  ADDWFC 02,F
247C:  MOVLW  00
247E:  CLRF   01
2480:  ADDWFC 01,F
2482:  MOVF   x0C,W
2484:  MULWF  x0E
2486:  MOVF   FF3,W
2488:  ADDWF  x12,F
248A:  MOVF   FF4,W
248C:  ADDWFC 03,F
248E:  MOVLW  00
2490:  ADDWFC 02,F
2492:  ADDWFC 01,F
2494:  MOVF   x0B,W
2496:  MULWF  x0E
2498:  MOVF   FF3,W
249A:  ADDWF  03,F
249C:  MOVF   FF4,W
249E:  ADDWFC 02,F
24A0:  MOVLW  00
24A2:  ADDWFC 01,F
24A4:  MOVF   x0A,W
24A6:  MULWF  x0E
24A8:  MOVF   FF3,W
24AA:  ADDWF  02,F
24AC:  MOVF   FF4,W
24AE:  ADDWFC 01,F
24B0:  INCF   00,F
24B2:  BTFSC  01.7
24B4:  BRA    24C0
24B6:  RLCF   x12,F
24B8:  RLCF   03,F
24BA:  RLCF   02,F
24BC:  RLCF   01,F
24BE:  DECF   00,F
24C0:  MOVLW  00
24C2:  BTFSS  x12.7
24C4:  BRA    24DA
24C6:  INCF   03,F
24C8:  ADDWFC 02,F
24CA:  ADDWFC 01,F
24CC:  MOVF   01,W
24CE:  BNZ   24DA
24D0:  MOVF   02,W
24D2:  BNZ   24DA
24D4:  MOVF   03,W
24D6:  BNZ   24DA
24D8:  INCF   00,F
24DA:  BTFSC  x11.7
24DC:  BSF    01.7
24DE:  BTFSS  x11.7
24E0:  BCF    01.7
24E2:  BRA    24EC
24E4:  CLRF   00
24E6:  CLRF   01
24E8:  CLRF   02
24EA:  CLRF   03
24EC:  MOVLB  0
24EE:  RETURN 0
24F0:  MOVLW  8E
24F2:  MOVWF  00
24F4:  MOVLB  3
24F6:  MOVF   x05,W
24F8:  SUBWF  00,F
24FA:  MOVFF  306,02
24FE:  MOVFF  307,01
2502:  BSF    02.7
2504:  MOVF   00,F
2506:  BZ    251A
2508:  BCF    FD8.0
250A:  MOVF   02,F
250C:  BNZ   2512
250E:  MOVF   01,F
2510:  BZ    251A
2512:  RRCF   02,F
2514:  RRCF   01,F
2516:  DECFSZ 00,F
2518:  BRA    2508
251A:  BTFSS  x06.7
251C:  BRA    2528
251E:  COMF   01,F
2520:  COMF   02,F
2522:  INCF   01,F
2524:  BTFSC  FD8.2
2526:  INCF   02,F
2528:  MOVLB  0
252A:  RETURN 0
252C:  MOVLB  3
252E:  MOVF   x06,W
2530:  XORWF  x08,W
2532:  ANDLW  80
2534:  MOVWF  x0A
2536:  BTFSS  x06.7
2538:  BRA    2544
253A:  COMF   x05,F
253C:  COMF   x06,F
253E:  INCF   x05,F
2540:  BTFSC  FD8.2
2542:  INCF   x06,F
2544:  BTFSS  x08.7
2546:  BRA    2552
2548:  COMF   x07,F
254A:  COMF   x08,F
254C:  INCF   x07,F
254E:  BTFSC  FD8.2
2550:  INCF   x08,F
2552:  MOVF   x05,W
2554:  MULWF  x07
2556:  MOVFF  FF3,01
255A:  MOVFF  FF4,00
255E:  MULWF  x08
2560:  MOVF   FF3,W
2562:  ADDWF  00,F
2564:  MOVF   x06,W
2566:  MULWF  x07
2568:  MOVF   FF3,W
256A:  ADDWFC 00,W
256C:  MOVWF  02
256E:  BTFSS  x0A.7
2570:  BRA    257C
2572:  COMF   01,F
2574:  COMF   02,F
2576:  INCF   01,F
2578:  BTFSC  FD8.2
257A:  INCF   02,F
257C:  MOVLB  0
257E:  GOTO   261E (RETURN)
*
272E:  MOVFF  FEA,2F7
2732:  MOVFF  FE9,2F6
2736:  MOVLB  2
2738:  SWAPF  xF0,W
273A:  IORLW  F0
273C:  MOVWF  xF2
273E:  ADDWF  xF2,F
2740:  ADDLW  E2
2742:  MOVWF  xF3
2744:  ADDLW  32
2746:  MOVWF  xF5
2748:  MOVF   xF0,W
274A:  ANDLW  0F
274C:  ADDWF  xF3,F
274E:  ADDWF  xF3,F
2750:  ADDWF  xF5,F
2752:  ADDLW  E9
2754:  MOVWF  xF4
2756:  ADDWF  xF4,F
2758:  ADDWF  xF4,F
275A:  SWAPF  xEF,W
275C:  ANDLW  0F
275E:  ADDWF  xF4,F
2760:  ADDWF  xF5,F
2762:  RLCF   xF4,F
2764:  RLCF   xF5,F
2766:  COMF   xF5,F
2768:  RLCF   xF5,F
276A:  MOVF   xEF,W
276C:  ANDLW  0F
276E:  ADDWF  xF5,F
2770:  RLCF   xF2,F
2772:  MOVLW  07
2774:  MOVWF  xF1
2776:  MOVLW  0A
2778:  DECF   xF4,F
277A:  ADDWF  xF5,F
277C:  BNC   2778
277E:  DECF   xF3,F
2780:  ADDWF  xF4,F
2782:  BNC   277E
2784:  DECF   xF2,F
2786:  ADDWF  xF3,F
2788:  BNC   2784
278A:  DECF   xF1,F
278C:  ADDWF  xF2,F
278E:  BNC   278A
2790:  MOVLW  02
2792:  MOVWF  FEA
2794:  MOVLW  F1
2796:  MOVWF  FE9
2798:  MOVLW  07
279A:  ANDWF  xF6,W
279C:  BCF    xF6.6
279E:  ADDWF  FE9,F
27A0:  MOVLW  00
27A2:  ADDWFC FEA,F
27A4:  MOVF   FE9,W
27A6:  SUBLW  F5
27A8:  BNZ   27B2
27AA:  MOVF   FEA,W
27AC:  SUBLW  02
27AE:  BNZ   27B2
27B0:  BSF    xF6.6
27B2:  MOVF   FEF,W
27B4:  MOVWF  00
27B6:  BNZ   27C8
27B8:  BTFSC  xF6.6
27BA:  BRA    27C8
27BC:  BTFSC  xF6.4
27BE:  BRA    27D8
27C0:  BTFSC  xF6.3
27C2:  BRA    27C8
27C4:  MOVLW  20
27C6:  BRA    27CE
27C8:  BSF    xF6.3
27CA:  BCF    xF6.4
27CC:  MOVLW  30
27CE:  ADDWF  00,F
27D0:  MOVF   00,W
27D2:  BTFSS  FA4.4
27D4:  BRA    27D2
27D6:  MOVWF  F73
27D8:  MOVF   FEE,W
27DA:  BTFSS  xF6.6
27DC:  BRA    27A4
27DE:  MOVLB  0
27E0:  GOTO   390A (RETURN)
27E4:  MOVFF  FEA,2F7
27E8:  MOVFF  FE9,2F6
27EC:  MOVLB  2
27EE:  BTFSS  xF0.7
27F0:  BRA    2802
27F2:  BSF    xF6.7
27F4:  BTFSS  xF6.4
27F6:  INCF   xF6,F
27F8:  COMF   xEF,F
27FA:  COMF   xF0,F
27FC:  INCF   xEF,F
27FE:  BTFSC  FD8.2
2800:  INCF   xF0,F
2802:  SWAPF  xF0,W
2804:  IORLW  F0
2806:  MOVWF  xF2
2808:  ADDWF  xF2,F
280A:  ADDLW  E2
280C:  MOVWF  xF3
280E:  ADDLW  32
2810:  MOVWF  xF5
2812:  MOVF   xF0,W
2814:  ANDLW  0F
2816:  ADDWF  xF3,F
2818:  ADDWF  xF3,F
281A:  ADDWF  xF5,F
281C:  ADDLW  E9
281E:  MOVWF  xF4
2820:  ADDWF  xF4,F
2822:  ADDWF  xF4,F
2824:  SWAPF  xEF,W
2826:  ANDLW  0F
2828:  ADDWF  xF4,F
282A:  ADDWF  xF5,F
282C:  RLCF   xF4,F
282E:  RLCF   xF5,F
2830:  COMF   xF5,F
2832:  RLCF   xF5,F
2834:  MOVF   xEF,W
2836:  ANDLW  0F
2838:  ADDWF  xF5,F
283A:  RLCF   xF2,F
283C:  MOVLW  07
283E:  MOVWF  xF1
2840:  MOVLW  0A
2842:  DECF   xF4,F
2844:  ADDWF  xF5,F
2846:  BNC   2842
2848:  DECF   xF3,F
284A:  ADDWF  xF4,F
284C:  BNC   2848
284E:  DECF   xF2,F
2850:  ADDWF  xF3,F
2852:  BNC   284E
2854:  DECF   xF1,F
2856:  ADDWF  xF2,F
2858:  BNC   2854
285A:  MOVLW  02
285C:  MOVWF  FEA
285E:  MOVLW  F1
2860:  MOVWF  FE9
2862:  MOVLW  07
2864:  ANDWF  xF6,W
2866:  BCF    xF6.6
2868:  MOVF   FED,F
286A:  ANDWF  xF6,W
286C:  BNZ   287C
286E:  BTFSC  xF6.4
2870:  MOVF   FEE,F
2872:  BTFSC  xF6.4
2874:  BRA    287C
2876:  MOVLW  20
2878:  MOVWF  00
287A:  BRA    28BE
287C:  ADDWF  FE9,F
287E:  MOVLW  00
2880:  ADDWFC FEA,F
2882:  MOVF   FE9,W
2884:  SUBLW  F5
2886:  BNZ   2890
2888:  MOVF   FEA,W
288A:  SUBLW  02
288C:  BNZ   2890
288E:  BSF    xF6.6
2890:  MOVF   FEF,W
2892:  MOVWF  00
2894:  BNZ   28A6
2896:  BTFSC  xF6.6
2898:  BRA    28A6
289A:  BTFSC  xF6.4
289C:  BRA    28C6
289E:  BTFSC  xF6.3
28A0:  BRA    28A6
28A2:  MOVLW  20
28A4:  BRA    28BC
28A6:  BTFSS  xF6.7
28A8:  BRA    28B6
28AA:  MOVLW  2D
28AC:  MOVWF  00
28AE:  MOVF   FED,W
28B0:  BCF    xF6.6
28B2:  BCF    xF6.7
28B4:  BRA    28BE
28B6:  BSF    xF6.3
28B8:  BCF    xF6.4
28BA:  MOVLW  30
28BC:  ADDWF  00,F
28BE:  MOVF   00,W
28C0:  BTFSS  FA4.4
28C2:  BRA    28C0
28C4:  MOVWF  F73
28C6:  MOVF   FEE,W
28C8:  BTFSS  xF6.6
28CA:  BRA    2882
28CC:  MOVLB  0
28CE:  GOTO   392E (RETURN)
*
2FB6:  MOVFF  2F5,2FC
2FBA:  MOVLB  2
2FBC:  MOVF   xF9,W
2FBE:  XORWF  xFC,F
2FC0:  BTFSS  xFC.7
2FC2:  BRA    2FCE
2FC4:  BCF    FD8.2
2FC6:  BCF    FD8.0
2FC8:  BTFSC  xF5.7
2FCA:  BSF    FD8.0
2FCC:  BRA    302C
2FCE:  MOVFF  2F5,2FC
2FD2:  MOVFF  2F8,2FD
2FD6:  MOVF   xF4,W
2FD8:  SUBWF  xFD,F
2FDA:  BZ    2FE8
2FDC:  BTFSS  xFC.7
2FDE:  BRA    302C
2FE0:  MOVF   FD8,W
2FE2:  XORLW  01
2FE4:  MOVWF  FD8
2FE6:  BRA    302C
2FE8:  MOVFF  2F9,2FD
2FEC:  MOVF   xF5,W
2FEE:  SUBWF  xFD,F
2FF0:  BZ    2FFE
2FF2:  BTFSS  xFC.7
2FF4:  BRA    302C
2FF6:  MOVF   FD8,W
2FF8:  XORLW  01
2FFA:  MOVWF  FD8
2FFC:  BRA    302C
2FFE:  MOVFF  2FA,2FD
3002:  MOVF   xF6,W
3004:  SUBWF  xFD,F
3006:  BZ    3014
3008:  BTFSS  xFC.7
300A:  BRA    302C
300C:  MOVF   FD8,W
300E:  XORLW  01
3010:  MOVWF  FD8
3012:  BRA    302C
3014:  MOVFF  2FB,2FD
3018:  MOVF   xF7,W
301A:  SUBWF  xFD,F
301C:  BZ    302A
301E:  BTFSS  xFC.7
3020:  BRA    302C
3022:  MOVF   FD8,W
3024:  XORLW  01
3026:  MOVWF  FD8
3028:  BRA    302C
302A:  BCF    FD8.0
302C:  MOVLB  0
302E:  RETURN 0
....................  
.................... #list 
....................  
....................     //#include <18F4520.h> 
....................     #device adc=10 
....................     #device HIGH_INTS=TRUE  
....................     #device PASS_STRINGS=IN_RAM   
....................    // #device ICD=FALSE 
....................  
....................     #FUSES NOWDT                    //No Watch Dog Timer 
....................     #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
....................     #FUSES INTRC_IO                 //Internal RC Osc, no CLKOUT 
....................     #FUSES PLLEN                  //4X HW PLL disabled, 4X PLL enabled in software 
....................     #FUSES NOPUT                      //Power Up Timer 
....................     #FUSES NOBROWNOUT               //No brownout reset 
....................     #FUSES WDT_SW                   //No Watch Dog Timer, enabled in Software 
....................     #FUSES NOPBADEN                 //PORTB pins are configured as digital I/O on RESET 
....................     #FUSES MCLR                   //Master Clear pin used for I/O 
....................     #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................     #FUSES PROTECT                  //Code protected from reads 
....................     //#FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................     #FUSES NOFCMEN 
....................     #FUSES NOHFOFST      
....................     #FUSES NODEBUG  
....................  
....................     #use delay(internal=64MHz) // 
*
04F8:  MOVLW  03
04FA:  MOVWF  FEA
04FC:  MOVLW  0A
04FE:  MOVWF  FE9
0500:  MOVF   FEF,W
0502:  BZ    0520
0504:  MOVLW  14
0506:  MOVWF  01
0508:  CLRF   00
050A:  DECFSZ 00,F
050C:  BRA    050A
050E:  DECFSZ 01,F
0510:  BRA    0508
0512:  MOVLW  BF
0514:  MOVWF  00
0516:  DECFSZ 00,F
0518:  BRA    0516
051A:  BRA    051C
051C:  DECFSZ FEF,F
051E:  BRA    0504
0520:  RETURN 0
*
2EAC:  MOVLW  01
2EAE:  MOVLB  2
2EB0:  SUBWF  xF1,F
2EB2:  BNC   2ECC
2EB4:  MOVLW  02
2EB6:  MOVWF  FEA
2EB8:  MOVLW  F1
2EBA:  MOVWF  FE9
2EBC:  MOVF   FEF,W
2EBE:  BZ    2ECC
2EC0:  MOVLW  04
2EC2:  MOVWF  00
2EC4:  DECFSZ 00,F
2EC6:  BRA    2EC4
2EC8:  DECFSZ FEF,F
2ECA:  BRA    2EC0
2ECC:  MOVLB  0
2ECE:  RETURN 0
....................  
....................     #use fast_io(d) 
....................    // #use rs232(baud=9600,parity=N,UART2,bits=8,stream=usbSerial)  //uart1 
....................     #use rs232(baud=9600,parity=N,xmit=PIN_D6, rcv=PIN_D7, bits=8,STREAM=usbSerial)  
....................  
....................    // #use rs232(baud=9600,parity=N, xmit=PIN_C6, rcv=PIN_C7,bits=8,DISABLE_INTS,STREAM=dfPlayerSerial) 
....................     #use rs232 (baud=9600, UART1, parity=N, stop=1, ERRORS,STREAM=dfPlayerSerial) 
*
061A:  BTFSS  F9E.4
061C:  BRA    061A
061E:  MOVWF  FAD
0620:  GOTO   06BA (RETURN)
....................      
....................  
....................     extern unsigned int32 timerIntSay; 
....................  
....................  
....................  
.................... #ifdef   __cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif   /* LFR_TREN_H */ 
....................  
....................  
.................... #include "tanimlamalar.h" 
.................... /*  
....................  * File:   tanimlamalar.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 31 Temmuz 2019 Çarþamba, 09:02 
....................  */ 
....................  
.................... #ifndef TANIMLAMALAR_H 
.................... #define	TANIMLAMALAR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................  
....................     #define buzzerPIN PIN_C0 
....................  
....................     #define FAN_PIN PIN_C4 
....................     #define ACIL_DUR_SENS_PIN PIN_B3    //PIN_A7  LED1 
....................     #define LED2_PIN PIN_A6 
....................     #define IR_LED_ANOT_PIN PIN_C3 
....................  
....................     #define fan_on() output_high(FAN_PIN); 
....................     #define fan_off() output_low(FAN_PIN);  
....................  
....................     #define led1_on() output_high(LED1_PIN); 
....................     #define led1_off() output_low(LED1_PIN); 
....................  
....................     #define led2_on() output_high(LED2_PIN); 
....................     #define led2_off() output_low(LED2_PIN); 
....................      
....................     #define ir_led_on() output_low(IR_LED_ANOT_PIN); 
....................     #define ir_led_off() output_high(IR_LED_ANOT_PIN); 
....................  
....................     #define buzzer_off()  output_low(buzzerPIN) 
....................     #define bip_yazildi() bipp(10,20,buzzerPIN) //sure,sayi,pin 
....................     #define bip_rf_var() bipp(50,2,buzzerPIN)  //sure,sayi,pin    
....................     #define bip_kurulum() bipp(25,2,buzzerPIN)  //sure,sayi,pin 
....................     #define bip_hata() bipp(3,100,buzzerPIN) 
....................     #define bip_tus() bipp(5,2,buzzerPIN)  //sure,sayi,pin 
....................  
....................     #define lfr_led_goster(sens)  hc595_spi_yaz(sens,8); 
....................  
....................     #define pwmMaxDeger 700 //200     //5Khz sinyal 
....................      
....................     #define ORT_HIZ_MIN 100 // soft kalkýþ için deðerler... 
....................     #define ORT_HIZ_MAX 600    //350  
....................  
....................     #define solMotor_hiz(v) set_pwm2_duty(v); 
....................     #define sagMotor_hiz(v) set_pwm1_duty(v); 
....................     #define solMotorDur()  set_pwm2_duty(0);  
....................     #define sagMotorDur()  set_pwm1_duty(0);  
....................  
....................     #define trenDur() solMotorDur();sagMotorDur() 
....................     #define ileri_git(v_sol,v_sag) solMotor_hiz(v_sol);sagMotor_hiz(v_sag) 
....................     #define sola_don(hiz, sure) solMotor_hiz((int16)(hiz/10));sagMotor_hiz(hiz);delay_ms(sure) 
....................     #define saga_don(hiz,sure) solMotor_hiz(hiz);sagMotor_hiz((int16)(hiz/10));delay_ms(sure) 
....................  
....................     #define AN_CHANNEL_AKU 8 
....................     #define ORNEK_SAYISI 8 
....................     #define SENS_SAYISI 8 
....................  
....................     #define HAM_DEGER 0 
....................     #define ORT_DEGER 1 
....................     #define MAX_DEGER 2 
....................     #define MIN_DEGER 3 
....................  
....................     #define MAX_HATA_DEGERI 1750 
....................  
....................     #define GERILIM_VAR 1 
....................     #define GERILIM_YOK 0 
....................  
....................     #define EMITTER_ON 1 
....................     #define EMITTER_OFF 0 
....................      
....................     #define BEYAZ 0x00 
....................     #define SIYAH 0x01 
....................  
....................     #define ASIRI_ISIK  'A' 
....................     #define NORMAL_ISIK 'N' 
....................     #define DUSUK_ISIK 'D' 
....................     #define KARANLIK_ISIK 'K' 
....................      
....................     #define ORTALAMA_DEGER 'O' 
....................     #define DIGITAL_DEGER   'B' 
....................  
....................     #define HATA_REF    1750 
....................  
....................     #define ee_adr_jtn 0x10 
....................     #define ee_adr_ortHiz_H 0x00  //high   //16 bitlik sayý 
....................     #define ee_adr_ortHiz_L 0x01  //low 
....................     #define ee_adr_df_ses   0x02 
....................  
....................     #define mp3_stop_100mS() mp3_stop();delay_ms(100) 
....................  
....................     //433MHz alýcý baðlantý pinleri 
....................     #define tus1 PIN_D0 
....................     #define tus2 PIN_D1 
....................     #define tus3 PIN_D2 
....................     #define tus4 PIN_D3 
....................     #define tus5 PIN_D4 
....................     #define tus6 PIN_D5 
....................     #define tus_vt  PIN_B0 
....................  
....................     #define ses_miniko          1 
....................     #define ses_demo            2 
....................     #define ses_getReady        3 
....................     #define ses_remix           4 
....................     #define ses_trenDuduk       5 
....................     #define ses_sureAyar        6 
....................     #define ses_kumandaKontrol  7 
....................     #define ses_cizgiTakip      8 
....................     #define TREN_DUDUK          5 
....................     #define OYUN_SON_JENERIK    2 
....................  
....................     #define SES_AKU_SARJ_50     26 
....................     #define SES_AKU_SARJ_25     27 
....................     #define SES_AKU_SARJ_DUSUK  28 
....................     #define SES_AKU_SARJ_TAK    29 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TANIMLAMALAR_H */ 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define STREAM_SERIAL_INPUT dfPlayerSerial 
.................... //#include "_input.c" 
....................  
.................... #define RAND_MAX 9      //rand() fonksiyonu için gerekli  RAND_MAX=MP3_SD_RASTGELE_MAX_SAYI olmalý 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0A14:  MOVFF  23,2F6
0A18:  MOVFF  22,2F5
0A1C:  MOVFF  21,2F4
0A20:  MOVFF  20,2F3
0A24:  MOVLW  41
0A26:  MOVLB  2
0A28:  MOVWF  xFA
0A2A:  MOVLW  C6
0A2C:  MOVWF  xF9
0A2E:  MOVLW  4E
0A30:  MOVWF  xF8
0A32:  MOVLW  6D
0A34:  MOVWF  xF7
0A36:  MOVLB  0
0A38:  BRA    0966
0A3A:  MOVLW  39
0A3C:  MOVLB  2
0A3E:  ADDWF  00,W
0A40:  MOVWF  20
0A42:  MOVLW  30
0A44:  ADDWFC 01,W
0A46:  MOVWF  21
0A48:  MOVLW  00
0A4A:  ADDWFC 02,W
0A4C:  MOVWF  22
0A4E:  MOVLW  00
0A50:  ADDWFC 03,W
0A52:  MOVWF  23
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0A54:  MOVFF  22,00
0A58:  MOVFF  23,01
0A5C:  CLRF   02
0A5E:  CLRF   03
0A60:  MOVFF  23,2F5
0A64:  MOVFF  22,2F4
0A68:  MOVFF  23,2F7
0A6C:  MOVFF  22,2F6
0A70:  CLRF   xF9
0A72:  MOVLW  09
0A74:  MOVWF  xF8
0A76:  MOVLB  0
0A78:  RCALL  09CE
0A7A:  MOVFF  00,01
0A7E:  MOVFF  03,02
0A82:  GOTO   0AD2 (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
089C:  MOVFF  2F2,23
08A0:  MOVFF  2F1,22
08A4:  MOVFF  2F0,21
08A8:  MOVFF  2EF,20
08AC:  GOTO   36F6 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "timer.h" 
.................... /*  
....................  * File:   timer.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 25 Aralýk 2018 Salý, 08:35 
....................  */ 
....................  
.................... #ifndef TIMER_H 
.................... #define	TIMER_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................     unsigned int32 timerIntSay=0; 
....................      
....................     #define millis() timerIntSay 
....................     #define set_millis(x) timerIntSay=x 
....................  
....................     void millis_kurulum(); 
....................     void Timer0_int(); 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TIMER_H */ 
....................  
....................  
.................... #include "hc595_spi.c" 
....................  
.................... //bit_set(var, bit) 
....................  
....................  
.................... #define load PIN_B5 
.................... #define data PIN_B1 
.................... #define clock PIN_B4 
....................  
.................... #define CLK_DELAY 1     //uS olarak 
....................  
....................  
.................... void hc595_spi_yaz(unsigned int16 veri,unsigned char yaz_bit)//MSB first gönderir 
08B0:  MOVLB  2
08B2:  CLRF   xF5
.................... {                                                     
....................       int x=0; 
....................       output_low(load);         //load=0;  
08B4:  BCF    F93.5
08B6:  BCF    F8A.5
....................       for(x=0;x<yaz_bit;++x)                            
08B8:  CLRF   xF5
08BA:  MOVF   xF4,W
08BC:  SUBWF  xF5,W
08BE:  BC    08FE
....................       { 
....................         if (bit_test(veri,((yaz_bit-1)-x)))  
08C0:  MOVLW  01
08C2:  SUBWF  xF4,W
08C4:  BSF    FD8.0
08C6:  SUBFWB xF5,W
08C8:  MOVWF  xF6
08CA:  MOVFF  2F3,03
08CE:  MOVFF  2F2,02
08D2:  MOVF   xF6,W
08D4:  MOVWF  00
08D6:  BZ    08E2
08D8:  BCF    FD8.0
08DA:  RRCF   03,F
08DC:  RRCF   02,F
08DE:  DECFSZ 00,F
08E0:  BRA    08D8
08E2:  MOVF   02,W
08E4:  BTFSS  02.0
08E6:  BRA    08EE
....................              output_high(data);         //data=1;  
08E8:  BCF    F93.1
08EA:  BSF    F8A.1
08EC:  BRA    08F2
....................         else  output_low(data);             //data=0;    
08EE:  BCF    F93.1
08F0:  BCF    F8A.1
....................          output_low(clock);         //clock=0; 
08F2:  BCF    F93.4
08F4:  BCF    F8A.4
....................          output_high(clock);        //clock=1; 
08F6:  BCF    F93.4
08F8:  BSF    F8A.4
08FA:  INCF   xF5,F
08FC:  BRA    08BA
....................       }                                       
....................       output_high(load);         //load=1;             
08FE:  BCF    F93.5
0900:  BSF    F8A.5
0902:  MOVLB  0
0904:  RETURN 0
.................... }//Sonu 
....................  
.................... void hc595_spi_24bit_yaz(unsigned int8 veriH,unsigned int8 veriM,unsigned int8 veriL)//MSB first  
.................... {                                                     
....................       int x=0; 
....................        
....................       output_low(load);         //load=0;  
....................        
....................       for(x=0;x<8;++x)                            
....................       { 
....................         if (bit_test(veriH,((7)-x))) //8-1=7 
....................              output_high(data);         //data=1;  
....................         else  output_low(data);             //data=0;    
....................          output_low(clock);         //clock=0; 
....................          delay_us(CLK_DELAY); 
....................          output_high(clock);        //clock=1; 
....................          delay_us(CLK_DELAY); 
....................       }  
....................        
....................       for(x=0;x<8;++x)                            
....................       { 
....................         if (bit_test(veriM,((7)-x)))  
....................              output_high(data);         //data=1;  
....................         else  output_low(data);             //data=0;    
....................          output_low(clock);         //clock=0; 
....................          delay_us(CLK_DELAY); 
....................          output_high(clock);        //clock=1; 
....................          delay_us(CLK_DELAY); 
....................       }  
....................        
....................       for(x=0;x<8;++x)                            
....................       { 
....................         if (bit_test(veriL,((7)-x)))  
....................              output_high(data);         //data=1;  
....................         else  output_low(data);             //data=0;    
....................          output_low(clock);         //clock=0; 
....................          delay_us(CLK_DELAY); 
....................          output_high(clock);        //clock=1; 
....................          delay_us(CLK_DELAY); 
....................       } 
....................       output_high(load);         //load=1;     
....................       
....................       output_toggle(PIN_A4); 
.................... }//Sonu 
....................  
.................... #include "dfPlayer.c" 
.................... #include "dfPlayer.h" 
.................... /*  
....................  * File:   dfPlayer.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 28 Þubat 2018 Çarþamba, 16:11 
....................  */ 
....................  
.................... /* 
....................  *	name:				DFPlayer_Mini_Mp3 
....................  *	version:			1.0 
....................  *	Author:				lisper <lisper.li@dfrobot.com> 
....................  *	Date:				2014-05-22 
....................  *	official website:		http://www.dfrobot.com 
....................  *	Products page:			http://www.dfrobot.com/index.php?route=product/product&product_id=1121#.U5Z_RYbUN8E 
....................  *	Description:			mp3 library for DFPlayer mini board 
....................  *					        note: mp3 file must put into mp3 folder in your tf card 
....................  */ 
....................  
.................... #ifndef DFPLAYER_H 
.................... #define	DFPLAYER_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................     typedef unsigned char mbyte; 
....................      
....................     #define startByte 0x7E 
....................     #define endByte 0xEF 
....................     #define versionByte 0xFF 
....................     #define dataLength 0x06 
....................     #define infoReq 0x01        //0x01 
....................     #define isDebug false 
....................     #define dfPlayerMaxSes 25 // dec30:0x1E 
....................     #define dfPlayerNSes 20 //20 
....................  
....................     #define DF_BUSY_PIN  PIN_C5 //PIN_B3 
....................  
....................     #define  MP3_SD_RASTGELE_BASLANGIC 30 
....................     #define  MP3_SD_RASTGELE_MAX_SAYI 9 
....................  
....................     #define dfPplayerMaxSes() mp3_set_volume (dfPlayerMaxSes);delay_ms(100)//48 
....................     #define dfPlayerNormSes() mp3_set_volume(dfPlayerNSes);delay_ms(100)  // 
....................     #define dfPlayerMinSes() mp3_set_volume(1);delay_ms(100) 
....................  
....................     unsigned int8 df_player_ses=15; 
....................  
....................     void sendCommand(mbyte Command, mbyte Param1, mbyte Param2); 
....................     void mp3_set_volume (char vol); 
....................     void mp3_set_equalizer(char eq); 
....................     void mp3_play_physical(unsigned int16 fileNum); 
....................     void mp3_get_error (); 
....................     void mp3_single_loop (unsigned int16 fileNum) ; 
....................     void mp3_enableLoopAll(); 
....................     void mp3_disbleLoopAll(); 
....................     void mp3_getData(*dizi); 
....................     void mp3_DataSeriGonder(*dizi,char len); 
....................     void mp3_stop(); 
....................     void mp3_reset(); 
....................     void mp3_baslangic(); 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* DFPLAYER_H */ 
....................  
....................  
....................  
.................... //Bu haliyle SD kart ana klasörüne mp3 yada vaw dosya atýlmasý 
.................... // fark etmiyor her ikisinide çalýþtýrýyor.. Ýsimler ayný olmayacak... 
....................  
....................  
.................... void sendCommand(mbyte Command, mbyte Param1, mbyte Param2) { 
*
0624:  MOVLW  05
0626:  MOVLB  2
0628:  ADDWF  xF8,W
062A:  MOVLB  3
062C:  MOVWF  x0A
062E:  MOVLW  01
0630:  MOVWF  x0B
0632:  BTFSC  FD8.0
0634:  INCF   x0B,F
0636:  MOVLW  01
0638:  ADDWF  x0A,F
063A:  MOVLW  00
063C:  ADDWFC x0B,F
063E:  MOVLB  2
0640:  MOVF   xF9,W
0642:  MOVLB  3
0644:  ADDWF  x0A,F
0646:  MOVLW  00
0648:  ADDWFC x0B,F
064A:  MOVLB  2
064C:  MOVF   xFA,W
064E:  MOVLB  3
0650:  ADDWF  x0A,W
0652:  MOVWF  01
0654:  MOVLW  00
0656:  ADDWFC x0B,W
0658:  MOVWF  03
065A:  MOVF   01,W
065C:  XORLW  FF
065E:  ADDLW  01
0660:  MOVWF  x05
0662:  MOVLW  00
0664:  SUBFWB 03,W
0666:  MOVWF  x06
0668:  MOVFF  305,307
066C:  MOVFF  306,308
....................      
....................   //  disable_interrupts(GLOBAL); 
.................... // Calculate the checksum 
....................   mbyte commandBuffer[10]; 
....................   unsigned int16 checkSum = -(versionByte + dataLength + Command + infoReq + Param1 + Param2); 
....................   mbyte low_cSum=make8(checkSum,0); 
....................   mbyte high_cSum=make8(checkSum,1); 
....................   // Construct the command line 
....................   //mbyte commandBuffer[10] ={startByte, versionByte, dataLength, Command, infoReq, Param1, Param2,high_cSum,low_cSum, endByte}; 
....................    
....................   commandBuffer[0]=startByte; 
0670:  MOVLW  7E
0672:  MOVLB  2
0674:  MOVWF  xFB
....................   commandBuffer[1]=versionByte; 
0676:  SETF   xFC
....................   commandBuffer[2]=dataLength; 
0678:  MOVLW  06
067A:  MOVWF  xFD
....................   commandBuffer[3]=Command; 
067C:  MOVFF  2F8,2FE
....................   commandBuffer[4]=infoReq; 
0680:  MOVLW  01
0682:  MOVWF  xFF
....................   commandBuffer[5]=Param1; 
0684:  MOVFF  2F9,300
....................   commandBuffer[6]=Param2; 
0688:  MOVFF  2FA,301
....................   commandBuffer[7]=high_cSum; 
068C:  MOVFF  308,302
....................   commandBuffer[8]=low_cSum; 
0690:  MOVFF  307,303
....................   commandBuffer[9]=endByte; 
0694:  MOVLW  EF
0696:  MOVLB  3
0698:  MOVWF  x04
.................... // 
....................   for (int cnt = 0; cnt < 10; cnt++) { 
069A:  CLRF   x09
069C:  MOVF   x09,W
069E:  SUBLW  09
06A0:  BNC   06C0
....................     //mp3.write(commandBuffer[cnt]); 
....................       //putc(commandBuffer[cnt]); 
....................       fputc(commandBuffer[cnt],dfPlayerSerial); 
06A2:  CLRF   03
06A4:  MOVF   x09,W
06A6:  ADDLW  FB
06A8:  MOVWF  FE9
06AA:  MOVLW  02
06AC:  ADDWFC 03,W
06AE:  MOVWF  FEA
06B0:  MOVFF  FEF,30A
06B4:  MOVF   x0A,W
06B6:  MOVLB  0
06B8:  BRA    061A
06BA:  MOVLB  3
06BC:  INCF   x09,F
06BE:  BRA    069C
....................   } 
....................  
....................   // Delay needed between successive commands 
....................   delay_ms(30); 
06C0:  MOVLW  1E
06C2:  MOVWF  x0A
06C4:  MOVLB  0
06C6:  RCALL  04F8
06C8:  RETURN 0
....................  // enable_interrupts(GLOBAL); 
....................    
.................... } 
....................  
.................... // Set volume (otherwise full blast!) command code 0x06 followed by high byte / low byte 
.................... // sendCommand(0x06, 0, 30); 
.................... void mp3_set_volume (char vol){ 
....................     sendCommand(0x06, 0, vol); 
06CA:  MOVLW  06
06CC:  MOVLB  2
06CE:  MOVWF  xF8
06D0:  CLRF   xF9
06D2:  MOVFF  2F3,2FA
06D6:  MOVLB  0
06D8:  RCALL  0624
06DA:  RETURN 0
.................... } 
.................... // Equaliser setting 
.................... //  sendCommand(0x07, 0, 5); 
.................... void mp3_set_equalizer(char eq){ 
....................     sendCommand(0x07, 0, eq); 
.................... } 
.................... // Specify track to play (0 = first track) 
.................... //  sendCommand(0x03, 0, 0); 
.................... void mp3_play_physical(unsigned int16 fileNum){ 
....................   sendCommand(0x03, make8(fileNum,1), make8(fileNum,0));   
....................   //sendCommand(0x03, 0, 1); 
.................... } 
.................... // 
.................... void mp3_single_loop (unsigned int16 fileNum) { 
.................... 	sendCommand(0x08, make8(fileNum,1), make8(fileNum,0)); 
.................... }   
.................... void mp3_enableLoopAll(){ 
....................     sendCommand(0x11, 0x00,0x01 );         
.................... } 
.................... void mp3_disbleLoopAll(){ 
....................     sendCommand(0x11, 0x00,0x00 );         
.................... } 
.................... // Play 
....................   //sendCommand(0x0D, 0, 0); 
.................... void mp3_play (){ 
....................    sendCommand(0x0D, 0, 0);  
.................... } 
....................  
.................... void mp3_play (unsigned int16 fileNum)  
.................... { 
.................... 	//mp3_send_cmd (0x12, num); 
....................     sendCommand(0x12, make8(fileNum,1), make8(fileNum,0));   
*
0916:  MOVFF  2F5,2F6
091A:  MOVFF  2F4,2F7
091E:  MOVLW  12
0920:  MOVLB  2
0922:  MOVWF  xF8
0924:  MOVFF  2F5,2F9
0928:  MOVFF  2F4,2FA
092C:  MOVLB  0
092E:  RCALL  0624
0930:  RETURN 0
.................... } 
.................... void mp3_stop(){ 
....................    sendCommand(0x16, 0, 0);      
*
0906:  MOVLW  16
0908:  MOVLB  2
090A:  MOVWF  xF8
090C:  CLRF   xF9
090E:  CLRF   xFA
0910:  MOVLB  0
0912:  RCALL  0624
0914:  RETURN 0
.................... } 
.................... void mp3_reset(){ 
....................     sendCommand(0x0C, 0, 0);  
.................... } 
....................  
.................... void mp3_get_error () { 
....................     sendCommand(0x40, 0, 0);  
....................      
.................... } 
.................... void mp3_getData(*dizi){        //kilitlendi ..... 
....................     char i=0; 
....................      
....................     while(i<10){ 
....................         if(kbhit(dfPlayerSerial)){ 
....................             dizi[i]=fgetc(dfPlayerSerial); 
....................             i++; 
....................         }   
....................     } 
.................... } 
....................  
.................... void mp3_DataSeriGonder(*dizi,char len){  
.................... //   int k=0;   
.................... //   fprintf(usbSerial,"\r\n"); 
.................... //   for( k=0;k<len;k++){ 
.................... //           fprintf(usbSerial,"%x ",dizi[k]);     
.................... //   }  
.................... //   fprintf(usbSerial,"\r\n"); 
.................... } 
....................  
.................... int mp3_sarki=19; 
.................... int mp3_sarki_list[MP3_SD_RASTGELE_MAX_SAYI]; /// 0-8 
.................... int mp3_index=0; 
....................  
.................... BOOLEAN mp3_list_kontrol(){ 
*
0932:  MOVLB  2
0934:  CLRF   xF3
....................     int x=0;  
....................     for(x=0;x<MP3_SD_RASTGELE_MAX_SAYI;x++){ 
0936:  CLRF   xF3
0938:  MOVF   xF3,W
093A:  SUBLW  08
093C:  BNC   095C
....................         if( mp3_sarki==mp3_sarki_list[x]){ 
093E:  CLRF   03
0940:  MOVF   xF3,W
0942:  ADDLW  26
0944:  MOVWF  FE9
0946:  MOVLW  00
0948:  ADDWFC 03,W
094A:  MOVWF  FEA
094C:  MOVF   FEF,W
094E:  SUBWF  25,W
0950:  BNZ   0958
....................             return FALSE; 
0952:  MOVLW  00
0954:  MOVWF  01
0956:  BRA    0960
....................         }  
0958:  INCF   xF3,F
095A:  BRA    0938
....................     } 
....................     return TRUE; 
095C:  MOVLW  01
095E:  MOVWF  01
0960:  MOVLB  0
0962:  GOTO   0ACC (RETURN)
....................  } 
....................  
....................  
....................   
.................... void mp3_rastgele(){ 
*
0A86:  MOVLB  2
0A88:  CLRF   xF2
0A8A:  CLRF   xF1
0A8C:  CLRF   xF0
0A8E:  CLRF   xEF
....................      
.................... //    int16 say=0; 
....................     unsigned int32 time_df_busy=0; 
....................     mp3_stop(); 
0A90:  MOVLB  0
0A92:  RCALL  0906
....................     delay_ms(100); 
0A94:  MOVLW  64
0A96:  MOVLB  3
0A98:  MOVWF  x0A
0A9A:  MOVLB  0
0A9C:  RCALL  04F8
....................     dfPlayerMinSes(); 
0A9E:  MOVLW  01
0AA0:  MOVLB  2
0AA2:  MOVWF  xF3
0AA4:  MOVLB  0
0AA6:  RCALL  06CA
0AA8:  MOVLW  64
0AAA:  MOVLB  3
0AAC:  MOVWF  x0A
0AAE:  MOVLB  0
0AB0:  RCALL  04F8
....................      
....................      if(mp3_index>MP3_SD_RASTGELE_MAX_SAYI-1)//9-1=8  9. eleman yok 
0AB2:  MOVF   2F,W
0AB4:  SUBLW  08
0AB6:  BC    0ACA
....................      { 
....................         mp3_index=0;  //þarký listesi dizisindeki elemanlarý index ler. 
0AB8:  CLRF   2F
....................         memset(mp3_sarki_list,0,sizeof(mp3_sarki_list)); 
0ABA:  CLRF   FEA
0ABC:  MOVLW  26
0ABE:  MOVWF  FE9
0AC0:  CLRF   00
0AC2:  CLRF   02
0AC4:  MOVLW  09
0AC6:  MOVWF  01
0AC8:  RCALL  06DC
....................     } 
....................      
....................      
....................     while(!mp3_list_kontrol()){ 
0ACA:  BRA    0932
0ACC:  MOVF   01,F
0ACE:  BNZ   0AF6
....................          mp3_sarki=MP3_SD_RASTGELE_BASLANGIC+rand()%MP3_SD_RASTGELE_MAX_SAYI; 
0AD0:  BRA    0A14
0AD2:  MOVFF  02,2F4
0AD6:  MOVFF  01,2F3
0ADA:  MOVFF  02,2F7
0ADE:  MOVFF  01,2F6
0AE2:  MOVLB  2
0AE4:  CLRF   xF9
0AE6:  MOVLW  09
0AE8:  MOVWF  xF8
0AEA:  MOVLB  0
0AEC:  RCALL  09CE
0AEE:  MOVF   00,W
0AF0:  ADDLW  1E
0AF2:  MOVWF  25
0AF4:  BRA    0ACA
....................     } 
....................     mp3_sarki_list[mp3_index]=mp3_sarki; 
0AF6:  CLRF   03
0AF8:  MOVF   2F,W
0AFA:  ADDLW  26
0AFC:  MOVWF  FE9
0AFE:  MOVLW  00
0B00:  ADDWFC 03,W
0B02:  MOVWF  FEA
0B04:  MOVFF  25,FEF
....................     mp3_index++; 
0B08:  INCF   2F,F
....................  
....................     if(mp3_sarki>(MP3_SD_RASTGELE_BASLANGIC+MP3_SD_RASTGELE_MAX_SAYI)) 
0B0A:  MOVF   25,W
0B0C:  SUBLW  27
0B0E:  BC    0B14
....................         mp3_sarki=MP3_SD_RASTGELE_BASLANGIC; 
0B10:  MOVLW  1E
0B12:  MOVWF  25
....................     if(mp3_sarki<MP3_SD_RASTGELE_BASLANGIC)mp3_sarki=MP3_SD_RASTGELE_BASLANGIC+(int8)(MP3_SD_RASTGELE_MAX_SAYI/2); 
0B14:  MOVF   25,W
0B16:  SUBLW  1D
0B18:  BNC   0B1E
0B1A:  MOVLW  22
0B1C:  MOVWF  25
....................      
....................     //mp3_play(mp3_getlowve_araba); 
....................     // printf(lcd_putc,"\f     KOSTUR"); 
....................     // printf(lcd_putc,"\n   ::  %u  ::",mp3_sarki); 
....................               
....................    //  dfPlayerNormSes(); 
....................    //  dfPplayerMaxSes(); 
.................... //    fprintf(usbSerial,"Mp3:%u\r\n",mp3_sarki); 
....................     mp3_set_volume(df_player_ses);delay_ms(100); 
0B1E:  MOVFF  24,2F3
0B22:  RCALL  06CA
0B24:  MOVLW  64
0B26:  MOVLB  3
0B28:  MOVWF  x0A
0B2A:  MOVLB  0
0B2C:  RCALL  04F8
....................     mp3_play(mp3_sarki); 
0B2E:  MOVLB  2
0B30:  CLRF   xF5
0B32:  MOVFF  25,2F4
0B36:  MOVLB  0
0B38:  RCALL  0916
....................     delay_ms(100); 
0B3A:  MOVLW  64
0B3C:  MOVLB  3
0B3E:  MOVWF  x0A
0B40:  MOVLB  0
0B42:  RCALL  04F8
....................      
....................     time_df_busy=millis(); 
0B44:  MOVFF  1D,2F2
0B48:  MOVFF  1C,2F1
0B4C:  MOVFF  1B,2F0
0B50:  MOVFF  1A,2EF
....................      
....................     while(TRUE){ 
....................         if(!input(DF_BUSY_PIN)) break; 
0B54:  BSF    F94.5
0B56:  BTFSS  F82.5
0B58:  BRA    0BC0
....................         mp3_stop(); 
0B5A:  RCALL  0906
....................         delay_ms(100); 
0B5C:  MOVLW  64
0B5E:  MOVLB  3
0B60:  MOVWF  x0A
0B62:  MOVLB  0
0B64:  RCALL  04F8
....................         mp3_play(mp3_sarki); 
0B66:  MOVLB  2
0B68:  CLRF   xF5
0B6A:  MOVFF  25,2F4
0B6E:  MOVLB  0
0B70:  RCALL  0916
....................         delay_ms(400); 
0B72:  MOVLW  02
0B74:  MOVLB  2
0B76:  MOVWF  xF3
0B78:  MOVLW  C8
0B7A:  MOVLB  3
0B7C:  MOVWF  x0A
0B7E:  MOVLB  0
0B80:  RCALL  04F8
0B82:  MOVLB  2
0B84:  DECFSZ xF3,F
0B86:  BRA    0B78
....................         if(millis()-time_df_busy>2000) break;      
0B88:  MOVF   xEF,W
0B8A:  SUBWF  1A,W
0B8C:  MOVWF  xF3
0B8E:  MOVF   xF0,W
0B90:  SUBWFB 1B,W
0B92:  MOVWF  xF4
0B94:  MOVF   xF1,W
0B96:  SUBWFB 1C,W
0B98:  MOVWF  xF5
0B9A:  MOVF   xF2,W
0B9C:  SUBWFB 1D,W
0B9E:  MOVWF  xF6
0BA0:  MOVF   xF6,F
0BA2:  BNZ   0BB8
0BA4:  MOVF   xF5,F
0BA6:  BNZ   0BB8
0BA8:  MOVF   xF4,W
0BAA:  SUBLW  06
0BAC:  BC    0BBC
0BAE:  XORLW  FF
0BB0:  BNZ   0BB8
0BB2:  MOVF   xF3,W
0BB4:  SUBLW  D0
0BB6:  BC    0BBC
0BB8:  MOVLB  0
0BBA:  BRA    0BC0
0BBC:  MOVLB  0
0BBE:  BRA    0B54
....................          
....................     } 
0BC0:  RETURN 0
....................      
....................       
....................  } 
....................  
.................... void mp3_baslangic(unsigned int ses){ 
....................      
....................     delay_ms(500); /// Mp3  player donaným kurulumndan belli bir süre sonra çalýþtýrmalý.... 
....................     mp3_set_equalizer(5); 
....................     delay_ms(100); 
....................     //mp3_set_volume(15);//48 e kadar olabiliyor denendi... 
....................     //dfPlayer_ses= map(read_adc(),0,1023,0,dfPlayerMaxSes); 
....................     mp3_stop(); 
....................     delay_ms(100); 
....................     mp3_set_volume (ses);       //20 
....................     delay_ms(100); 
....................     //mp3_enableLoopAll(); 
....................     delay_ms(100); 
....................    // mp3_single_loop(18); 
.................... //    mp3_play(mp3_dejavu); 
....................     //mp3_rastgele(); 
....................     delay_ms(100); 
....................      
.................... } 
....................  
.................... #include "dfPlayer.h" 
.................... /*  
....................  * File:   dfPlayer.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 28 Þubat 2018 Çarþamba, 16:11 
....................  */ 
....................  
.................... /* 
....................  *	name:				DFPlayer_Mini_Mp3 
....................  *	version:			1.0 
....................  *	Author:				lisper <lisper.li@dfrobot.com> 
....................  *	Date:				2014-05-22 
....................  *	official website:		http://www.dfrobot.com 
....................  *	Products page:			http://www.dfrobot.com/index.php?route=product/product&product_id=1121#.U5Z_RYbUN8E 
....................  *	Description:			mp3 library for DFPlayer mini board 
....................  *					        note: mp3 file must put into mp3 folder in your tf card 
....................  */ 
....................  
.................... #ifndef DFPLAYER_H 
.................... #define	DFPLAYER_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................     typedef unsigned char mbyte; 
....................      
....................     #define startByte 0x7E 
....................     #define endByte 0xEF 
....................     #define versionByte 0xFF 
....................     #define dataLength 0x06 
....................     #define infoReq 0x01        //0x01 
....................     #define isDebug false 
....................     #define dfPlayerMaxSes 25 // dec30:0x1E 
....................     #define dfPlayerNSes 20 //20 
....................  
....................     #define DF_BUSY_PIN  PIN_C5 //PIN_B3 
....................  
....................     #define  MP3_SD_RASTGELE_BASLANGIC 30 
....................     #define  MP3_SD_RASTGELE_MAX_SAYI 9 
....................  
....................     #define dfPplayerMaxSes() mp3_set_volume (dfPlayerMaxSes);delay_ms(100)//48 
....................     #define dfPlayerNormSes() mp3_set_volume(dfPlayerNSes);delay_ms(100)  // 
....................     #define dfPlayerMinSes() mp3_set_volume(1);delay_ms(100) 
....................  
....................     unsigned int8 df_player_ses=15; 
....................  
....................     void sendCommand(mbyte Command, mbyte Param1, mbyte Param2); 
....................     void mp3_set_volume (char vol); 
....................     void mp3_set_equalizer(char eq); 
....................     void mp3_play_physical(unsigned int16 fileNum); 
....................     void mp3_get_error (); 
....................     void mp3_single_loop (unsigned int16 fileNum) ; 
....................     void mp3_enableLoopAll(); 
....................     void mp3_disbleLoopAll(); 
....................     void mp3_getData(*dizi); 
....................     void mp3_DataSeriGonder(*dizi,char len); 
....................     void mp3_stop(); 
....................     void mp3_reset(); 
....................     void mp3_baslangic(); 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* DFPLAYER_H */ 
....................  
....................  
.................... #include "pid_hesapla.c" 
.................... #include "tanimlamalar.h" 
.................... /*  
....................  * File:   tanimlamalar.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 31 Temmuz 2019 Çarþamba, 09:02 
....................  */ 
....................  
.................... #ifndef TANIMLAMALAR_H 
.................... #define	TANIMLAMALAR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................  
....................     #define buzzerPIN PIN_C0 
....................  
....................     #define FAN_PIN PIN_C4 
....................     #define ACIL_DUR_SENS_PIN PIN_B3    //PIN_A7  LED1 
....................     #define LED2_PIN PIN_A6 
....................     #define IR_LED_ANOT_PIN PIN_C3 
....................  
....................     #define fan_on() output_high(FAN_PIN); 
....................     #define fan_off() output_low(FAN_PIN);  
....................  
....................     #define led1_on() output_high(LED1_PIN); 
....................     #define led1_off() output_low(LED1_PIN); 
....................  
....................     #define led2_on() output_high(LED2_PIN); 
....................     #define led2_off() output_low(LED2_PIN); 
....................      
....................     #define ir_led_on() output_low(IR_LED_ANOT_PIN); 
....................     #define ir_led_off() output_high(IR_LED_ANOT_PIN); 
....................  
....................     #define buzzer_off()  output_low(buzzerPIN) 
....................     #define bip_yazildi() bipp(10,20,buzzerPIN) //sure,sayi,pin 
....................     #define bip_rf_var() bipp(50,2,buzzerPIN)  //sure,sayi,pin    
....................     #define bip_kurulum() bipp(25,2,buzzerPIN)  //sure,sayi,pin 
....................     #define bip_hata() bipp(3,100,buzzerPIN) 
....................     #define bip_tus() bipp(5,2,buzzerPIN)  //sure,sayi,pin 
....................  
....................     #define lfr_led_goster(sens)  hc595_spi_yaz(sens,8); 
....................  
....................     #define pwmMaxDeger 700 //200     //5Khz sinyal 
....................      
....................     #define ORT_HIZ_MIN 100 // soft kalkýþ için deðerler... 
....................     #define ORT_HIZ_MAX 600    //350  
....................  
....................     #define solMotor_hiz(v) set_pwm2_duty(v); 
....................     #define sagMotor_hiz(v) set_pwm1_duty(v); 
....................     #define solMotorDur()  set_pwm2_duty(0);  
....................     #define sagMotorDur()  set_pwm1_duty(0);  
....................  
....................     #define trenDur() solMotorDur();sagMotorDur() 
....................     #define ileri_git(v_sol,v_sag) solMotor_hiz(v_sol);sagMotor_hiz(v_sag) 
....................     #define sola_don(hiz, sure) solMotor_hiz((int16)(hiz/10));sagMotor_hiz(hiz);delay_ms(sure) 
....................     #define saga_don(hiz,sure) solMotor_hiz(hiz);sagMotor_hiz((int16)(hiz/10));delay_ms(sure) 
....................  
....................     #define AN_CHANNEL_AKU 8 
....................     #define ORNEK_SAYISI 8 
....................     #define SENS_SAYISI 8 
....................  
....................     #define HAM_DEGER 0 
....................     #define ORT_DEGER 1 
....................     #define MAX_DEGER 2 
....................     #define MIN_DEGER 3 
....................  
....................     #define MAX_HATA_DEGERI 1750 
....................  
....................     #define GERILIM_VAR 1 
....................     #define GERILIM_YOK 0 
....................  
....................     #define EMITTER_ON 1 
....................     #define EMITTER_OFF 0 
....................      
....................     #define BEYAZ 0x00 
....................     #define SIYAH 0x01 
....................  
....................     #define ASIRI_ISIK  'A' 
....................     #define NORMAL_ISIK 'N' 
....................     #define DUSUK_ISIK 'D' 
....................     #define KARANLIK_ISIK 'K' 
....................      
....................     #define ORTALAMA_DEGER 'O' 
....................     #define DIGITAL_DEGER   'B' 
....................  
....................     #define HATA_REF    1750 
....................  
....................     #define ee_adr_jtn 0x10 
....................     #define ee_adr_ortHiz_H 0x00  //high   //16 bitlik sayý 
....................     #define ee_adr_ortHiz_L 0x01  //low 
....................     #define ee_adr_df_ses   0x02 
....................  
....................     #define mp3_stop_100mS() mp3_stop();delay_ms(100) 
....................  
....................     //433MHz alýcý baðlantý pinleri 
....................     #define tus1 PIN_D0 
....................     #define tus2 PIN_D1 
....................     #define tus3 PIN_D2 
....................     #define tus4 PIN_D3 
....................     #define tus5 PIN_D4 
....................     #define tus6 PIN_D5 
....................     #define tus_vt  PIN_B0 
....................  
....................     #define ses_miniko          1 
....................     #define ses_demo            2 
....................     #define ses_getReady        3 
....................     #define ses_remix           4 
....................     #define ses_trenDuduk       5 
....................     #define ses_sureAyar        6 
....................     #define ses_kumandaKontrol  7 
....................     #define ses_cizgiTakip      8 
....................     #define TREN_DUDUK          5 
....................     #define OYUN_SON_JENERIK    2 
....................  
....................     #define SES_AKU_SARJ_50     26 
....................     #define SES_AKU_SARJ_25     27 
....................     #define SES_AKU_SARJ_DUSUK  28 
....................     #define SES_AKU_SARJ_TAK    29 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TANIMLAMALAR_H */ 
....................  
....................  
....................  
.................... unsigned int16 tic,o_tic;  // Türev hesabý için hata deðiþim süresini belirler, sayar.  
....................                            
.................... //signed int16 sonHata;  //  
.................... //float kp=0.8f; 
.................... signed int16 sonTurev; 
.................... //signed int16 hataDeg; 
.................... float kd; 
....................  
.................... signed int16 pdKontrol(signed int16 err, signed int16 deg_err,signed int16 son_err, float kp,float kd) 
*
2582:  MOVFF  2F4,306
2586:  MOVFF  2F3,305
258A:  RCALL  23AA
258C:  MOVFF  2FC,30C
2590:  MOVFF  2FB,30B
2594:  MOVFF  2FA,30A
2598:  MOVFF  2F9,309
259C:  MOVFF  03,310
25A0:  MOVFF  02,30F
25A4:  MOVFF  01,30E
25A8:  MOVFF  00,30D
25AC:  RCALL  23FA
25AE:  MOVFF  03,308
25B2:  MOVFF  02,307
25B6:  MOVFF  01,306
25BA:  MOVFF  00,305
25BE:  RCALL  24F0
25C0:  MOVFF  02,302
25C4:  MOVFF  01,301
25C8:  MOVLB  3
25CA:  CLRF   x04
25CC:  CLRF   x03
.................... { 
....................     
....................     //kd=kp/8; 
....................     //hata=orta-pos;//orta referans degeridir yani set edilmesi gereken deger. 
....................     signed int16 oransal=(kp*err); 
....................     signed int16 turev=0; 
....................      
....................     if (err == son_err)  //hata ayný ise deðiþim süresini say. 
25CE:  MOVLB  2
25D0:  MOVF   xF7,W
25D2:  SUBWF  xF3,W
25D4:  BNZ   2646
25D6:  MOVF   xF8,W
25D8:  SUBWF  xF4,W
25DA:  BNZ   2646
....................     { 
....................       tic = tic + 1; 
25DC:  MOVLW  01
25DE:  ADDWF  30,F
25E0:  MOVLW  00
25E2:  ADDWFC 31,F
....................       if(tic > 60000){tic = 60000;} 
25E4:  MOVF   31,W
25E6:  SUBLW  E9
25E8:  BC    25FC
25EA:  XORLW  FF
25EC:  BNZ   25F4
25EE:  MOVF   30,W
25F0:  SUBLW  60
25F2:  BC    25FC
25F4:  MOVLW  EA
25F6:  MOVWF  31
25F8:  MOVLW  60
25FA:  MOVWF  30
....................       //if(tic > o_tic){turev = sonTurev/(tic);} 
....................       //if(tic > o_tic){turev = sonTurev/(tic*0.001f);} 
....................       if(tic > o_tic)  // son hata deðiþim süresi geçildi ise yeni hesaplamayý son türeve göre yap. 
25FC:  MOVF   33,W
25FE:  SUBWF  31,W
2600:  BNC   2644
2602:  BNZ   260A
2604:  MOVF   30,W
2606:  SUBWF  32,W
2608:  BC    2644
....................       { 
....................          // turev = (sonTurev*100)/tic;  //2.5mS dt *400  1mS dt*1000 10mS dt*100 
....................           turev = (sonTurev*(1000/40))/tic; //40mS 
260A:  MOVFF  35,306
260E:  MOVFF  34,305
2612:  MOVLB  3
2614:  CLRF   x08
2616:  MOVLW  19
2618:  MOVWF  x07
261A:  MOVLB  0
261C:  BRA    252C
261E:  MOVFF  02,306
2622:  MOVFF  01,305
2626:  MOVFF  02,308
262A:  MOVFF  01,307
262E:  MOVFF  31,30A
2632:  MOVFF  30,309
2636:  CALL   0BC2
263A:  MOVFF  02,304
263E:  MOVFF  01,303
2642:  MOVLB  2
....................       } 
....................       //if(tic > tic_old){errord = (errord_old*tic_old)/tic;} 
....................     } 
2644:  BRA    2718
....................     else  // yeni hata oluþtu ise, yeni türev hesapla. 
....................     { 
....................       tic++; 
2646:  INCF   30,F
2648:  BTFSC  FD8.2
264A:  INCF   31,F
....................       //printf("%lu\n",tic); 
....................       //printf("%d\n",deg_e); 
....................       //turev=kd*(hataDeg)/(tic); 
....................       //turev=kd*(deg_e)/(tic*0.001f); 
....................       //turev=(kd*deg_err*100)/(tic);//2.5mS dt 
....................       //turev=kd*(hataDeg)/1; 
....................       turev=(kd*deg_err*(1000/40))/(tic); //40mS 
264C:  MOVFF  2F6,306
2650:  MOVFF  2F5,305
2654:  MOVLB  0
2656:  RCALL  23AA
2658:  MOVFF  300,30C
265C:  MOVFF  2FF,30B
2660:  MOVFF  2FE,30A
2664:  MOVFF  2FD,309
2668:  MOVFF  03,310
266C:  MOVFF  02,30F
2670:  MOVFF  01,30E
2674:  MOVFF  00,30D
2678:  RCALL  23FA
267A:  MOVFF  03,308
267E:  MOVFF  02,307
2682:  MOVFF  01,306
2686:  MOVFF  00,305
268A:  MOVFF  03,30C
268E:  MOVFF  02,30B
2692:  MOVFF  01,30A
2696:  MOVFF  00,309
269A:  MOVLB  3
269C:  CLRF   x10
269E:  CLRF   x0F
26A0:  MOVLW  48
26A2:  MOVWF  x0E
26A4:  MOVLW  83
26A6:  MOVWF  x0D
26A8:  MOVLB  0
26AA:  RCALL  23FA
26AC:  MOVFF  03,308
26B0:  MOVFF  02,307
26B4:  MOVFF  01,306
26B8:  MOVFF  00,305
26BC:  MOVFF  31,30A
26C0:  MOVFF  30,309
26C4:  RCALL  2216
26C6:  MOVFF  308,30C
26CA:  MOVFF  307,30B
26CE:  MOVFF  306,30A
26D2:  MOVFF  305,309
26D6:  MOVFF  03,310
26DA:  MOVFF  02,30F
26DE:  MOVFF  01,30E
26E2:  MOVFF  00,30D
26E6:  RCALL  224C
26E8:  MOVFF  03,308
26EC:  MOVFF  02,307
26F0:  MOVFF  01,306
26F4:  MOVFF  00,305
26F8:  RCALL  24F0
26FA:  MOVFF  02,304
26FE:  MOVFF  01,303
....................       sonTurev= turev; 
2702:  MOVFF  304,35
2706:  MOVFF  303,34
....................       o_tic=tic; 
270A:  MOVFF  31,33
270E:  MOVFF  30,32
....................       tic=0; 
2712:  CLRF   31
2714:  CLRF   30
2716:  MOVLB  2
....................       //printf("%d\n",turev+oransal); 
....................     }   
....................      
....................     //turev=kd*(hata-sonHata); 
....................     //sonHata=hata;; 
....................     //sonTurev=turev; 
....................      
....................     return (signed int16)(oransal+turev); 
2718:  MOVLB  3
271A:  MOVF   x03,W
271C:  ADDWF  x01,W
271E:  MOVWF  01
2720:  MOVF   x04,W
2722:  ADDWFC x02,W
2724:  MOVWF  03
2726:  MOVWF  02
2728:  MOVLB  0
272A:  GOTO   38DE (RETURN)
.................... } 
....................  
.................... //int1 hepsiSiyahBeyaz(unsigned int16 *sDig){ 
.................... //    int i=0; 
.................... //    int sb=0,digSB=0; 
.................... //     
.................... //    for (i = 0; i < 5; i++) 
.................... //    { 
.................... //        if(sDig[i]==1){ 
.................... //            digSB|=(1<<i);   //i. inci biti 1 yapar 
.................... //        }else if(senDig[i]==1){ 
.................... //            digSB|=~(1<<i);  //i. inci biti sýfýr yapar 
.................... //        } 
.................... //    } 
.................... //    //printf("%u\n",digSB);  
.................... //    if(digSB==0b11111111){ 
.................... //       //sb=hepsiSiyah;  
.................... //    }else if(digSB==0b00000000){ 
.................... //        //sb=hepsiBeyaz; 
.................... //    }else { 
.................... //         //sb=enAzBiriSB; 
.................... //         
.................... //         //if((digSB==0b00000100) || (digSB==0b00001110)) sb=ortaNokta; 
.................... ////        if((digSB==0b00111111)||(digSB==0b00011111)||(digSB==0b00011111)){ 
.................... ////            sb=sagDoksan; 
.................... ////            //printf("sagD\n");     
.................... ////        } 
.................... ////         if((digSB==0b11111100)||(digSB==0b11111000)||(digSB==0b11111000)){ 
.................... ////            sb=solDoksan; 
.................... ////            //printf("solD\n");  
.................... ////        } 
.................... //    } 
.................... //                            //en az biri siyah veya beyaz 
.................... //    return sb; 
.................... //} 
.................... // 
.................... //void solDoksanDon(){ 
.................... //  
.................... //} 
.................... //void sagDoksanDon(){ 
.................... //  
.................... //} 
....................  
....................  
.................... unsigned int32 time_led = 0; //long long int32 
.................... unsigned int32 time_aku_sarj_seslendir=0;      //long long, int32 
.................... //unsigned int32 time_sens_deger_goster = 0; 
....................  
.................... unsigned int8 lfr_led = 0;                  // sensorlerin çizgi pozisyonlarýný tutar digital olarak. 
.................... unsigned int16 ir_sens_pos_digital = 0;     // ir_sens_pos_ort=0; 
....................  
.................... signed int16 solMhiz=0;     // *** 17.01.2020 : signed deðer olmalý heasaplama yanlýþ çýkýyor 
.................... signed int16 sagMhiz=0;     // PD den gelen deðer uygun þekilde alýnmadýðýndan kontrol uyuugn deðer alamýyor 
....................                             // týrtýl sapýtýyor çizgi takip yapmýyor 
....................  
.................... unsigned int16 ortHiz=150, ortHiz_max=200;      // soft kalkýþ ve kontrol için deðiþkenler. 
.................... BOOLEAN soft_kalkis=FALSE; 
....................  
.................... int aku_ornek_say=0; 
.................... int aku_sarj_seslendir_say=0; 
.................... BOOLEAN aku_yuzde_50=FALSE; 
.................... BOOLEAN aku_yuzde_25=FALSE; 
.................... BOOLEAN aku_dusuk=FALSE; 
.................... BOOLEAN aku_sarja_tak=FALSE; 
....................  
.................... unsigned int32 time_aku_ornek=0; 
.................... int ee_jeton_suresi_deger=25;           //2.5 dakika demek. 
.................... unsigned int32 oyunSuresiSay=0; 
....................  
.................... float v_aku = 0.0; 
.................... unsigned int16 aku_adc_toplam=0; 
....................  
.................... //unsigned int16 aku_hareketli_ortalama_dizi[ORNEK_SAYISI]; 
....................  
.................... int hareketli_ort_orn_say = 0; 
....................  
....................  
.................... unsigned int16 ir_sens_adc_ham_deger[SENS_SAYISI]; 
.................... unsigned int16 ir_sens_ort_deger[SENS_SAYISI];          //kalibre edlmiþ ortalama deðer, ortam ýþýðýnýn etkisinden arýndýrýþný deðer. 
.................... unsigned int16 ir_sens_ort_deger_e_on[SENS_SAYISI]; 
.................... unsigned int16 ir_sens_ort_deger_e_off[SENS_SAYISI]; 
....................  
.................... //unsigned int16 ir_sens_ort_max_deger[SENS_SAYISI]; 
.................... //unsigned int16 ir_sens_ort_min_deger[SENS_SAYISI]; 
.................... // 
.................... unsigned int16 ir_sens_esik_deger[SENS_SAYISI]; 
.................... unsigned int16 ir_sens_baslangic_esik_deger[SENS_SAYISI]; 
....................  
.................... char ir_sens_isik_durumu[SENS_SAYISI]={0,0,0,0,0,0,0,0}; 
.................... unsigned int16 ir_sens_asiri_isik_deger[SENS_SAYISI]={0,0,0,0,0,0,0,0}; 
.................... unsigned int8 son_isik_durumu[SENS_SAYISI]={0,0,0,0,0,0,0,0}; 
....................  
.................... unsigned int8 ir_sens_sayisal_deger[SENS_SAYISI] = {0, 0, 0, 0, 0, 0, 0, 0}; 
....................  
.................... BOOLEAN sens_yeni_deger = 0; 
.................... int sens_emiter_on_off = 0; 
....................  
.................... signed int16 hata = 0, son_hata = 0,hata_deg=0 ,kontrol=0;      // iþaretli sayý olmalarý önemli... 
.................... float kP=0.0;   //oransal katsayý 
....................  
.................... BOOLEAN sens_hepsi_beyaz = 0; 
.................... BOOLEAN sens_hepsi_siyah = 0; 
....................  
.................... int1 rfKontrol=TRUE; 
.................... int1 cizgiKontrol=FALSE; 
.................... int1 cizgiKontrolBaslat=FALSE; 
.................... int1 oyunBitti=1; 
....................  
.................... int time_saniye_say=0; 
.................... long time_saniye=0; 
.................... long time_ort_hiz=0; 
....................  
.................... unsigned int16 agirlikliPosGetir(char ortDigital); 
.................... void ir_sens_adc_oku(BOOLEAN e_on); 
.................... void millis_kurulum(); 
.................... //void sens_max_min_bul(BOOLEAN anlik, BOOLEAN baslangic); 
.................... void sens_led_goster(); 
.................... //void sens_deger_sayisal(); 
.................... //void kalibrasyon(); 
.................... void Timer0_int(); 
.................... //void sens_cizgi_durum_getir(); 
.................... //unsigned int16 hareketli_ortalama(int ornek_say, unsigned int16 an_deger, unsigned int16 *moving_dizi); 
.................... void bipp(unsigned int16 sure, int sayi, long pin); 
.................... void delay_m_us(unsigned int16 n); 
.................... //float v_aku_oku_ort(); 
.................... v_aku_oku(int orn_say); 
.................... void aku_sarj_seslendir(float aku_gerilim); 
.................... //void debug_ir_sens_dizi(unsigned int16 *ir_dizi); 
.................... //void debug_ir_sens(int deger_tip,BOOLEAN volt); 
.................... void test_donanim(); 
.................... //void dizi_set(unsigned int16 *dizi, unsigned int16 deger, int16 uzunluk); 
....................  
.................... #include "k_means_fonk.c" 
.................... // 
.................... #include "tanimlamalar.h" 
.................... /*  
....................  * File:   tanimlamalar.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 31 Temmuz 2019 Çarþamba, 09:02 
....................  */ 
....................  
.................... #ifndef TANIMLAMALAR_H 
.................... #define	TANIMLAMALAR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................  
....................     #define buzzerPIN PIN_C0 
....................  
....................     #define FAN_PIN PIN_C4 
....................     #define ACIL_DUR_SENS_PIN PIN_B3    //PIN_A7  LED1 
....................     #define LED2_PIN PIN_A6 
....................     #define IR_LED_ANOT_PIN PIN_C3 
....................  
....................     #define fan_on() output_high(FAN_PIN); 
....................     #define fan_off() output_low(FAN_PIN);  
....................  
....................     #define led1_on() output_high(LED1_PIN); 
....................     #define led1_off() output_low(LED1_PIN); 
....................  
....................     #define led2_on() output_high(LED2_PIN); 
....................     #define led2_off() output_low(LED2_PIN); 
....................      
....................     #define ir_led_on() output_low(IR_LED_ANOT_PIN); 
....................     #define ir_led_off() output_high(IR_LED_ANOT_PIN); 
....................  
....................     #define buzzer_off()  output_low(buzzerPIN) 
....................     #define bip_yazildi() bipp(10,20,buzzerPIN) //sure,sayi,pin 
....................     #define bip_rf_var() bipp(50,2,buzzerPIN)  //sure,sayi,pin    
....................     #define bip_kurulum() bipp(25,2,buzzerPIN)  //sure,sayi,pin 
....................     #define bip_hata() bipp(3,100,buzzerPIN) 
....................     #define bip_tus() bipp(5,2,buzzerPIN)  //sure,sayi,pin 
....................  
....................     #define lfr_led_goster(sens)  hc595_spi_yaz(sens,8); 
....................  
....................     #define pwmMaxDeger 700 //200     //5Khz sinyal 
....................      
....................     #define ORT_HIZ_MIN 100 // soft kalkýþ için deðerler... 
....................     #define ORT_HIZ_MAX 600    //350  
....................  
....................     #define solMotor_hiz(v) set_pwm2_duty(v); 
....................     #define sagMotor_hiz(v) set_pwm1_duty(v); 
....................     #define solMotorDur()  set_pwm2_duty(0);  
....................     #define sagMotorDur()  set_pwm1_duty(0);  
....................  
....................     #define trenDur() solMotorDur();sagMotorDur() 
....................     #define ileri_git(v_sol,v_sag) solMotor_hiz(v_sol);sagMotor_hiz(v_sag) 
....................     #define sola_don(hiz, sure) solMotor_hiz((int16)(hiz/10));sagMotor_hiz(hiz);delay_ms(sure) 
....................     #define saga_don(hiz,sure) solMotor_hiz(hiz);sagMotor_hiz((int16)(hiz/10));delay_ms(sure) 
....................  
....................     #define AN_CHANNEL_AKU 8 
....................     #define ORNEK_SAYISI 8 
....................     #define SENS_SAYISI 8 
....................  
....................     #define HAM_DEGER 0 
....................     #define ORT_DEGER 1 
....................     #define MAX_DEGER 2 
....................     #define MIN_DEGER 3 
....................  
....................     #define MAX_HATA_DEGERI 1750 
....................  
....................     #define GERILIM_VAR 1 
....................     #define GERILIM_YOK 0 
....................  
....................     #define EMITTER_ON 1 
....................     #define EMITTER_OFF 0 
....................      
....................     #define BEYAZ 0x00 
....................     #define SIYAH 0x01 
....................  
....................     #define ASIRI_ISIK  'A' 
....................     #define NORMAL_ISIK 'N' 
....................     #define DUSUK_ISIK 'D' 
....................     #define KARANLIK_ISIK 'K' 
....................      
....................     #define ORTALAMA_DEGER 'O' 
....................     #define DIGITAL_DEGER   'B' 
....................  
....................     #define HATA_REF    1750 
....................  
....................     #define ee_adr_jtn 0x10 
....................     #define ee_adr_ortHiz_H 0x00  //high   //16 bitlik sayý 
....................     #define ee_adr_ortHiz_L 0x01  //low 
....................     #define ee_adr_df_ses   0x02 
....................  
....................     #define mp3_stop_100mS() mp3_stop();delay_ms(100) 
....................  
....................     //433MHz alýcý baðlantý pinleri 
....................     #define tus1 PIN_D0 
....................     #define tus2 PIN_D1 
....................     #define tus3 PIN_D2 
....................     #define tus4 PIN_D3 
....................     #define tus5 PIN_D4 
....................     #define tus6 PIN_D5 
....................     #define tus_vt  PIN_B0 
....................  
....................     #define ses_miniko          1 
....................     #define ses_demo            2 
....................     #define ses_getReady        3 
....................     #define ses_remix           4 
....................     #define ses_trenDuduk       5 
....................     #define ses_sureAyar        6 
....................     #define ses_kumandaKontrol  7 
....................     #define ses_cizgiTakip      8 
....................     #define TREN_DUDUK          5 
....................     #define OYUN_SON_JENERIK    2 
....................  
....................     #define SES_AKU_SARJ_50     26 
....................     #define SES_AKU_SARJ_25     27 
....................     #define SES_AKU_SARJ_DUSUK  28 
....................     #define SES_AKU_SARJ_TAK    29 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TANIMLAMALAR_H */ 
....................  
....................  
....................  
.................... unsigned int16 k_means_veri_havuzu[SENS_SAYISI * 10]; 
.................... unsigned int16 max_esik_veri_havuzu[SENS_SAYISI * 10]; 
.................... unsigned int16 min_esik_veri_havuzu[SENS_SAYISI * 10]; 
.................... unsigned int16 max_esik_ort_deger = 0; 
.................... unsigned int16 min_esik_ort_deger = 0; 
.................... unsigned int16 k_means_esik_ort_deger = 0, baslangic_esik_ort_deger = 0; 
.................... BYTE k_means_veri_say = 0, k_means_veri_havuzu_index = 0; 
.................... BOOLEAN k_means_yeni_veri = 0; 
.................... BOOLEAN baslangic_esik_gec = FALSE; 
....................  
.................... void k_means_veri_havuzu_olustur() { 
*
01E2:  MOVLB  3
01E4:  CLRF   x1A
....................     int i = 0; 
....................  
....................     k_means_veri_say++; 
01E6:  MOVLB  2
01E8:  INCF   xE3,F
....................  
....................     if (k_means_veri_say <= 10 && !k_means_yeni_veri) { 
01EA:  MOVF   xE3,W
01EC:  SUBLW  0A
01EE:  BTFSS  FD8.0
01F0:  BRA    043E
01F2:  MOVLB  0
01F4:  BTFSS  xF5.4
01F6:  BRA    01FC
01F8:  MOVLB  2
01FA:  BRA    043E
....................  
....................         for (i = 0; i < SENS_SAYISI; i++) { 
01FC:  MOVLB  3
01FE:  CLRF   x1A
0200:  MOVF   x1A,W
0202:  SUBLW  07
0204:  BTFSS  FD8.0
0206:  BRA    043C
....................  
....................             if (ir_sens_ort_deger_e_on[i] == ir_sens_ort_deger_e_off[i] 
....................                 || 
....................                 ir_sens_ort_deger_e_on[i]<ir_sens_ort_deger_e_off[i]    ) //Aþýrý ýþýk, Von=Voff 
0208:  BCF    FD8.0
020A:  RLCF   x1A,W
020C:  CLRF   03
020E:  ADDLW  80
0210:  MOVWF  FE9
0212:  MOVLW  00
0214:  ADDWFC 03,W
0216:  MOVWF  FEA
0218:  MOVFF  FEC,31C
021C:  MOVF   FED,F
021E:  MOVFF  FEF,31B
0222:  BCF    FD8.0
0224:  RLCF   x1A,W
0226:  CLRF   03
0228:  ADDLW  90
022A:  MOVWF  FE9
022C:  MOVLW  00
022E:  ADDWFC 03,W
0230:  MOVWF  FEA
0232:  MOVFF  FEC,03
0236:  MOVF   FED,F
0238:  MOVF   FEF,W
023A:  SUBWF  x1B,W
023C:  BNZ   0244
023E:  MOVF   03,W
0240:  SUBWF  x1C,W
0242:  BZ    0286
0244:  BCF    FD8.0
0246:  RLCF   x1A,W
0248:  CLRF   03
024A:  ADDLW  80
024C:  MOVWF  FE9
024E:  MOVLW  00
0250:  ADDWFC 03,W
0252:  MOVWF  FEA
0254:  MOVFF  FEC,31C
0258:  MOVF   FED,F
025A:  MOVFF  FEF,31B
025E:  BCF    FD8.0
0260:  RLCF   x1A,W
0262:  CLRF   03
0264:  ADDLW  90
0266:  MOVWF  FE9
0268:  MOVLW  00
026A:  ADDWFC 03,W
026C:  MOVWF  FEA
026E:  MOVFF  FEC,03
0272:  MOVF   FED,F
0274:  MOVFF  FEF,01
0278:  MOVF   x1C,W
027A:  SUBWF  03,W
027C:  BNC   0322
027E:  BNZ   0286
0280:  MOVF   01,W
0282:  SUBWF  x1B,W
0284:  BC    0322
....................             { 
....................  
....................                 ir_sens_ort_deger[i] = ir_sens_ort_deger_e_on[i]; 
0286:  BCF    FD8.0
0288:  RLCF   x1A,W
028A:  CLRF   03
028C:  ADDLW  70
028E:  MOVWF  01
0290:  MOVLW  00
0292:  ADDWFC 03,F
0294:  MOVFF  03,31C
0298:  BCF    FD8.0
029A:  RLCF   x1A,W
029C:  CLRF   03
029E:  ADDLW  80
02A0:  MOVWF  FE9
02A2:  MOVLW  00
02A4:  ADDWFC 03,W
02A6:  MOVWF  FEA
02A8:  MOVFF  FEC,03
02AC:  MOVF   FED,F
02AE:  MOVFF  FEF,31D
02B2:  MOVFF  31C,FEA
02B6:  MOVFF  01,FE9
02BA:  MOVFF  03,FEC
02BE:  MOVF   FED,F
02C0:  MOVFF  31D,FEF
....................                 k_means_veri_havuzu[k_means_veri_havuzu_index++] = ir_sens_ort_deger_e_on[i]; 
02C4:  MOVLB  2
02C6:  MOVF   xE4,W
02C8:  INCF   xE4,F
02CA:  MOVWF  00
02CC:  BCF    FD8.0
02CE:  RLCF   00,F
02D0:  MOVF   00,W
02D2:  CLRF   03
02D4:  ADDLW  FB
02D6:  MOVWF  01
02D8:  MOVLW  00
02DA:  ADDWFC 03,F
02DC:  MOVLB  3
02DE:  MOVFF  03,31C
02E2:  BCF    FD8.0
02E4:  RLCF   x1A,W
02E6:  CLRF   03
02E8:  ADDLW  80
02EA:  MOVWF  FE9
02EC:  MOVLW  00
02EE:  ADDWFC 03,W
02F0:  MOVWF  FEA
02F2:  MOVFF  FEC,03
02F6:  MOVF   FED,F
02F8:  MOVFF  FEF,31D
02FC:  MOVFF  31C,FEA
0300:  MOVFF  01,FE9
0304:  MOVFF  03,FEC
0308:  MOVF   FED,F
030A:  MOVFF  31D,FEF
....................                 ir_sens_isik_durumu[i] = ASIRI_ISIK; //Sayýsallaþtýrma iþlemine hangi durumda baþlanacaðýný belirler. 
030E:  CLRF   03
0310:  MOVF   x1A,W
0312:  ADDLW  C0
0314:  MOVWF  FE9
0316:  MOVLW  00
0318:  ADDWFC 03,W
031A:  MOVWF  FEA
031C:  MOVLW  41
031E:  MOVWF  FEF
....................  
....................             } else if (ir_sens_ort_deger_e_on[i] > ir_sens_ort_deger_e_off[i] + 50) //normal ýþýk, Von>voff 
0320:  BRA    0428
0322:  BCF    FD8.0
0324:  RLCF   x1A,W
0326:  CLRF   03
0328:  ADDLW  80
032A:  MOVWF  FE9
032C:  MOVLW  00
032E:  ADDWFC 03,W
0330:  MOVWF  FEA
0332:  MOVFF  FEC,31C
0336:  MOVF   FED,F
0338:  MOVFF  FEF,31B
033C:  BCF    FD8.0
033E:  RLCF   x1A,W
0340:  CLRF   03
0342:  ADDLW  90
0344:  MOVWF  FE9
0346:  MOVLW  00
0348:  ADDWFC 03,W
034A:  MOVWF  FEA
034C:  MOVFF  FEC,31E
0350:  MOVF   FED,F
0352:  MOVFF  FEF,31D
0356:  MOVLW  32
0358:  ADDWF  x1D,W
035A:  MOVWF  01
035C:  MOVLW  00
035E:  ADDWFC x1E,W
0360:  MOVWF  03
0362:  MOVF   03,W
0364:  SUBWF  x1C,W
0366:  BNC   0428
0368:  BNZ   0370
036A:  MOVF   x1B,W
036C:  SUBWF  01,W
036E:  BC    0428
....................             { 
....................                 ir_sens_ort_deger[i] = ir_sens_ort_deger_e_on[i] - ir_sens_ort_deger_e_off[i]; 
0370:  BCF    FD8.0
0372:  RLCF   x1A,W
0374:  CLRF   03
0376:  ADDLW  70
0378:  MOVWF  01
037A:  MOVLW  00
037C:  ADDWFC 03,F
037E:  MOVFF  03,31C
0382:  BCF    FD8.0
0384:  RLCF   x1A,W
0386:  CLRF   03
0388:  ADDLW  80
038A:  MOVWF  FE9
038C:  MOVLW  00
038E:  ADDWFC 03,W
0390:  MOVWF  FEA
0392:  MOVFF  FEC,31E
0396:  MOVF   FED,F
0398:  MOVFF  FEF,31D
039C:  BCF    FD8.0
039E:  RLCF   x1A,W
03A0:  CLRF   03
03A2:  ADDLW  90
03A4:  MOVWF  FE9
03A6:  MOVLW  00
03A8:  ADDWFC 03,W
03AA:  MOVWF  FEA
03AC:  MOVFF  FEC,03
03B0:  MOVF   FED,F
03B2:  MOVF   FEF,W
03B4:  SUBWF  x1D,W
03B6:  MOVWF  00
03B8:  MOVF   03,W
03BA:  SUBWFB x1E,W
03BC:  MOVFF  31C,FEA
03C0:  MOVFF  01,FE9
03C4:  MOVWF  FEC
03C6:  MOVF   FED,F
03C8:  MOVFF  00,FEF
....................                 k_means_veri_havuzu[k_means_veri_havuzu_index++] = ir_sens_ort_deger[i]; 
03CC:  MOVLB  2
03CE:  MOVF   xE4,W
03D0:  INCF   xE4,F
03D2:  MOVWF  00
03D4:  BCF    FD8.0
03D6:  RLCF   00,F
03D8:  MOVF   00,W
03DA:  CLRF   03
03DC:  ADDLW  FB
03DE:  MOVWF  01
03E0:  MOVLW  00
03E2:  ADDWFC 03,F
03E4:  MOVLB  3
03E6:  MOVFF  03,31C
03EA:  BCF    FD8.0
03EC:  RLCF   x1A,W
03EE:  CLRF   03
03F0:  ADDLW  70
03F2:  MOVWF  FE9
03F4:  MOVLW  00
03F6:  ADDWFC 03,W
03F8:  MOVWF  FEA
03FA:  MOVFF  FEC,03
03FE:  MOVF   FED,F
0400:  MOVFF  FEF,31D
0404:  MOVFF  31C,FEA
0408:  MOVFF  01,FE9
040C:  MOVFF  03,FEC
0410:  MOVF   FED,F
0412:  MOVFF  31D,FEF
....................                 ir_sens_isik_durumu[i] = NORMAL_ISIK; //Sayýsallaþtýrma iþlemine hangi durumda baþlanacaðýný belirler. 
0416:  CLRF   03
0418:  MOVF   x1A,W
041A:  ADDLW  C0
041C:  MOVWF  FE9
041E:  MOVLW  00
0420:  ADDWFC 03,W
0422:  MOVWF  FEA
0424:  MOVLW  4E
0426:  MOVWF  FEF
....................             } 
....................  
....................             if (k_means_veri_havuzu_index >= (SENS_SAYISI * 10)) break; 
0428:  MOVLB  2
042A:  MOVF   xE4,W
042C:  SUBLW  4F
042E:  BC    0436
0430:  MOVLB  3
0432:  BRA    043C
0434:  MOVLB  2
0436:  MOVLB  3
0438:  INCF   x1A,F
043A:  BRA    0200
043C:  MOVLB  2
....................         } 
....................     } 
....................  
....................     if (k_means_veri_say >= 10 || (k_means_veri_havuzu_index >= (SENS_SAYISI * 10))) { 
043E:  MOVF   xE3,W
0440:  SUBLW  09
0442:  BNC   044A
0444:  MOVF   xE4,W
0446:  SUBLW  4F
0448:  BC    0456
....................         k_means_veri_havuzu_index = k_means_veri_say = 0; 
044A:  CLRF   xE3
044C:  MOVFF  2E3,2E4
....................         k_means_yeni_veri = TRUE; 
0450:  MOVLB  0
0452:  BSF    xF5.4
0454:  MOVLB  2
....................     } 
0456:  MOVLB  0
0458:  GOTO   0494 (RETURN)
....................  
....................  
.................... } 
....................  
.................... void k_means_baslangic_esik(unsigned int16 *veri) { 
*
06F6:  MOVLB  2
06F8:  CLRF   xF5
06FA:  CLRF   xF7
06FC:  CLRF   xF6
06FE:  MOVLW  03
0700:  MOVWF  xF9
0702:  SETF   xF8
....................     int x = 0; 
....................  
....................     unsigned int16 _max_deger = 0; 
....................     unsigned int16 _min_deger = 1023; 
....................  
....................     if (k_means_yeni_veri) { 
0704:  MOVLB  0
0706:  BTFSS  xF5.4
0708:  BRA    080C
....................  
....................         k_means_yeni_veri = FALSE; 
070A:  BCF    xF5.4
....................  
....................         for (x = 0; x < SENS_SAYISI * 10; x++) { 
070C:  MOVLB  2
070E:  CLRF   xF5
0710:  MOVF   xF5,W
0712:  SUBLW  4F
0714:  BNC   07BE
....................  
....................             if (veri[x] > _max_deger) _max_deger = veri[x]; 
0716:  CLRF   03
0718:  MOVFF  2F5,02
071C:  BCF    FD8.0
071E:  RLCF   02,F
0720:  RLCF   03,F
0722:  MOVF   02,W
0724:  ADDWF  xF3,W
0726:  MOVWF  FE9
0728:  MOVF   xF4,W
072A:  ADDWFC 03,W
072C:  MOVWF  FEA
072E:  MOVFF  FEC,2FB
0732:  MOVF   FED,F
0734:  MOVFF  FEF,2FA
0738:  MOVF   xF7,W
073A:  SUBWF  xFB,W
073C:  BNC   0768
073E:  BNZ   0746
0740:  MOVF   xFA,W
0742:  SUBWF  xF6,W
0744:  BC    0768
0746:  CLRF   03
0748:  MOVFF  2F5,02
074C:  BCF    FD8.0
074E:  RLCF   02,F
0750:  RLCF   03,F
0752:  MOVF   02,W
0754:  ADDWF  xF3,W
0756:  MOVWF  FE9
0758:  MOVF   xF4,W
075A:  ADDWFC 03,W
075C:  MOVWF  FEA
075E:  MOVFF  FEC,2F7
0762:  MOVF   FED,F
0764:  MOVFF  FEF,2F6
....................             if (veri[x] < _min_deger) _min_deger = veri[x]; 
0768:  CLRF   03
076A:  MOVFF  2F5,02
076E:  BCF    FD8.0
0770:  RLCF   02,F
0772:  RLCF   03,F
0774:  MOVF   02,W
0776:  ADDWF  xF3,W
0778:  MOVWF  FE9
077A:  MOVF   xF4,W
077C:  ADDWFC 03,W
077E:  MOVWF  FEA
0780:  MOVFF  FEC,2FB
0784:  MOVF   FED,F
0786:  MOVFF  FEF,2FA
078A:  MOVF   xFB,W
078C:  SUBWF  xF9,W
078E:  BNC   07BA
0790:  BNZ   0798
0792:  MOVF   xF8,W
0794:  SUBWF  xFA,W
0796:  BC    07BA
0798:  CLRF   03
079A:  MOVFF  2F5,02
079E:  BCF    FD8.0
07A0:  RLCF   02,F
07A2:  RLCF   03,F
07A4:  MOVF   02,W
07A6:  ADDWF  xF3,W
07A8:  MOVWF  FE9
07AA:  MOVF   xF4,W
07AC:  ADDWFC 03,W
07AE:  MOVWF  FEA
07B0:  MOVFF  FEC,2F9
07B4:  MOVF   FED,F
07B6:  MOVFF  FEF,2F8
07BA:  INCF   xF5,F
07BC:  BRA    0710
....................         } 
....................  
....................         baslangic_esik_ort_deger = (unsigned int16) ((_max_deger + _min_deger) / 2); 
07BE:  MOVF   xF8,W
07C0:  ADDWF  xF6,W
07C2:  MOVWF  xFA
07C4:  MOVF   xF9,W
07C6:  ADDWFC xF7,W
07C8:  MOVWF  xFB
07CA:  BCF    FD8.0
07CC:  RRCF   xFB,W
07CE:  MOVWF  xE2
07D0:  RRCF   xFA,W
07D2:  MOVWF  xE1
....................         if (baslangic_esik_ort_deger < 100) baslangic_esik_ort_deger = 400; 
07D4:  MOVF   xE2,F
07D6:  BNZ   07E6
07D8:  MOVF   xE1,W
07DA:  SUBLW  63
07DC:  BNC   07E6
07DE:  MOVLW  01
07E0:  MOVWF  xE2
07E2:  MOVLW  90
07E4:  MOVWF  xE1
....................          
....................         for (x = 0; x < SENS_SAYISI; x++) 
07E6:  CLRF   xF5
07E8:  MOVF   xF5,W
07EA:  SUBLW  07
07EC:  BNC   080C
....................              ir_sens_baslangic_esik_deger[x]= baslangic_esik_ort_deger; 
07EE:  BCF    FD8.0
07F0:  RLCF   xF5,W
07F2:  CLRF   03
07F4:  ADDLW  B0
07F6:  MOVWF  FE9
07F8:  MOVLW  00
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  MOVFF  2E2,FEC
0802:  MOVF   FED,F
0804:  MOVFF  2E1,FEF
0808:  INCF   xF5,F
080A:  BRA    07E8
080C:  MOVLB  0
....................     } 
080E:  GOTO   084E (RETURN)
....................  
....................  
.................... } 
....................  
.................... void k_means_baslangic_esik_olustur() { 
0812:  MOVLB  2
0814:  CLRF   xF2
0816:  CLRF   xF1
0818:  CLRF   xF0
081A:  CLRF   xEF
....................  
....................     unsigned int32 time_kal_yap = 0; 
....................     bip_rf_var(); 
081C:  CLRF   xF5
081E:  MOVLW  32
0820:  MOVWF  xF4
0822:  MOVLW  02
0824:  MOVWF  xF6
0826:  MOVLW  7C
0828:  MOVWF  xF8
082A:  MOVLW  10
082C:  MOVWF  xF7
082E:  MOVLB  0
0830:  RCALL  0522
....................     time_kal_yap=millis(); 
0832:  MOVFF  1D,2F2
0836:  MOVFF  1C,2F1
083A:  MOVFF  1B,2F0
083E:  MOVFF  1A,2EF
....................     while (1) { 
....................  
....................         k_means_baslangic_esik(k_means_veri_havuzu); 
0842:  MOVLB  2
0844:  CLRF   xF4
0846:  MOVLW  FB
0848:  MOVWF  xF3
084A:  MOVLB  0
084C:  BRA    06F6
....................  
....................         if (millis() - time_kal_yap > 5000) { 
084E:  MOVLB  2
0850:  MOVF   xEF,W
0852:  SUBWF  1A,W
0854:  MOVWF  xF3
0856:  MOVF   xF0,W
0858:  SUBWFB 1B,W
085A:  MOVWF  xF4
085C:  MOVF   xF1,W
085E:  SUBWFB 1C,W
0860:  MOVWF  xF5
0862:  MOVF   xF2,W
0864:  SUBWFB 1D,W
0866:  MOVWF  xF6
0868:  MOVF   xF6,F
086A:  BNZ   0880
086C:  MOVF   xF5,F
086E:  BNZ   0880
0870:  MOVF   xF4,W
0872:  SUBLW  12
0874:  BC    0882
0876:  XORLW  FF
0878:  BNZ   0880
087A:  MOVF   xF3,W
087C:  SUBLW  88
087E:  BC    0882
....................             break; 
0880:  BRA    0884
....................         } 
0882:  BRA    0844
....................  
....................     } 
....................     //    fprintf(usbSerial,"K Means Bas Esik:%lu \r\n",baslangic_esik_ort_deger); 
....................     bip_yazildi(); 
0884:  CLRF   xF5
0886:  MOVLW  0A
0888:  MOVWF  xF4
088A:  MOVLW  14
088C:  MOVWF  xF6
088E:  MOVLW  7C
0890:  MOVWF  xF8
0892:  MOVLW  10
0894:  MOVWF  xF7
0896:  MOVLB  0
0898:  RCALL  0522
089A:  RETURN 0
....................  
.................... } 
....................  
.................... void fuzzy_pos_led(float *f_dizi) { 
....................     int x = 0, say_siyah = 0, say_beyaz = 0; 
....................  
....................     unsigned int8 int_pos; //= (unsigned int8) ((s_pos- floor(s_pos) > 0.5) ? ceil(s_pos) : floor(s_pos)); 
....................  
....................     for (x = 0; x < 8; x++) { 
....................         if (ir_sens_ort_deger[x] < baslangic_esik_ort_deger) ++say_siyah; 
....................         if (ir_sens_ort_deger[x] > baslangic_esik_ort_deger) ++say_beyaz; 
....................     } 
....................  
....................     if (say_siyah >= 8) { 
....................         int_pos = 15; 
....................         sens_hepsi_siyah = 1; 
....................     } else sens_hepsi_siyah = 0; 
....................  
....................     if (say_beyaz >= 8) { 
....................         int_pos = 16; 
....................         sens_hepsi_beyaz = 1; 
....................     } else sens_hepsi_beyaz = 0; 
....................  
....................     for (x = 0; x < 8; x++) { 
....................  
....................         if (f_dizi[x] > 0.5) { 
....................             bit_set(lfr_led, x); 
....................             //  lfr_led_goster(lfr_led); 
....................         } else if (f_dizi[x] < 0.5) { 
....................             bit_clear(lfr_led, x); 
....................             // lfr_led_goster(lfr_led); 
....................         } 
....................     } 
....................     if (sens_hepsi_siyah) { 
....................         lfr_led = 0xFF; 
....................         //lfr_led_goster(lfr_led); 
....................     } 
....................     if (sens_hepsi_beyaz) { 
....................         lfr_led = 0x00; 
....................         // lfr_led_goster(lfr_led); 
....................     } 
....................     lfr_led_goster(lfr_led); 
....................  
.................... } 
....................  
.................... void k_means_sens_sayisal() { 
....................     int x = 0; 
....................  
....................     for (x = 0; x < SENS_SAYISI; x++) { 
....................  
....................         if (ir_sens_ort_deger[x] <= k_means_esik_ort_deger+100) 
....................         //if (ir_sens_ort_deger[x] <=  baslangic_esik_ort_deger) 
....................         { 
....................             ir_sens_sayisal_deger[x] = SIYAH; 
....................         } 
....................        
....................         if (ir_sens_ort_deger[x] > k_means_esik_ort_deger+100) 
....................         //if (ir_sens_ort_deger[x] > baslangic_esik_ort_deger) 
....................         { 
....................             ir_sens_sayisal_deger[x] = BEYAZ; 
....................         } 
....................          
....................     }//for... 
.................... } 
....................  
.................... void sens_cizgi_durum_getir(){ 
*
1B42:  MOVLB  2
1B44:  CLRF   xEF
....................     int x=0; 
....................      
....................     for(x=0;x<SENS_SAYISI;x++)   //Iþýk durum tespiti ve ortalama deger hesaplama    
1B46:  CLRF   xEF
1B48:  MOVF   xEF,W
1B4A:  SUBLW  07
1B4C:  BTFSS  FD8.0
1B4E:  BRA    1FAE
....................     { 
....................         if(ir_sens_ort_deger_e_on[x]==ir_sens_ort_deger_e_off[x] //sensor on ve off ölçümleri eþitse 
....................            ||                                                    //veya 
....................            ir_sens_ort_deger_e_on[x]<ir_sens_ort_deger_e_off[x]) // off ölçümü on ölçümünden büyükse 
1B50:  BCF    FD8.0
1B52:  RLCF   xEF,W
1B54:  CLRF   03
1B56:  ADDLW  80
1B58:  MOVWF  FE9
1B5A:  MOVLW  00
1B5C:  ADDWFC 03,W
1B5E:  MOVWF  FEA
1B60:  MOVFF  FEC,2F1
1B64:  MOVF   FED,F
1B66:  MOVFF  FEF,2F0
1B6A:  BCF    FD8.0
1B6C:  RLCF   xEF,W
1B6E:  CLRF   03
1B70:  ADDLW  90
1B72:  MOVWF  FE9
1B74:  MOVLW  00
1B76:  ADDWFC 03,W
1B78:  MOVWF  FEA
1B7A:  MOVFF  FEC,03
1B7E:  MOVF   FED,F
1B80:  MOVF   FEF,W
1B82:  SUBWF  xF0,W
1B84:  BNZ   1B8C
1B86:  MOVF   03,W
1B88:  SUBWF  xF1,W
1B8A:  BZ    1BCE
1B8C:  BCF    FD8.0
1B8E:  RLCF   xEF,W
1B90:  CLRF   03
1B92:  ADDLW  80
1B94:  MOVWF  FE9
1B96:  MOVLW  00
1B98:  ADDWFC 03,W
1B9A:  MOVWF  FEA
1B9C:  MOVFF  FEC,2F1
1BA0:  MOVF   FED,F
1BA2:  MOVFF  FEF,2F0
1BA6:  BCF    FD8.0
1BA8:  RLCF   xEF,W
1BAA:  CLRF   03
1BAC:  ADDLW  90
1BAE:  MOVWF  FE9
1BB0:  MOVLW  00
1BB2:  ADDWFC 03,W
1BB4:  MOVWF  FEA
1BB6:  MOVFF  FEC,03
1BBA:  MOVF   FED,F
1BBC:  MOVFF  FEF,01
1BC0:  MOVF   xF1,W
1BC2:  SUBWF  03,W
1BC4:  BNC   1C50
1BC6:  BNZ   1BCE
1BC8:  MOVF   01,W
1BCA:  SUBWF  xF0,W
1BCC:  BC    1C50
....................         { 
....................            // ir_sens_ort_deger[x]=0;                              // sensor AÞIRI ýþýk altýnda 
....................             ir_sens_isik_durumu[x]=ASIRI_ISIK; 
1BCE:  CLRF   03
1BD0:  MOVF   xEF,W
1BD2:  ADDLW  C0
1BD4:  MOVWF  FE9
1BD6:  MOVLW  00
1BD8:  ADDWFC 03,W
1BDA:  MOVWF  FEA
1BDC:  MOVLW  41
1BDE:  MOVWF  FEF
....................              
....................             ir_sens_asiri_isik_deger[x]=ir_sens_ort_deger_e_on[x];  //Siyahta olma aþýrý ýþýk koþulu için Von deger kaydediliyor... 
1BE0:  BCF    FD8.0
1BE2:  RLCF   xEF,W
1BE4:  CLRF   03
1BE6:  ADDLW  C8
1BE8:  MOVWF  01
1BEA:  MOVLW  00
1BEC:  ADDWFC 03,F
1BEE:  MOVFF  03,2F1
1BF2:  BCF    FD8.0
1BF4:  RLCF   xEF,W
1BF6:  CLRF   03
1BF8:  ADDLW  80
1BFA:  MOVWF  FE9
1BFC:  MOVLW  00
1BFE:  ADDWFC 03,W
1C00:  MOVWF  FEA
1C02:  MOVFF  FEC,03
1C06:  MOVF   FED,F
1C08:  MOVFF  FEF,2F2
1C0C:  MOVFF  2F1,FEA
1C10:  MOVFF  01,FE9
1C14:  MOVFF  03,FEC
1C18:  MOVF   FED,F
1C1A:  MOVFF  2F2,FEF
....................             fprintf(usbSerial,"--> ASIRI ISIK:%u\r\n",x); 
1C1E:  MOVLW  BE
1C20:  MOVWF  FF6
1C22:  MOVLW  00
1C24:  MOVWF  FF7
1C26:  MOVLW  0F
1C28:  MOVWF  xF0
1C2A:  MOVLB  0
1C2C:  RCALL  1A6E
1C2E:  MOVFF  2EF,2F0
1C32:  MOVLW  1B
1C34:  MOVLB  2
1C36:  MOVWF  xF1
1C38:  MOVLB  0
1C3A:  RCALL  1AC4
1C3C:  MOVLW  0D
1C3E:  BTFSS  FA4.4
1C40:  BRA    1C3E
1C42:  MOVWF  F73
1C44:  MOVLW  0A
1C46:  BTFSS  FA4.4
1C48:  BRA    1C46
1C4A:  MOVWF  F73
....................         } 
1C4C:  BRA    1DC0
1C4E:  MOVLB  2
....................         else 
....................         { 
....................  
....................             if (son_isik_durumu[x] == ASIRI_ISIK) // ASIRI_ISIK--> NORMAL_ISIK geçiþi 
1C50:  CLRF   03
1C52:  MOVF   xEF,W
1C54:  ADDLW  D8
1C56:  MOVWF  FE9
1C58:  MOVLW  00
1C5A:  ADDWFC 03,W
1C5C:  MOVWF  FEA
1C5E:  MOVF   FEF,W
1C60:  SUBLW  41
1C62:  BNZ   1CAE
....................             { 
....................                // ir_sens_baslangic_esik_deger[x] = k_means_esik_ort_deger; // ilk degeri güncelle 
....................                 ir_sens_esik_deger[x]=k_means_esik_ort_deger; 
1C64:  BCF    FD8.0
1C66:  RLCF   xEF,W
1C68:  CLRF   03
1C6A:  ADDLW  A0
1C6C:  MOVWF  FE9
1C6E:  MOVLW  00
1C70:  ADDWFC 03,W
1C72:  MOVWF  FEA
1C74:  MOVFF  2E0,FEC
1C78:  MOVF   FED,F
1C7A:  MOVFF  2DF,FEF
....................                // ir_sens_ort_deger[x] = ir_sens_ort_deger_e_on[x] - ir_sens_ort_deger_e_off[x]; 
....................               //  ir_sens_isik_durumu[x] = NORMAL_ISIK; 
....................                  
....................                 fprintf(usbSerial, "--> Normal ISIK:%u\r\n",x); 
1C7E:  MOVLW  D2
1C80:  MOVWF  FF6
1C82:  MOVLW  00
1C84:  MOVWF  FF7
1C86:  MOVLW  10
1C88:  MOVWF  xF0
1C8A:  MOVLB  0
1C8C:  RCALL  1A6E
1C8E:  MOVFF  2EF,2F0
1C92:  MOVLW  1B
1C94:  MOVLB  2
1C96:  MOVWF  xF1
1C98:  MOVLB  0
1C9A:  RCALL  1AC4
1C9C:  MOVLW  0D
1C9E:  BTFSS  FA4.4
1CA0:  BRA    1C9E
1CA2:  MOVWF  F73
1CA4:  MOVLW  0A
1CA6:  BTFSS  FA4.4
1CA8:  BRA    1CA6
1CAA:  MOVWF  F73
1CAC:  MOVLB  2
....................             }  
....................             if (son_isik_durumu[x] == NORMAL_ISIK)  
1CAE:  CLRF   03
1CB0:  MOVF   xEF,W
1CB2:  ADDLW  D8
1CB4:  MOVWF  FE9
1CB6:  MOVLW  00
1CB8:  ADDWFC 03,W
1CBA:  MOVWF  FEA
1CBC:  MOVF   FEF,W
1CBE:  SUBLW  4E
1CC0:  BTFSS  FD8.2
1CC2:  BRA    1DBE
....................             { 
....................                 if (ir_sens_ort_deger_e_on[x] > ir_sens_ort_deger_e_off[x] + 100) //100=~500mV 
1CC4:  BCF    FD8.0
1CC6:  RLCF   xEF,W
1CC8:  CLRF   03
1CCA:  ADDLW  80
1CCC:  MOVWF  FE9
1CCE:  MOVLW  00
1CD0:  ADDWFC 03,W
1CD2:  MOVWF  FEA
1CD4:  MOVFF  FEC,2F1
1CD8:  MOVF   FED,F
1CDA:  MOVFF  FEF,2F0
1CDE:  BCF    FD8.0
1CE0:  RLCF   xEF,W
1CE2:  CLRF   03
1CE4:  ADDLW  90
1CE6:  MOVWF  FE9
1CE8:  MOVLW  00
1CEA:  ADDWFC 03,W
1CEC:  MOVWF  FEA
1CEE:  MOVFF  FEC,2F3
1CF2:  MOVF   FED,F
1CF4:  MOVFF  FEF,2F2
1CF8:  MOVLW  64
1CFA:  ADDWF  xF2,W
1CFC:  MOVWF  01
1CFE:  MOVLW  00
1D00:  ADDWFC xF3,W
1D02:  MOVWF  03
1D04:  MOVF   03,W
1D06:  SUBWF  xF1,W
1D08:  BNC   1DBE
1D0A:  BNZ   1D12
1D0C:  MOVF   xF0,W
1D0E:  SUBWF  01,W
1D10:  BC    1DBE
....................                 { 
....................                     ir_sens_ort_deger[x] = ir_sens_ort_deger_e_on[x] - ir_sens_ort_deger_e_off[x]; 
1D12:  BCF    FD8.0
1D14:  RLCF   xEF,W
1D16:  CLRF   03
1D18:  ADDLW  70
1D1A:  MOVWF  01
1D1C:  MOVLW  00
1D1E:  ADDWFC 03,F
1D20:  MOVFF  03,2F1
1D24:  BCF    FD8.0
1D26:  RLCF   xEF,W
1D28:  CLRF   03
1D2A:  ADDLW  80
1D2C:  MOVWF  FE9
1D2E:  MOVLW  00
1D30:  ADDWFC 03,W
1D32:  MOVWF  FEA
1D34:  MOVFF  FEC,2F3
1D38:  MOVF   FED,F
1D3A:  MOVFF  FEF,2F2
1D3E:  BCF    FD8.0
1D40:  RLCF   xEF,W
1D42:  CLRF   03
1D44:  ADDLW  90
1D46:  MOVWF  FE9
1D48:  MOVLW  00
1D4A:  ADDWFC 03,W
1D4C:  MOVWF  FEA
1D4E:  MOVFF  FEC,03
1D52:  MOVF   FED,F
1D54:  MOVF   FEF,W
1D56:  SUBWF  xF2,W
1D58:  MOVWF  00
1D5A:  MOVF   03,W
1D5C:  SUBWFB xF3,W
1D5E:  MOVFF  2F1,FEA
1D62:  MOVFF  01,FE9
1D66:  MOVWF  FEC
1D68:  MOVF   FED,F
1D6A:  MOVFF  00,FEF
....................                     ir_sens_isik_durumu[x] = NORMAL_ISIK; 
1D6E:  CLRF   03
1D70:  MOVF   xEF,W
1D72:  ADDLW  C0
1D74:  MOVWF  FE9
1D76:  MOVLW  00
1D78:  ADDWFC 03,W
1D7A:  MOVWF  FEA
1D7C:  MOVLW  4E
1D7E:  MOVWF  FEF
....................                    // ir_sens_esik_deger[x] = k_means_esik_ort_deger;// 
....................                     ir_sens_esik_deger[x] = ir_sens_baslangic_esik_deger[x]; 
1D80:  BCF    FD8.0
1D82:  RLCF   xEF,W
1D84:  CLRF   03
1D86:  ADDLW  A0
1D88:  MOVWF  01
1D8A:  MOVLW  00
1D8C:  ADDWFC 03,F
1D8E:  MOVFF  03,2F1
1D92:  BCF    FD8.0
1D94:  RLCF   xEF,W
1D96:  CLRF   03
1D98:  ADDLW  B0
1D9A:  MOVWF  FE9
1D9C:  MOVLW  00
1D9E:  ADDWFC 03,W
1DA0:  MOVWF  FEA
1DA2:  MOVFF  FEC,03
1DA6:  MOVF   FED,F
1DA8:  MOVFF  FEF,2F2
1DAC:  MOVFF  2F1,FEA
1DB0:  MOVFF  01,FE9
1DB4:  MOVFF  03,FEC
1DB8:  MOVF   FED,F
1DBA:  MOVFF  2F2,FEF
1DBE:  MOVLB  0
....................  
....................                 } 
....................             } 
....................         }  
....................         //*                         *// 
....................  
....................         if(ir_sens_isik_durumu[x]==ASIRI_ISIK) ////Von==Voff 
1DC0:  CLRF   03
1DC2:  MOVLB  2
1DC4:  MOVF   xEF,W
1DC6:  ADDLW  C0
1DC8:  MOVWF  FE9
1DCA:  MOVLW  00
1DCC:  ADDWFC 03,W
1DCE:  MOVWF  FEA
1DD0:  MOVF   FEF,W
1DD2:  SUBLW  41
1DD4:  BNZ   1DE6
....................         { 
....................             ir_sens_sayisal_deger[x]=BEYAZ; 
1DD6:  CLRF   03
1DD8:  MOVF   xEF,W
1DDA:  ADDLW  E0
1DDC:  MOVWF  FE9
1DDE:  MOVLW  00
1DE0:  ADDWFC 03,W
1DE2:  MOVWF  FEA
1DE4:  CLRF   FEF
....................            // hepsi_beyaz_say++; 
....................         } 
....................  
....................         if(ir_sens_isik_durumu[x]==NORMAL_ISIK) 
1DE6:  CLRF   03
1DE8:  MOVF   xEF,W
1DEA:  ADDLW  C0
1DEC:  MOVWF  FE9
1DEE:  MOVLW  00
1DF0:  ADDWFC 03,W
1DF2:  MOVWF  FEA
1DF4:  MOVF   FEF,W
1DF6:  SUBLW  4E
1DF8:  BNZ   1EA0
....................         { 
....................             if(ir_sens_ort_deger[x]> ir_sens_esik_deger[x]) { 
1DFA:  BCF    FD8.0
1DFC:  RLCF   xEF,W
1DFE:  CLRF   03
1E00:  ADDLW  70
1E02:  MOVWF  FE9
1E04:  MOVLW  00
1E06:  ADDWFC 03,W
1E08:  MOVWF  FEA
1E0A:  MOVFF  FEC,2F1
1E0E:  MOVF   FED,F
1E10:  MOVFF  FEF,2F0
1E14:  BCF    FD8.0
1E16:  RLCF   xEF,W
1E18:  CLRF   03
1E1A:  ADDLW  A0
1E1C:  MOVWF  FE9
1E1E:  MOVLW  00
1E20:  ADDWFC 03,W
1E22:  MOVWF  FEA
1E24:  MOVFF  FEC,03
1E28:  MOVF   FED,F
1E2A:  MOVFF  FEF,01
1E2E:  MOVF   03,W
1E30:  SUBWF  xF1,W
1E32:  BNC   1E4C
1E34:  BNZ   1E3C
1E36:  MOVF   xF0,W
1E38:  SUBWF  01,W
1E3A:  BC    1E4C
....................                 ir_sens_sayisal_deger[x]=BEYAZ; 
1E3C:  CLRF   03
1E3E:  MOVF   xEF,W
1E40:  ADDLW  E0
1E42:  MOVWF  FE9
1E44:  MOVLW  00
1E46:  ADDWFC 03,W
1E48:  MOVWF  FEA
1E4A:  CLRF   FEF
....................                  //hepsi_beyaz_say++; 
....................             } 
....................              
....................             if(ir_sens_ort_deger[x]< ir_sens_esik_deger[x]) //Normal ýþýk SIYAH tespiti 
1E4C:  BCF    FD8.0
1E4E:  RLCF   xEF,W
1E50:  CLRF   03
1E52:  ADDLW  70
1E54:  MOVWF  FE9
1E56:  MOVLW  00
1E58:  ADDWFC 03,W
1E5A:  MOVWF  FEA
1E5C:  MOVFF  FEC,2F1
1E60:  MOVF   FED,F
1E62:  MOVFF  FEF,2F0
1E66:  BCF    FD8.0
1E68:  RLCF   xEF,W
1E6A:  CLRF   03
1E6C:  ADDLW  A0
1E6E:  MOVWF  FE9
1E70:  MOVLW  00
1E72:  ADDWFC 03,W
1E74:  MOVWF  FEA
1E76:  MOVFF  FEC,03
1E7A:  MOVF   FED,F
1E7C:  MOVFF  FEF,01
1E80:  MOVF   xF1,W
1E82:  SUBWF  03,W
1E84:  BNC   1EA0
1E86:  BNZ   1E8E
1E88:  MOVF   01,W
1E8A:  SUBWF  xF0,W
1E8C:  BC    1EA0
....................             { 
....................                 ir_sens_sayisal_deger[x]=SIYAH; 
1E8E:  CLRF   03
1E90:  MOVF   xEF,W
1E92:  ADDLW  E0
1E94:  MOVWF  FE9
1E96:  MOVLW  00
1E98:  ADDWFC 03,W
1E9A:  MOVWF  FEA
1E9C:  MOVLW  01
1E9E:  MOVWF  FEF
....................                // hepsi_siyah_say++; 
....................             } 
....................         } 
....................  
....................         if((ir_sens_ort_deger_e_on[x]>ir_sens_ort_deger_e_off[x]) //Aþýrý ýþýk altýnda siyah tespiti 
....................                // &&  (ir_sens_esik_deger[x]<350)) //350:1.7V  //deneysel çalýþmaya göre bulundu dolayýsý ile baðýmlý bir durum 
....................                && (son_isik_durumu[x]==ASIRI_ISIK))                                   // adaptif olamaz. 
1EA0:  BCF    FD8.0
1EA2:  RLCF   xEF,W
1EA4:  CLRF   03
1EA6:  ADDLW  80
1EA8:  MOVWF  FE9
1EAA:  MOVLW  00
1EAC:  ADDWFC 03,W
1EAE:  MOVWF  FEA
1EB0:  MOVFF  FEC,2F1
1EB4:  MOVF   FED,F
1EB6:  MOVFF  FEF,2F0
1EBA:  BCF    FD8.0
1EBC:  RLCF   xEF,W
1EBE:  CLRF   03
1EC0:  ADDLW  90
1EC2:  MOVWF  FE9
1EC4:  MOVLW  00
1EC6:  ADDWFC 03,W
1EC8:  MOVWF  FEA
1ECA:  MOVFF  FEC,03
1ECE:  MOVF   FED,F
1ED0:  MOVFF  FEF,01
1ED4:  MOVF   03,W
1ED6:  SUBWF  xF1,W
1ED8:  BNC   1F7C
1EDA:  BNZ   1EE2
1EDC:  MOVF   xF0,W
1EDE:  SUBWF  01,W
1EE0:  BC    1F7C
1EE2:  CLRF   03
1EE4:  MOVF   xEF,W
1EE6:  ADDLW  D8
1EE8:  MOVWF  FE9
1EEA:  MOVLW  00
1EEC:  ADDWFC 03,W
1EEE:  MOVWF  FEA
1EF0:  MOVF   FEF,W
1EF2:  SUBLW  41
1EF4:  BNZ   1F7C
....................              
....................         { 
....................             if((ir_sens_ort_deger_e_on[x]<ir_sens_asiri_isik_deger[x]-100)&& ir_sens_ort_deger[x]>0){ 
1EF6:  BCF    FD8.0
1EF8:  RLCF   xEF,W
1EFA:  CLRF   03
1EFC:  ADDLW  80
1EFE:  MOVWF  FE9
1F00:  MOVLW  00
1F02:  ADDWFC 03,W
1F04:  MOVWF  FEA
1F06:  MOVFF  FEC,2F1
1F0A:  MOVF   FED,F
1F0C:  MOVFF  FEF,2F0
1F10:  BCF    FD8.0
1F12:  RLCF   xEF,W
1F14:  CLRF   03
1F16:  ADDLW  C8
1F18:  MOVWF  FE9
1F1A:  MOVLW  00
1F1C:  ADDWFC 03,W
1F1E:  MOVWF  FEA
1F20:  MOVFF  FEC,2F3
1F24:  MOVF   FED,F
1F26:  MOVFF  FEF,2F2
1F2A:  MOVLW  64
1F2C:  SUBWF  xF2,W
1F2E:  MOVWF  00
1F30:  MOVLW  00
1F32:  SUBWFB xF3,W
1F34:  MOVWF  03
1F36:  MOVFF  00,01
1F3A:  MOVF   xF1,W
1F3C:  SUBWF  03,W
1F3E:  BNC   1F7C
1F40:  BNZ   1F48
1F42:  MOVF   01,W
1F44:  SUBWF  xF0,W
1F46:  BC    1F7C
1F48:  BCF    FD8.0
1F4A:  RLCF   xEF,W
1F4C:  CLRF   03
1F4E:  ADDLW  70
1F50:  MOVWF  FE9
1F52:  MOVLW  00
1F54:  ADDWFC 03,W
1F56:  MOVWF  FEA
1F58:  MOVFF  FEC,2F1
1F5C:  MOVF   FED,F
1F5E:  MOVFF  FEF,2F0
1F62:  MOVF   xF0,F
1F64:  BNZ   1F6A
1F66:  MOVF   xF1,F
1F68:  BZ    1F7C
....................                 ir_sens_sayisal_deger[x]=SIYAH;      
1F6A:  CLRF   03
1F6C:  MOVF   xEF,W
1F6E:  ADDLW  E0
1F70:  MOVWF  FE9
1F72:  MOVLW  00
1F74:  ADDWFC 03,W
1F76:  MOVWF  FEA
1F78:  MOVLW  01
1F7A:  MOVWF  FEF
....................                // hepsi_siyah_say++; 
....................             } 
....................         } 
....................         son_isik_durumu[x]= ir_sens_isik_durumu[x];  //deðiþimi algýlmak için 
1F7C:  CLRF   03
1F7E:  MOVF   xEF,W
1F80:  ADDLW  D8
1F82:  MOVWF  01
1F84:  MOVLW  00
1F86:  ADDWFC 03,F
1F88:  MOVFF  03,2F1
1F8C:  CLRF   03
1F8E:  MOVF   xEF,W
1F90:  ADDLW  C0
1F92:  MOVWF  FE9
1F94:  MOVLW  00
1F96:  ADDWFC 03,W
1F98:  MOVWF  FEA
1F9A:  MOVFF  FEF,2F2
1F9E:  MOVFF  2F1,FEA
1FA2:  MOVFF  01,FE9
1FA6:  MOVFF  2F2,FEF
1FAA:  INCF   xEF,F
1FAC:  BRA    1B48
....................  
.................... //        //Sayýsal durum incelemesi... 
.................... //        if(!ir_sens_sayisal_deger[3] && !ir_sens_sayisal_deger[4]){ 
.................... //            if(ir_sens_sayisal_deger[0] || ir_sens_sayisal_deger[1] || ir_sens_sayisal_deger[2]){ 
.................... //                ir_sens_sayisal_deger[5]=ir_sens_sayisal_deger[6]=ir_sens_sayisal_deger[7]=BEYAZ; 
.................... //            } 
.................... //            if(ir_sens_sayisal_deger[5] || ir_sens_sayisal_deger[6] || ir_sens_sayisal_deger[7]){ 
.................... //                ir_sens_sayisal_deger[0]=ir_sens_sayisal_deger[1]=ir_sens_sayisal_deger[2]=BEYAZ; 
.................... //            } 
.................... //        } 
.................... //        if(ir_sens_sayisal_deger[3] && ir_sens_sayisal_deger[4]){ 
.................... //            ir_sens_sayisal_deger[0]=ir_sens_sayisal_deger[1]=ir_sens_sayisal_deger[2]=BEYAZ; 
.................... //            ir_sens_sayisal_deger[5]=ir_sens_sayisal_deger[6]=ir_sens_sayisal_deger[7]=BEYAZ; 
.................... //        } 
.................... //         
.................... //        if(hepsi_beyaz_say>=SENS_SAYISI) 
.................... //            sens_hepsi_beyaz=1; 
.................... //        else sens_hepsi_beyaz=0; 
.................... //         
.................... //        if(hepsi_siyah_say>=SENS_SAYISI) 
.................... //            sens_hepsi_siyah=1; 
.................... //        else sens_hepsi_siyah=0; 
....................          
....................     }//for 
1FAE:  MOVLB  0
1FB0:  RETURN 0
.................... }// 
....................  
.................... int k_means_max_min_esik() { 
*
1702:  MOVLB  2
1704:  CLRF   xEF
1706:  CLRF   xF0
1708:  CLRF   xF1
170A:  CLRF   xF2
170C:  CLRF   xF6
170E:  CLRF   xF5
1710:  CLRF   xF4
1712:  CLRF   xF3
1714:  CLRF   xFA
1716:  CLRF   xF9
1718:  CLRF   xF8
171A:  CLRF   xF7
171C:  CLRF   xFC
171E:  CLRF   xFB
....................     int x = 0, _max_index = 0, _min_index = 0, yineleme = 0; 
....................     unsigned int32 _maxtop = 0, _mintop = 0; 
....................     unsigned int16 son_deger = 0; 
....................  
....................     max_esik_ort_deger = 0; 
1720:  CLRF   xDC
1722:  CLRF   xDB
....................     min_esik_ort_deger = 1023; 
1724:  MOVLW  03
1726:  MOVWF  xDE
1728:  SETF   xDD
....................  
....................     memset(max_esik_veri_havuzu, 0, SENS_SAYISI * 10); 
172A:  MOVLW  01
172C:  MOVWF  FEA
172E:  MOVLW  9B
1730:  MOVWF  FE9
1732:  CLRF   00
1734:  CLRF   02
1736:  MOVLW  50
1738:  MOVWF  01
173A:  MOVLB  0
173C:  CALL   06DC
....................     memset(min_esik_veri_havuzu, 0, SENS_SAYISI * 10); 
1740:  MOVLW  02
1742:  MOVWF  FEA
1744:  MOVLW  3B
1746:  MOVWF  FE9
1748:  CLRF   00
174A:  CLRF   02
174C:  MOVLW  50
174E:  MOVWF  01
1750:  CALL   06DC
....................  
....................     do { 
....................         max_esik_ort_deger = 0; 
1754:  MOVLB  2
1756:  CLRF   xDC
1758:  CLRF   xDB
....................         min_esik_ort_deger = 1023; 
175A:  MOVLW  03
175C:  MOVWF  xDE
175E:  SETF   xDD
....................  
....................         for (x = 0; x < SENS_SAYISI * 10; x++) { 
1760:  CLRF   xEF
1762:  MOVF   xEF,W
1764:  SUBLW  4F
1766:  BTFSS  FD8.0
1768:  BRA    194A
....................  
....................             if (!baslangic_esik_gec) { 
176A:  MOVLB  0
176C:  BTFSC  xF5.5
176E:  BRA    17E2
....................                 if (k_means_veri_havuzu[x] > baslangic_esik_ort_deger) { 
1770:  BCF    FD8.0
1772:  MOVLB  2
1774:  RLCF   xEF,W
1776:  CLRF   03
1778:  ADDLW  FB
177A:  MOVWF  FE9
177C:  MOVLW  00
177E:  ADDWFC 03,W
1780:  MOVWF  FEA
1782:  MOVFF  FEC,2FE
1786:  MOVF   FED,F
1788:  MOVFF  FEF,2FD
178C:  MOVF   xE2,W
178E:  SUBWF  xFE,W
1790:  BNC   17E0
1792:  BNZ   179A
1794:  MOVF   xFD,W
1796:  SUBWF  xE1,W
1798:  BC    17E0
....................                     max_esik_veri_havuzu[_max_index++] = k_means_veri_havuzu[x]; 
179A:  MOVF   xF0,W
179C:  INCF   xF0,F
179E:  MOVWF  00
17A0:  BCF    FD8.0
17A2:  RLCF   00,F
17A4:  MOVF   00,W
17A6:  CLRF   03
17A8:  ADDLW  9B
17AA:  MOVWF  01
17AC:  MOVLW  01
17AE:  ADDWFC 03,F
17B0:  MOVFF  03,2FE
17B4:  BCF    FD8.0
17B6:  RLCF   xEF,W
17B8:  CLRF   03
17BA:  ADDLW  FB
17BC:  MOVWF  FE9
17BE:  MOVLW  00
17C0:  ADDWFC 03,W
17C2:  MOVWF  FEA
17C4:  MOVFF  FEC,03
17C8:  MOVF   FED,F
17CA:  MOVFF  FEF,2FF
17CE:  MOVFF  2FE,FEA
17D2:  MOVFF  01,FE9
17D6:  MOVFF  03,FEC
17DA:  MOVF   FED,F
17DC:  MOVFF  2FF,FEF
17E0:  MOVLB  0
....................                 } 
....................             } 
....................             if (baslangic_esik_gec) { 
17E2:  BTFSS  xF5.5
17E4:  BRA    1858
....................                 if (k_means_veri_havuzu[x] > k_means_esik_ort_deger) { 
17E6:  BCF    FD8.0
17E8:  MOVLB  2
17EA:  RLCF   xEF,W
17EC:  CLRF   03
17EE:  ADDLW  FB
17F0:  MOVWF  FE9
17F2:  MOVLW  00
17F4:  ADDWFC 03,W
17F6:  MOVWF  FEA
17F8:  MOVFF  FEC,2FE
17FC:  MOVF   FED,F
17FE:  MOVFF  FEF,2FD
1802:  MOVF   xE0,W
1804:  SUBWF  xFE,W
1806:  BNC   1856
1808:  BNZ   1810
180A:  MOVF   xFD,W
180C:  SUBWF  xDF,W
180E:  BC    1856
....................                     max_esik_veri_havuzu[_max_index++] = k_means_veri_havuzu[x]; 
1810:  MOVF   xF0,W
1812:  INCF   xF0,F
1814:  MOVWF  00
1816:  BCF    FD8.0
1818:  RLCF   00,F
181A:  MOVF   00,W
181C:  CLRF   03
181E:  ADDLW  9B
1820:  MOVWF  01
1822:  MOVLW  01
1824:  ADDWFC 03,F
1826:  MOVFF  03,2FE
182A:  BCF    FD8.0
182C:  RLCF   xEF,W
182E:  CLRF   03
1830:  ADDLW  FB
1832:  MOVWF  FE9
1834:  MOVLW  00
1836:  ADDWFC 03,W
1838:  MOVWF  FEA
183A:  MOVFF  FEC,03
183E:  MOVF   FED,F
1840:  MOVFF  FEF,2FF
1844:  MOVFF  2FE,FEA
1848:  MOVFF  01,FE9
184C:  MOVFF  03,FEC
1850:  MOVF   FED,F
1852:  MOVFF  2FF,FEF
1856:  MOVLB  0
....................  
....................                 } 
....................             } 
....................  
....................             if (!baslangic_esik_gec) { 
1858:  BTFSC  xF5.5
185A:  BRA    18CE
....................                 if (k_means_veri_havuzu[x] < baslangic_esik_ort_deger) { 
185C:  BCF    FD8.0
185E:  MOVLB  2
1860:  RLCF   xEF,W
1862:  CLRF   03
1864:  ADDLW  FB
1866:  MOVWF  FE9
1868:  MOVLW  00
186A:  ADDWFC 03,W
186C:  MOVWF  FEA
186E:  MOVFF  FEC,2FE
1872:  MOVF   FED,F
1874:  MOVFF  FEF,2FD
1878:  MOVF   xFE,W
187A:  SUBWF  xE2,W
187C:  BNC   18CC
187E:  BNZ   1886
1880:  MOVF   xE1,W
1882:  SUBWF  xFD,W
1884:  BC    18CC
....................                     min_esik_veri_havuzu[_min_index++] = k_means_veri_havuzu[x]; 
1886:  MOVF   xF1,W
1888:  INCF   xF1,F
188A:  MOVWF  00
188C:  BCF    FD8.0
188E:  RLCF   00,F
1890:  MOVF   00,W
1892:  CLRF   03
1894:  ADDLW  3B
1896:  MOVWF  01
1898:  MOVLW  02
189A:  ADDWFC 03,F
189C:  MOVFF  03,2FE
18A0:  BCF    FD8.0
18A2:  RLCF   xEF,W
18A4:  CLRF   03
18A6:  ADDLW  FB
18A8:  MOVWF  FE9
18AA:  MOVLW  00
18AC:  ADDWFC 03,W
18AE:  MOVWF  FEA
18B0:  MOVFF  FEC,03
18B4:  MOVF   FED,F
18B6:  MOVFF  FEF,2FF
18BA:  MOVFF  2FE,FEA
18BE:  MOVFF  01,FE9
18C2:  MOVFF  03,FEC
18C6:  MOVF   FED,F
18C8:  MOVFF  2FF,FEF
18CC:  MOVLB  0
....................                 } 
....................             } 
....................             if (baslangic_esik_gec) { 
18CE:  BTFSS  xF5.5
18D0:  BRA    1944
....................                 if (k_means_veri_havuzu[x] < k_means_esik_ort_deger) { 
18D2:  BCF    FD8.0
18D4:  MOVLB  2
18D6:  RLCF   xEF,W
18D8:  CLRF   03
18DA:  ADDLW  FB
18DC:  MOVWF  FE9
18DE:  MOVLW  00
18E0:  ADDWFC 03,W
18E2:  MOVWF  FEA
18E4:  MOVFF  FEC,2FE
18E8:  MOVF   FED,F
18EA:  MOVFF  FEF,2FD
18EE:  MOVF   xFE,W
18F0:  SUBWF  xE0,W
18F2:  BNC   1942
18F4:  BNZ   18FC
18F6:  MOVF   xDF,W
18F8:  SUBWF  xFD,W
18FA:  BC    1942
....................                     min_esik_veri_havuzu[_min_index++] = k_means_veri_havuzu[x]; 
18FC:  MOVF   xF1,W
18FE:  INCF   xF1,F
1900:  MOVWF  00
1902:  BCF    FD8.0
1904:  RLCF   00,F
1906:  MOVF   00,W
1908:  CLRF   03
190A:  ADDLW  3B
190C:  MOVWF  01
190E:  MOVLW  02
1910:  ADDWFC 03,F
1912:  MOVFF  03,2FE
1916:  BCF    FD8.0
1918:  RLCF   xEF,W
191A:  CLRF   03
191C:  ADDLW  FB
191E:  MOVWF  FE9
1920:  MOVLW  00
1922:  ADDWFC 03,W
1924:  MOVWF  FEA
1926:  MOVFF  FEC,03
192A:  MOVF   FED,F
192C:  MOVFF  FEF,2FF
1930:  MOVFF  2FE,FEA
1934:  MOVFF  01,FE9
1938:  MOVFF  03,FEC
193C:  MOVF   FED,F
193E:  MOVFF  2FF,FEF
1942:  MOVLB  0
....................                 } 
....................             } 
1944:  MOVLB  2
1946:  INCF   xEF,F
1948:  BRA    1762
....................  
....................             // fprintf(usbSerial,"%lu,",k_means_veri_havuzu[x]); 
....................             //  fprintf(usbSerial,"%lu,",max_esik_veri_havuzu[_max_index]); 
....................             // fprintf(usbSerial,"%lu,",k_means_veri_havuzu[x]); 
....................  
....................         }//for 
....................  
....................         // fprintf(usbSerial,"\r\n"); 
....................  
....................         baslangic_esik_gec = TRUE; 
194A:  MOVLB  0
194C:  BSF    xF5.5
....................  
....................         for (x = 0; x < _max_index; x++) _maxtop += max_esik_veri_havuzu[x]; 
194E:  MOVLB  2
1950:  CLRF   xEF
1952:  MOVF   xF0,W
1954:  SUBWF  xEF,W
1956:  BC    1980
1958:  BCF    FD8.0
195A:  RLCF   xEF,W
195C:  CLRF   03
195E:  ADDLW  9B
1960:  MOVWF  FE9
1962:  MOVLW  01
1964:  ADDWFC 03,W
1966:  MOVWF  FEA
1968:  MOVFF  FEC,03
196C:  MOVF   FED,F
196E:  MOVF   FEF,W
1970:  ADDWF  xF3,F
1972:  MOVF   03,W
1974:  ADDWFC xF4,F
1976:  MOVLW  00
1978:  ADDWFC xF5,F
197A:  ADDWFC xF6,F
197C:  INCF   xEF,F
197E:  BRA    1952
....................         for (x = 0; x < _min_index; x++) _mintop += min_esik_veri_havuzu[x]; 
1980:  CLRF   xEF
1982:  MOVF   xF1,W
1984:  SUBWF  xEF,W
1986:  BC    19B0
1988:  BCF    FD8.0
198A:  RLCF   xEF,W
198C:  CLRF   03
198E:  ADDLW  3B
1990:  MOVWF  FE9
1992:  MOVLW  02
1994:  ADDWFC 03,W
1996:  MOVWF  FEA
1998:  MOVFF  FEC,03
199C:  MOVF   FED,F
199E:  MOVF   FEF,W
19A0:  ADDWF  xF7,F
19A2:  MOVF   03,W
19A4:  ADDWFC xF8,F
19A6:  MOVLW  00
19A8:  ADDWFC xF9,F
19AA:  ADDWFC xFA,F
19AC:  INCF   xEF,F
19AE:  BRA    1982
....................  
....................         max_esik_ort_deger = (unsigned int16) (_maxtop / _max_index); 
19B0:  BCF    FD8.1
19B2:  MOVFF  2F6,300
19B6:  MOVFF  2F5,2FF
19BA:  MOVFF  2F4,2FE
19BE:  MOVFF  2F3,2FD
19C2:  MOVLB  3
19C4:  CLRF   x04
19C6:  CLRF   x03
19C8:  CLRF   x02
19CA:  MOVFF  2F0,301
19CE:  MOVLB  0
19D0:  RCALL  166A
19D2:  MOVFF  01,2DC
19D6:  MOVFF  00,2DB
....................         min_esik_ort_deger = (unsigned int16) (_mintop / _min_index); 
19DA:  BCF    FD8.1
19DC:  MOVFF  2FA,300
19E0:  MOVFF  2F9,2FF
19E4:  MOVFF  2F8,2FE
19E8:  MOVFF  2F7,2FD
19EC:  MOVLB  3
19EE:  CLRF   x04
19F0:  CLRF   x03
19F2:  CLRF   x02
19F4:  MOVFF  2F1,301
19F8:  MOVLB  0
19FA:  RCALL  166A
19FC:  MOVFF  01,2DE
1A00:  MOVFF  00,2DD
....................         k_means_esik_ort_deger = (unsigned int16) ((max_esik_ort_deger + min_esik_ort_deger) / 2); 
1A04:  MOVLB  2
1A06:  MOVF   xDD,W
1A08:  ADDWF  xDB,W
1A0A:  MOVWF  xFD
1A0C:  MOVF   xDE,W
1A0E:  ADDWFC xDC,W
1A10:  MOVWF  xFE
1A12:  BCF    FD8.0
1A14:  RRCF   xFE,W
1A16:  MOVWF  xE0
1A18:  RRCF   xFD,W
1A1A:  MOVWF  xDF
....................  
....................         // fprintf(usbSerial,"indexMm:%Lu,%Lu \t %u,%u\r\n",_maxtop,_mintop,_max_index,_min_index); 
....................  
....................         _max_index = _min_index = 0; 
1A1C:  CLRF   xF1
1A1E:  MOVFF  2F1,2F0
....................         _maxtop = _mintop = 0; 
1A22:  CLRF   xFA
1A24:  CLRF   xF9
1A26:  CLRF   xF8
1A28:  CLRF   xF7
1A2A:  MOVFF  2FA,2F6
1A2E:  MOVFF  2F9,2F5
1A32:  MOVFF  2F8,2F4
1A36:  MOVFF  2F7,2F3
....................  
....................         // memset(max_esik_veri_havuzu,0,SENS_SAYISI*10); 
....................         // memset(min_esik_veri_havuzu,0,SENS_SAYISI*10); 
....................  
....................         yineleme++; 
1A3A:  INCF   xF2,F
....................  
....................         //        fprintf(usbSerial,"K Means: max:%lu\tmin:%lu\tesik=%lu\tyineleme=%u\r\n", 
....................         //                                    max_esik_ort_deger,min_esik_ort_deger,k_means_esik_ort_deger,yineleme); 
....................  
....................         if ((k_means_esik_ort_deger == son_deger) || yineleme > 10) { 
1A3C:  MOVF   xFB,W
1A3E:  SUBWF  xDF,W
1A40:  BNZ   1A48
1A42:  MOVF   xFC,W
1A44:  SUBWF  xE0,W
1A46:  BZ    1A4E
1A48:  MOVF   xF2,W
1A4A:  SUBLW  0A
1A4C:  BC    1A56
....................             k_means_yeni_veri = TRUE; 
1A4E:  MOVLB  0
1A50:  BSF    xF5.4
....................             break; 
1A52:  BRA    1A64
1A54:  MOVLB  2
....................         } 
....................  
....................         son_deger = k_means_esik_ort_deger; 
1A56:  MOVFF  2E0,2FC
1A5A:  MOVFF  2DF,2FB
....................  
....................     } while (!k_means_yeni_veri); 
1A5E:  MOVLB  0
1A60:  BTFSS  xF5.4
1A62:  BRA    1754
....................  
.................... //        fprintf(usbSerial,"K Means: max:%lu\tmin:%lu\tesik=%lu\tyineleme=%u\r\n", 
.................... //                        max_esik_ort_deger,min_esik_ort_deger,k_means_esik_ort_deger,yineleme); 
....................  
....................     // k_means_sens_sayisal(); 
....................  
....................  
....................     //    disable_interrupts(INT_TIMER0); 
....................     //    do { 
....................     // 
....................     //        for (x = 0; x < SENS_SAYISI; x++) { 
....................     //            fprintf(usbSerial, "%lu,", ir_sens_ort_deger[x]); 
....................     //        } 
....................     // 
....................     //        fprintf(usbSerial, "%lu,%lu,\r", max_esik_ort_deger, min_esik_ort_deger); 
....................     //        delay_ms(100);  //100 ugun deger oldu 
....................     // 
....................     //    } while (!rx_pos); 
....................     //    //seri_pos_led(seri_pos); 
....................     //    rx_pos=0; 
....................     //    enable_interrupts(INT_TIMER0); 
....................  
....................     // Fuzzy degerlendirme  
....................  
....................  //   disable_interrupts(INT_TIMER0); 
.................... //     
.................... //    dizi_setle_coef1(fis_gMFI0Coeff1, min_esik_ort_deger, max_esik_ort_deger); 
.................... //    dizi_setle_coef2(fis_gMFI0Coeff2, min_esik_ort_deger, max_esik_ort_deger); 
.................... // 
.................... // 
.................... //    for (x = 0; x < SENS_SAYISI; x++) { 
.................... // 
.................... //        g_fisOutput[0] = 0.0; 
.................... //        g_fisInput[0] = ir_sens_ort_deger[x]; 
.................... // 
.................... //        fis_evaluate(); 
.................... // 
.................... //        ir_sens_fuzzy_deger[x] = g_fisOutput[0]; 
.................... //        //fprintf(usbSerial, "%f|", ir_sens_fuzzy_deger[x]); 
.................... //    } 
....................     // fprintf(usbSerial, "\r\n"); 
....................  
....................     // fuzzy_pos_led(ir_sens_fuzzy_deger); 
....................  
....................  //   enable_interrupts(INT_TIMER0); 
....................     return yineleme; 
1A64:  MOVLB  2
1A66:  MOVFF  2F2,01
1A6A:  MOVLB  0
1A6C:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... ///önceki fonksiyonlar 
.................... //void k_means_veri_havuzu_olustur() { 
.................... //    int i = 0; 
.................... // 
.................... //    k_means_veri_say++; 
.................... // 
.................... //    if (k_means_veri_say <= 10 && !k_means_yeni_veri) { 
.................... // 
.................... //        for (i = 0; i < SENS_SAYISI; i++) { 
.................... // 
.................... //            if (ir_sens_ort_deger_e_on[i] == ir_sens_ort_deger_e_off[i]) //Aþýrý ýþýk, Von=Voff 
.................... //            { 
.................... // 
.................... //                ir_sens_ort_deger[i] = ir_sens_ort_deger_e_on[i]; 
.................... //                k_means_veri_havuzu[k_means_veri_havuzu_index++] = ir_sens_ort_deger_e_on[i]; 
.................... //                ir_sens_isik_durumu[i] = ASIRI_ISIK; 
.................... // 
.................... //            } else if (ir_sens_ort_deger_e_on[i] > ir_sens_ort_deger_e_off[i] + 100) //normal ýþýk, Von>voff 
.................... //            { 
.................... //                ir_sens_ort_deger[i] = ir_sens_ort_deger_e_on[i] - ir_sens_ort_deger_e_off[i]; 
.................... //                k_means_veri_havuzu[k_means_veri_havuzu_index++] = ir_sens_ort_deger[i]; 
.................... //                ir_sens_isik_durumu[i] = NORMAL_ISIK; 
.................... //            } 
.................... // 
.................... //            if (k_means_veri_havuzu_index >= (SENS_SAYISI * 10)) break; 
.................... //        } 
.................... //    } 
.................... // 
.................... //    if (k_means_veri_say >= 10 || (k_means_veri_havuzu_index >= (SENS_SAYISI * 10))) { 
.................... //        k_means_veri_havuzu_index = k_means_veri_say = 0; 
.................... //        k_means_yeni_veri = TRUE; 
.................... //    } 
.................... // 
.................... // 
.................... //} 
.................... // 
....................  
.................... #include "rf_islemler.c" 
....................  
.................... #include "tanimlamalar.h" 
.................... /*  
....................  * File:   tanimlamalar.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 31 Temmuz 2019 Çarþamba, 09:02 
....................  */ 
....................  
.................... #ifndef TANIMLAMALAR_H 
.................... #define	TANIMLAMALAR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................  
....................     #define buzzerPIN PIN_C0 
....................  
....................     #define FAN_PIN PIN_C4 
....................     #define ACIL_DUR_SENS_PIN PIN_B3    //PIN_A7  LED1 
....................     #define LED2_PIN PIN_A6 
....................     #define IR_LED_ANOT_PIN PIN_C3 
....................  
....................     #define fan_on() output_high(FAN_PIN); 
....................     #define fan_off() output_low(FAN_PIN);  
....................  
....................     #define led1_on() output_high(LED1_PIN); 
....................     #define led1_off() output_low(LED1_PIN); 
....................  
....................     #define led2_on() output_high(LED2_PIN); 
....................     #define led2_off() output_low(LED2_PIN); 
....................      
....................     #define ir_led_on() output_low(IR_LED_ANOT_PIN); 
....................     #define ir_led_off() output_high(IR_LED_ANOT_PIN); 
....................  
....................     #define buzzer_off()  output_low(buzzerPIN) 
....................     #define bip_yazildi() bipp(10,20,buzzerPIN) //sure,sayi,pin 
....................     #define bip_rf_var() bipp(50,2,buzzerPIN)  //sure,sayi,pin    
....................     #define bip_kurulum() bipp(25,2,buzzerPIN)  //sure,sayi,pin 
....................     #define bip_hata() bipp(3,100,buzzerPIN) 
....................     #define bip_tus() bipp(5,2,buzzerPIN)  //sure,sayi,pin 
....................  
....................     #define lfr_led_goster(sens)  hc595_spi_yaz(sens,8); 
....................  
....................     #define pwmMaxDeger 700 //200     //5Khz sinyal 
....................      
....................     #define ORT_HIZ_MIN 100 // soft kalkýþ için deðerler... 
....................     #define ORT_HIZ_MAX 600    //350  
....................  
....................     #define solMotor_hiz(v) set_pwm2_duty(v); 
....................     #define sagMotor_hiz(v) set_pwm1_duty(v); 
....................     #define solMotorDur()  set_pwm2_duty(0);  
....................     #define sagMotorDur()  set_pwm1_duty(0);  
....................  
....................     #define trenDur() solMotorDur();sagMotorDur() 
....................     #define ileri_git(v_sol,v_sag) solMotor_hiz(v_sol);sagMotor_hiz(v_sag) 
....................     #define sola_don(hiz, sure) solMotor_hiz((int16)(hiz/10));sagMotor_hiz(hiz);delay_ms(sure) 
....................     #define saga_don(hiz,sure) solMotor_hiz(hiz);sagMotor_hiz((int16)(hiz/10));delay_ms(sure) 
....................  
....................     #define AN_CHANNEL_AKU 8 
....................     #define ORNEK_SAYISI 8 
....................     #define SENS_SAYISI 8 
....................  
....................     #define HAM_DEGER 0 
....................     #define ORT_DEGER 1 
....................     #define MAX_DEGER 2 
....................     #define MIN_DEGER 3 
....................  
....................     #define MAX_HATA_DEGERI 1750 
....................  
....................     #define GERILIM_VAR 1 
....................     #define GERILIM_YOK 0 
....................  
....................     #define EMITTER_ON 1 
....................     #define EMITTER_OFF 0 
....................      
....................     #define BEYAZ 0x00 
....................     #define SIYAH 0x01 
....................  
....................     #define ASIRI_ISIK  'A' 
....................     #define NORMAL_ISIK 'N' 
....................     #define DUSUK_ISIK 'D' 
....................     #define KARANLIK_ISIK 'K' 
....................      
....................     #define ORTALAMA_DEGER 'O' 
....................     #define DIGITAL_DEGER   'B' 
....................  
....................     #define HATA_REF    1750 
....................  
....................     #define ee_adr_jtn 0x10 
....................     #define ee_adr_ortHiz_H 0x00  //high   //16 bitlik sayý 
....................     #define ee_adr_ortHiz_L 0x01  //low 
....................     #define ee_adr_df_ses   0x02 
....................  
....................     #define mp3_stop_100mS() mp3_stop();delay_ms(100) 
....................  
....................     //433MHz alýcý baðlantý pinleri 
....................     #define tus1 PIN_D0 
....................     #define tus2 PIN_D1 
....................     #define tus3 PIN_D2 
....................     #define tus4 PIN_D3 
....................     #define tus5 PIN_D4 
....................     #define tus6 PIN_D5 
....................     #define tus_vt  PIN_B0 
....................  
....................     #define ses_miniko          1 
....................     #define ses_demo            2 
....................     #define ses_getReady        3 
....................     #define ses_remix           4 
....................     #define ses_trenDuduk       5 
....................     #define ses_sureAyar        6 
....................     #define ses_kumandaKontrol  7 
....................     #define ses_cizgiTakip      8 
....................     #define TREN_DUDUK          5 
....................     #define OYUN_SON_JENERIK    2 
....................  
....................     #define SES_AKU_SARJ_50     26 
....................     #define SES_AKU_SARJ_25     27 
....................     #define SES_AKU_SARJ_DUSUK  28 
....................     #define SES_AKU_SARJ_TAK    29 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TANIMLAMALAR_H */ 
....................  
....................  
....................  
.................... int tusBasSay = 0; 
.................... int tusBasAyarSay = 0; 
.................... int jetonSureSesSay = 9; 
.................... unsigned int8 jetonSuresiSay = 20; 
.................... int sensIptalSay = 0; 
.................... long long time_sure_son_say=0; 
....................  
....................  
.................... void JtnSureAyarSeslendir(unsigned int ses) { 
....................     mp3_stop_100mS(); 
*
0C3A:  RCALL  0906
0C3C:  MOVLW  64
0C3E:  MOVLB  3
0C40:  MOVWF  x0A
0C42:  MOVLB  0
0C44:  RCALL  04F8
....................     mp3_play(ses); 
0C46:  MOVLB  2
0C48:  CLRF   xF5
0C4A:  MOVFF  2EF,2F4
0C4E:  MOVLB  0
0C50:  RCALL  0916
....................     delay_ms(1000); 
0C52:  MOVLW  04
0C54:  MOVLB  2
0C56:  MOVWF  xF0
0C58:  MOVLW  FA
0C5A:  MOVLB  3
0C5C:  MOVWF  x0A
0C5E:  MOVLB  0
0C60:  RCALL  04F8
0C62:  MOVLB  2
0C64:  DECFSZ xF0,F
0C66:  BRA    0C58
0C68:  MOVLB  0
0C6A:  RETURN 0
....................  
.................... } 
....................  
.................... void rf_islemler() { 
....................  
....................     if (input(tus1)) // Kumanda: Çalýþmayý baþlatýr, hýzý arttýrýr.  
0C6C:  BTFSS  F83.0
0C6E:  BRA    0E88
....................                      // Çizgi:Çalýþmayý baþlatýr. 
....................     { 
....................         time_aku_sarj_seslendir=millis(); 
0C70:  MOVFF  1D,41
0C74:  MOVFF  1C,40
0C78:  MOVFF  1B,3F
0C7C:  MOVFF  1A,3E
....................         output_toggle(LED2_PIN); 
0C80:  BCF    F92.6
0C82:  BTG    F89.6
....................         bip_rf_var(); 
0C84:  MOVLB  2
0C86:  CLRF   xF5
0C88:  MOVLW  32
0C8A:  MOVWF  xF4
0C8C:  MOVLW  02
0C8E:  MOVWF  xF6
0C90:  MOVLW  7C
0C92:  MOVWF  xF8
0C94:  MOVLW  10
0C96:  MOVWF  xF7
0C98:  MOVLB  0
0C9A:  RCALL  0522
....................         tusBasSay = 0; 
0C9C:  MOVLB  2
0C9E:  CLRF   xE5
....................         sensIptalSay = 0; 
0CA0:  CLRF   xE9
....................         mp3_stop_100mS(); 
0CA2:  MOVLB  0
0CA4:  RCALL  0906
0CA6:  MOVLW  64
0CA8:  MOVLB  3
0CAA:  MOVWF  x0A
0CAC:  MOVLB  0
0CAE:  RCALL  04F8
....................         if (rfKontrol) { 
0CB0:  BTFSS  xF5.0
0CB2:  BRA    0DD6
....................             fan_on(); 
0CB4:  BCF    F94.4
0CB6:  BSF    F8B.4
....................             do { 
....................                 solMhiz += 50; 
0CB8:  MOVLW  32
0CBA:  ADDWF  45,F
0CBC:  MOVLW  00
0CBE:  ADDWFC 46,F
....................                 sagMhiz += 50; 
0CC0:  MOVLW  32
0CC2:  ADDWF  47,F
0CC4:  MOVLW  00
0CC6:  ADDWFC 48,F
....................                 if (solMhiz >= pwmMaxDeger)solMhiz = pwmMaxDeger; 
0CC8:  BTFSC  46.7
0CCA:  BRA    0CE4
0CCC:  MOVF   46,W
0CCE:  SUBLW  01
0CD0:  BC    0CE4
0CD2:  XORLW  FF
0CD4:  BNZ   0CDC
0CD6:  MOVF   45,W
0CD8:  SUBLW  BB
0CDA:  BC    0CE4
0CDC:  MOVLW  02
0CDE:  MOVWF  46
0CE0:  MOVLW  BC
0CE2:  MOVWF  45
....................                 if (sagMhiz >= pwmMaxDeger)sagMhiz = pwmMaxDeger; 
0CE4:  BTFSC  48.7
0CE6:  BRA    0D00
0CE8:  MOVF   48,W
0CEA:  SUBLW  01
0CEC:  BC    0D00
0CEE:  XORLW  FF
0CF0:  BNZ   0CF8
0CF2:  MOVF   47,W
0CF4:  SUBLW  BB
0CF6:  BC    0D00
0CF8:  MOVLW  02
0CFA:  MOVWF  48
0CFC:  MOVLW  BC
0CFE:  MOVWF  47
....................                 ileri_git(solMhiz, sagMhiz); 
0D00:  MOVFF  46,02
0D04:  MOVFF  45,01
0D08:  RRCF   02,F
0D0A:  RRCF   01,F
0D0C:  RRCF   02,F
0D0E:  RRCF   01,F
0D10:  RRCF   02,F
0D12:  MOVFF  01,F67
0D16:  RRCF   02,F
0D18:  RRCF   02,W
0D1A:  ANDLW  30
0D1C:  MOVWF  00
0D1E:  MOVF   F66,W
0D20:  ANDLW  CF
0D22:  IORWF  00,W
0D24:  MOVWF  F66
0D26:  MOVFF  48,02
0D2A:  MOVFF  47,01
0D2E:  RRCF   02,F
0D30:  RRCF   01,F
0D32:  RRCF   02,F
0D34:  RRCF   01,F
0D36:  RRCF   02,F
0D38:  MOVFF  01,FBE
0D3C:  RRCF   02,F
0D3E:  RRCF   02,W
0D40:  ANDLW  30
0D42:  MOVWF  00
0D44:  MOVF   FBD,W
0D46:  ANDLW  CF
0D48:  IORWF  00,W
0D4A:  MOVWF  FBD
....................                if(solMhiz<700) bip_rf_var(); 
0D4C:  BTFSC  46.7
0D4E:  BRA    0D5E
0D50:  MOVF   46,W
0D52:  SUBLW  02
0D54:  BNC   0D78
0D56:  BNZ   0D5E
0D58:  MOVF   45,W
0D5A:  SUBLW  BB
0D5C:  BNC   0D78
0D5E:  MOVLB  2
0D60:  CLRF   xF5
0D62:  MOVLW  32
0D64:  MOVWF  xF4
0D66:  MOVLW  02
0D68:  MOVWF  xF6
0D6A:  MOVLW  7C
0D6C:  MOVWF  xF8
0D6E:  MOVLW  10
0D70:  MOVWF  xF7
0D72:  MOVLB  0
0D74:  CALL   0522
....................                 delay_ms(250); 
0D78:  MOVLW  FA
0D7A:  MOVLB  3
0D7C:  MOVWF  x0A
0D7E:  MOVLB  0
0D80:  CALL   04F8
....................             } while (input(tus1)); 
0D84:  BTFSC  F83.0
0D86:  BRA    0CB8
....................  
....................              
....................              
....................             ileri_git(solMhiz, sagMhiz); 
0D88:  MOVFF  46,02
0D8C:  MOVFF  45,01
0D90:  RRCF   02,F
0D92:  RRCF   01,F
0D94:  RRCF   02,F
0D96:  RRCF   01,F
0D98:  RRCF   02,F
0D9A:  MOVFF  01,F67
0D9E:  RRCF   02,F
0DA0:  RRCF   02,W
0DA2:  ANDLW  30
0DA4:  MOVWF  00
0DA6:  MOVF   F66,W
0DA8:  ANDLW  CF
0DAA:  IORWF  00,W
0DAC:  MOVWF  F66
0DAE:  MOVFF  48,02
0DB2:  MOVFF  47,01
0DB6:  RRCF   02,F
0DB8:  RRCF   01,F
0DBA:  RRCF   02,F
0DBC:  RRCF   01,F
0DBE:  RRCF   02,F
0DC0:  MOVFF  01,FBE
0DC4:  RRCF   02,F
0DC6:  RRCF   02,W
0DC8:  ANDLW  30
0DCA:  MOVWF  00
0DCC:  MOVF   FBD,W
0DCE:  ANDLW  CF
0DD0:  IORWF  00,W
0DD2:  MOVWF  FBD
....................         } else { 
0DD4:  BRA    0E88
....................             //cizgi takip iþlemi baþlat 
....................             if (cizgiKontrol) { 
0DD6:  BTFSS  xF5.1
0DD8:  BRA    0E88
....................                 mp3_stop_100mS(); 
0DDA:  RCALL  0906
0DDC:  MOVLW  64
0DDE:  MOVLB  3
0DE0:  MOVWF  x0A
0DE2:  MOVLB  0
0DE4:  CALL   04F8
....................                 k_means_baslangic_esik_olustur(); 
0DE8:  RCALL  0812
....................                 mp3_set_volume (df_player_ses); 
0DEA:  MOVFF  24,2F3
0DEE:  RCALL  06CA
....................                 delay_ms(500); 
0DF0:  MOVLW  02
0DF2:  MOVLB  2
0DF4:  MOVWF  xEF
0DF6:  MOVLW  FA
0DF8:  MOVLB  3
0DFA:  MOVWF  x0A
0DFC:  MOVLB  0
0DFE:  CALL   04F8
0E02:  MOVLB  2
0E04:  DECFSZ xEF,F
0E06:  BRA    0DF6
....................                 mp3_play(ses_getReady); 
0E08:  CLRF   xF5
0E0A:  MOVLW  03
0E0C:  MOVWF  xF4
0E0E:  MOVLB  0
0E10:  RCALL  0916
....................                 delay_ms(3000); 
0E12:  MOVLW  0C
0E14:  MOVLB  2
0E16:  MOVWF  xEF
0E18:  MOVLW  FA
0E1A:  MOVLB  3
0E1C:  MOVWF  x0A
0E1E:  MOVLB  0
0E20:  CALL   04F8
0E24:  MOVLB  2
0E26:  DECFSZ xEF,F
0E28:  BRA    0E18
....................                 mp3_stop_100mS(); 
0E2A:  MOVLB  0
0E2C:  RCALL  0906
0E2E:  MOVLW  64
0E30:  MOVLB  3
0E32:  MOVWF  x0A
0E34:  MOVLB  0
0E36:  CALL   04F8
....................                 mp3_play(ses_miniko); 
0E3A:  MOVLB  2
0E3C:  CLRF   xF5
0E3E:  MOVLW  01
0E40:  MOVWF  xF4
0E42:  MOVLB  0
0E44:  RCALL  0916
....................                 delay_ms(1000); 
0E46:  MOVLW  04
0E48:  MOVLB  2
0E4A:  MOVWF  xEF
0E4C:  MOVLW  FA
0E4E:  MOVLB  3
0E50:  MOVWF  x0A
0E52:  MOVLB  0
0E54:  CALL   04F8
0E58:  MOVLB  2
0E5A:  DECFSZ xEF,F
0E5C:  BRA    0E4C
....................                  
....................                 ortHiz=ORT_HIZ_MIN;  
0E5E:  CLRF   4A
0E60:  MOVLW  64
0E62:  MOVWF  49
....................                 soft_kalkis=FALSE; 
0E64:  BCF    4D.0
....................                  
....................                 set_millis(0); 
0E66:  CLRF   1D
0E68:  CLRF   1C
0E6A:  CLRF   1B
0E6C:  CLRF   1A
....................                 fan_on(); 
0E6E:  BCF    F94.4
0E70:  BSF    F8B.4
....................                 oyunBitti=FALSE; 
0E72:  MOVLB  0
0E74:  BCF    xF5.3
....................                 cizgiKontrolBaslat = TRUE;  // oyun baþlat  
0E76:  BSF    xF5.2
....................                 oyunSuresiSay = millis();   // oyun suresini resetle. 
0E78:  MOVFF  1D,58
0E7C:  MOVFF  1C,57
0E80:  MOVFF  1B,56
0E84:  MOVFF  1A,55
....................             } 
....................         } 
....................     } 
....................     if (input(tus2))        //  Kumanda : Hýzý azaltýr. Çalýþma süresi ayarlama iþleminde süreyi arttýrýr. 
0E88:  BTFSS  F83.1
0E8A:  BRA    101A
....................                             //  Uzun süre basýlýnca mp3 player sesi ayarlar 
....................     { 
....................         time_aku_sarj_seslendir=millis(); 
0E8C:  MOVFF  1D,41
0E90:  MOVFF  1C,40
0E94:  MOVFF  1B,3F
0E98:  MOVFF  1A,3E
....................         bip_rf_var(); 
0E9C:  MOVLB  2
0E9E:  CLRF   xF5
0EA0:  MOVLW  32
0EA2:  MOVWF  xF4
0EA4:  MOVLW  02
0EA6:  MOVWF  xF6
0EA8:  MOVLW  7C
0EAA:  MOVWF  xF8
0EAC:  MOVLW  10
0EAE:  MOVWF  xF7
0EB0:  MOVLB  0
0EB2:  CALL   0522
....................         mp3_stop_100mS(); 
0EB6:  RCALL  0906
0EB8:  MOVLW  64
0EBA:  MOVLB  3
0EBC:  MOVWF  x0A
0EBE:  MOVLB  0
0EC0:  CALL   04F8
....................         tusBasAyarSay++; 
0EC4:  MOVLB  2
0EC6:  INCF   xE6,F
....................          
....................         if (tusBasAyarSay > 5 && rfKontrol) { 
0EC8:  MOVF   xE6,W
0ECA:  SUBLW  05
0ECC:  BC    0F7A
0ECE:  MOVLB  0
0ED0:  BTFSC  xF5.0
0ED2:  BRA    0ED8
0ED4:  MOVLB  2
0ED6:  BRA    0F7A
....................             tusBasAyarSay=0; 
0ED8:  MOVLB  2
0EDA:  CLRF   xE6
....................              
....................             mp3_rastgele(); 
0EDC:  MOVLB  0
0EDE:  RCALL  0A86
....................              
....................             do{ 
....................                   if (input(tus2)){ 
0EE0:  BTFSS  F83.1
0EE2:  BRA    0F2C
....................                       delay_ms(250); 
0EE4:  MOVLW  FA
0EE6:  MOVLB  3
0EE8:  MOVWF  x0A
0EEA:  MOVLB  0
0EEC:  CALL   04F8
....................                       df_player_ses+=3; 
0EF0:  MOVLW  03
0EF2:  ADDWF  24,F
....................                       if(df_player_ses>27) df_player_ses=3; 
0EF4:  MOVF   24,W
0EF6:  SUBLW  1B
0EF8:  BC    0EFE
0EFA:  MOVLW  03
0EFC:  MOVWF  24
....................                       mp3_set_volume(df_player_ses); 
0EFE:  MOVFF  24,2F3
0F02:  CALL   06CA
....................                       bip_rf_var(); 
0F06:  MOVLB  2
0F08:  CLRF   xF5
0F0A:  MOVLW  32
0F0C:  MOVWF  xF4
0F0E:  MOVLW  02
0F10:  MOVWF  xF6
0F12:  MOVLW  7C
0F14:  MOVWF  xF8
0F16:  MOVLW  10
0F18:  MOVWF  xF7
0F1A:  MOVLB  0
0F1C:  CALL   0522
....................                       delay_ms(100); 
0F20:  MOVLW  64
0F22:  MOVLB  3
0F24:  MOVWF  x0A
0F26:  MOVLB  0
0F28:  CALL   04F8
....................                   } 
....................                    
....................                   if (input(tus6)){ 
0F2C:  BTFSS  F83.5
0F2E:  BRA    0F76
....................                     write_eeprom(ee_adr_df_ses, df_player_ses); 
0F30:  MOVF   FF2,W
0F32:  MOVWF  00
0F34:  BCF    FF2.7
0F36:  MOVLW  02
0F38:  MOVWF  FA9
0F3A:  MOVFF  24,FA8
0F3E:  BCF    FA6.6
0F40:  BCF    FA6.7
0F42:  BSF    FA6.2
0F44:  MOVLB  F
0F46:  MOVLW  55
0F48:  MOVWF  FA7
0F4A:  MOVLW  AA
0F4C:  MOVWF  FA7
0F4E:  BSF    FA6.1
0F50:  BTFSC  FA6.1
0F52:  BRA    0F50
0F54:  BCF    FA6.2
0F56:  MOVF   00,W
0F58:  IORWF  FF2,F
....................                     bip_yazildi(); 
0F5A:  MOVLB  2
0F5C:  CLRF   xF5
0F5E:  MOVLW  0A
0F60:  MOVWF  xF4
0F62:  MOVLW  14
0F64:  MOVWF  xF6
0F66:  MOVLW  7C
0F68:  MOVWF  xF8
0F6A:  MOVLW  10
0F6C:  MOVWF  xF7
0F6E:  MOVLB  0
0F70:  CALL   0522
....................                     
....................                     break; 
0F74:  BRA    0F78
....................                   } 
....................                  
....................             } while(1);          
0F76:  BRA    0EE0
0F78:  MOVLB  2
....................         } 
....................          
....................         if (rfKontrol) { 
0F7A:  MOVLB  0
0F7C:  BTFSS  xF5.0
0F7E:  BRA    101A
....................  
....................             solMhiz -= 50; 
0F80:  MOVLW  32
0F82:  SUBWF  45,F
0F84:  MOVLW  00
0F86:  SUBWFB 46,F
....................             sagMhiz -= 50; 
0F88:  MOVLW  32
0F8A:  SUBWF  47,F
0F8C:  MOVLW  00
0F8E:  SUBWFB 48,F
....................  
....................             if (solMhiz < 50)solMhiz = 0; 
0F90:  BTFSC  46.7
0F92:  BRA    0F9E
0F94:  MOVF   46,F
0F96:  BNZ   0FA2
0F98:  MOVF   45,W
0F9A:  SUBLW  31
0F9C:  BNC   0FA2
0F9E:  CLRF   46
0FA0:  CLRF   45
....................             if (sagMhiz < 50)sagMhiz = 0; 
0FA2:  BTFSC  48.7
0FA4:  BRA    0FB0
0FA6:  MOVF   48,F
0FA8:  BNZ   0FB4
0FAA:  MOVF   47,W
0FAC:  SUBLW  31
0FAE:  BNC   0FB4
0FB0:  CLRF   48
0FB2:  CLRF   47
....................             ileri_git(solMhiz, sagMhiz); 
0FB4:  MOVFF  46,02
0FB8:  MOVFF  45,01
0FBC:  RRCF   02,F
0FBE:  RRCF   01,F
0FC0:  RRCF   02,F
0FC2:  RRCF   01,F
0FC4:  RRCF   02,F
0FC6:  MOVFF  01,F67
0FCA:  RRCF   02,F
0FCC:  RRCF   02,W
0FCE:  ANDLW  30
0FD0:  MOVWF  00
0FD2:  MOVF   F66,W
0FD4:  ANDLW  CF
0FD6:  IORWF  00,W
0FD8:  MOVWF  F66
0FDA:  MOVFF  48,02
0FDE:  MOVFF  47,01
0FE2:  RRCF   02,F
0FE4:  RRCF   01,F
0FE6:  RRCF   02,F
0FE8:  RRCF   01,F
0FEA:  RRCF   02,F
0FEC:  MOVFF  01,FBE
0FF0:  RRCF   02,F
0FF2:  RRCF   02,W
0FF4:  ANDLW  30
0FF6:  MOVWF  00
0FF8:  MOVF   FBD,W
0FFA:  ANDLW  CF
0FFC:  IORWF  00,W
0FFE:  MOVWF  FBD
....................             bip_rf_var(); 
1000:  MOVLB  2
1002:  CLRF   xF5
1004:  MOVLW  32
1006:  MOVWF  xF4
1008:  MOVLW  02
100A:  MOVWF  xF6
100C:  MOVLW  7C
100E:  MOVWF  xF8
1010:  MOVLW  10
1012:  MOVWF  xF7
1014:  MOVLB  0
1016:  CALL   0522
....................             //fprintf(softSerial,"solMotor:%Lu\r\n",solMhiz); 
....................         } 
....................     } 
....................  
....................     if (input(tus3))        // Kumanda :Devamlý basýlýnca sola döndürür.   
101A:  BTFSS  F83.2
101C:  BRA    1194
....................                             // Çizgi :Çizgi izleme hýzýný arttýrýr. 
....................     { 
....................         time_aku_sarj_seslendir=millis(); 
101E:  MOVFF  1D,41
1022:  MOVFF  1C,40
1026:  MOVFF  1B,3F
102A:  MOVFF  1A,3E
....................         tusBasSay = 0; 
102E:  MOVLB  2
1030:  CLRF   xE5
....................         mp3_stop_100mS(); 
1032:  MOVLB  0
1034:  RCALL  0906
1036:  MOVLW  64
1038:  MOVLB  3
103A:  MOVWF  x0A
103C:  MOVLB  0
103E:  CALL   04F8
....................         if (cizgiKontrolBaslat) 
1042:  BTFSS  xF5.2
1044:  BRA    111E
....................         { 
....................             do{ 
....................                 solMhiz = 0; 
1046:  CLRF   46
1048:  CLRF   45
....................                 sagMhiz = 0; 
104A:  CLRF   48
104C:  CLRF   47
....................                 ortHiz=0; 
104E:  CLRF   4A
1050:  CLRF   49
....................                  
....................                 trenDur(); 
1052:  CLRF   F67
1054:  CLRF   FBE
....................                  
....................                 if (input(tus3)) { 
1056:  BTFSS  F83.2
1058:  BRA    10A2
....................                     delay_ms(250); 
105A:  MOVLW  FA
105C:  MOVLB  3
105E:  MOVWF  x0A
1060:  MOVLB  0
1062:  CALL   04F8
....................                     ortHiz_max+=25; 
1066:  MOVLW  19
1068:  ADDWF  4B,F
106A:  MOVLW  00
106C:  ADDWFC 4C,F
....................                     if (ortHiz_max >= pwmMaxDeger)ortHiz_max = pwmMaxDeger; 
106E:  MOVF   4C,W
1070:  SUBLW  01
1072:  BC    1088
1074:  XORLW  FF
1076:  BNZ   107E
1078:  MOVF   4B,W
107A:  SUBLW  BB
107C:  BC    1088
107E:  MOVLW  02
1080:  MOVWF  4C
1082:  MOVLW  BC
1084:  MOVWF  4B
1086:  BRA    10A2
....................                     else  bip_rf_var(); 
1088:  MOVLB  2
108A:  CLRF   xF5
108C:  MOVLW  32
108E:  MOVWF  xF4
1090:  MOVLW  02
1092:  MOVWF  xF6
1094:  MOVLW  7C
1096:  MOVWF  xF8
1098:  MOVLW  10
109A:  MOVWF  xF7
109C:  MOVLB  0
109E:  CALL   0522
....................                 } 
....................   
....................                 if (input(tus6)){ 
10A2:  BTFSS  F83.5
10A4:  BRA    111C
....................                     write_eeprom(ee_adr_ortHiz_H, make8(ortHiz_max,1)); 
10A6:  MOVFF  4C,2EF
10AA:  MOVF   FF2,W
10AC:  MOVWF  00
10AE:  BCF    FF2.7
10B0:  CLRF   FA9
10B2:  MOVFF  2EF,FA8
10B6:  BCF    FA6.6
10B8:  BCF    FA6.7
10BA:  BSF    FA6.2
10BC:  MOVLB  F
10BE:  MOVLW  55
10C0:  MOVWF  FA7
10C2:  MOVLW  AA
10C4:  MOVWF  FA7
10C6:  BSF    FA6.1
10C8:  BTFSC  FA6.1
10CA:  BRA    10C8
10CC:  BCF    FA6.2
10CE:  MOVF   00,W
10D0:  IORWF  FF2,F
....................                     write_eeprom(ee_adr_ortHiz_L, make8(ortHiz_max,0)); 
10D2:  MOVFF  4B,2EF
10D6:  MOVFF  FF2,00
10DA:  BCF    FF2.7
10DC:  MOVLW  01
10DE:  MOVWF  FA9
10E0:  MOVFF  4B,FA8
10E4:  BCF    FA6.6
10E6:  BCF    FA6.7
10E8:  BSF    FA6.2
10EA:  MOVLW  55
10EC:  MOVWF  FA7
10EE:  MOVLW  AA
10F0:  MOVWF  FA7
10F2:  BSF    FA6.1
10F4:  BTFSC  FA6.1
10F6:  BRA    10F4
10F8:  BCF    FA6.2
10FA:  MOVF   00,W
10FC:  IORWF  FF2,F
....................                      
....................                     bip_yazildi(); 
10FE:  MOVLB  2
1100:  CLRF   xF5
1102:  MOVLW  0A
1104:  MOVWF  xF4
1106:  MOVLW  14
1108:  MOVWF  xF6
110A:  MOVLW  7C
110C:  MOVWF  xF8
110E:  MOVLW  10
1110:  MOVWF  xF7
1112:  MOVLB  0
1114:  CALL   0522
....................                      
....................                     cizgiKontrolBaslat=FALSE; 
1118:  BCF    xF5.2
....................                     break; 
111A:  BRA    111E
....................                 } 
....................                 
....................             }while(1); 
111C:  BRA    1046
....................         } 
....................          
....................         if (rfKontrol) { 
111E:  BTFSS  xF5.0
1120:  BRA    1194
....................             do { 
....................                 sola_don(solMhiz, 100); //hýz, sure 
1122:  MOVFF  46,308
1126:  MOVFF  45,307
112A:  MOVLB  3
112C:  CLRF   x0A
112E:  MOVLW  0A
1130:  MOVWF  x09
1132:  MOVLB  0
1134:  RCALL  0BC2
1136:  MOVFF  02,2F0
113A:  MOVLB  2
113C:  MOVFF  01,2EF
1140:  RRCF   xF0,F
1142:  RRCF   xEF,F
1144:  RRCF   xF0,F
1146:  RRCF   xEF,F
1148:  RRCF   xF0,F
114A:  MOVFF  2EF,F67
114E:  RRCF   xF0,F
1150:  RRCF   xF0,W
1152:  ANDLW  30
1154:  MOVWF  00
1156:  MOVF   F66,W
1158:  ANDLW  CF
115A:  IORWF  00,W
115C:  MOVWF  F66
115E:  MOVFF  46,02
1162:  MOVFF  45,01
1166:  RRCF   02,F
1168:  RRCF   01,F
116A:  RRCF   02,F
116C:  RRCF   01,F
116E:  RRCF   02,F
1170:  MOVFF  01,FBE
1174:  RRCF   02,F
1176:  RRCF   02,W
1178:  ANDLW  30
117A:  MOVWF  00
117C:  MOVF   FBD,W
117E:  ANDLW  CF
1180:  IORWF  00,W
1182:  MOVWF  FBD
1184:  MOVLW  64
1186:  MOVLB  3
1188:  MOVWF  x0A
118A:  MOVLB  0
118C:  CALL   04F8
....................             } while (input(tus3)); 
1190:  BTFSC  F83.2
1192:  BRA    1122
....................         } 
....................     } 
....................     if (input(tus4))    // Kumanda : Devamlý basýlýnca saða döndürür. Çalýþma süresi ayarlama iþleminde süreyi azaltýr. 
1194:  BTFSS  F83.3
1196:  BRA    1308
....................                         // Çizgi : Çizgi izleme hýzýný azaltýr. 
....................     { 
....................         time_aku_sarj_seslendir=millis(); 
1198:  MOVFF  1D,41
119C:  MOVFF  1C,40
11A0:  MOVFF  1B,3F
11A4:  MOVFF  1A,3E
....................         tusBasSay = 0; 
11A8:  MOVLB  2
11AA:  CLRF   xE5
....................         mp3_stop_100mS(); 
11AC:  MOVLB  0
11AE:  CALL   0906
11B2:  MOVLW  64
11B4:  MOVLB  3
11B6:  MOVWF  x0A
11B8:  MOVLB  0
11BA:  CALL   04F8
....................  
....................         if (cizgiKontrolBaslat)  
11BE:  BTFSS  xF5.2
11C0:  BRA    1292
....................         { 
....................             do{ 
....................                 solMhiz = 0; 
11C2:  CLRF   46
11C4:  CLRF   45
....................                 sagMhiz = 0; 
11C6:  CLRF   48
11C8:  CLRF   47
....................                 ortHiz=0; 
11CA:  CLRF   4A
11CC:  CLRF   49
....................                  
....................                 trenDur(); 
11CE:  CLRF   F67
11D0:  CLRF   FBE
....................                  
....................                 if (input(tus4)) { 
11D2:  BTFSS  F83.3
11D4:  BRA    1216
....................                     delay_ms(250); 
11D6:  MOVLW  FA
11D8:  MOVLB  3
11DA:  MOVWF  x0A
11DC:  MOVLB  0
11DE:  CALL   04F8
....................                     ortHiz_max-=25;  
11E2:  MOVLW  19
11E4:  SUBWF  4B,F
11E6:  MOVLW  00
11E8:  SUBWFB 4C,F
....................                     if (ortHiz_max <= 200)ortHiz_max = 200; 
11EA:  MOVF   4C,F
11EC:  BNZ   11FC
11EE:  MOVF   4B,W
11F0:  SUBLW  C8
11F2:  BNC   11FC
11F4:  CLRF   4C
11F6:  MOVLW  C8
11F8:  MOVWF  4B
11FA:  BRA    1216
....................                     else  bip_rf_var(); 
11FC:  MOVLB  2
11FE:  CLRF   xF5
1200:  MOVLW  32
1202:  MOVWF  xF4
1204:  MOVLW  02
1206:  MOVWF  xF6
1208:  MOVLW  7C
120A:  MOVWF  xF8
120C:  MOVLW  10
120E:  MOVWF  xF7
1210:  MOVLB  0
1212:  CALL   0522
....................                 } 
....................                 if (input(tus6)){ 
1216:  BTFSS  F83.5
1218:  BRA    1290
....................                     write_eeprom(ee_adr_ortHiz_H, make8(ortHiz_max,1)); 
121A:  MOVFF  4C,2EF
121E:  MOVF   FF2,W
1220:  MOVWF  00
1222:  BCF    FF2.7
1224:  CLRF   FA9
1226:  MOVFF  2EF,FA8
122A:  BCF    FA6.6
122C:  BCF    FA6.7
122E:  BSF    FA6.2
1230:  MOVLB  F
1232:  MOVLW  55
1234:  MOVWF  FA7
1236:  MOVLW  AA
1238:  MOVWF  FA7
123A:  BSF    FA6.1
123C:  BTFSC  FA6.1
123E:  BRA    123C
1240:  BCF    FA6.2
1242:  MOVF   00,W
1244:  IORWF  FF2,F
....................                     write_eeprom(ee_adr_ortHiz_L, make8(ortHiz_max,0)); 
1246:  MOVFF  4B,2EF
124A:  MOVFF  FF2,00
124E:  BCF    FF2.7
1250:  MOVLW  01
1252:  MOVWF  FA9
1254:  MOVFF  4B,FA8
1258:  BCF    FA6.6
125A:  BCF    FA6.7
125C:  BSF    FA6.2
125E:  MOVLW  55
1260:  MOVWF  FA7
1262:  MOVLW  AA
1264:  MOVWF  FA7
1266:  BSF    FA6.1
1268:  BTFSC  FA6.1
126A:  BRA    1268
126C:  BCF    FA6.2
126E:  MOVF   00,W
1270:  IORWF  FF2,F
....................                      
....................                     bip_yazildi(); 
1272:  MOVLB  2
1274:  CLRF   xF5
1276:  MOVLW  0A
1278:  MOVWF  xF4
127A:  MOVLW  14
127C:  MOVWF  xF6
127E:  MOVLW  7C
1280:  MOVWF  xF8
1282:  MOVLW  10
1284:  MOVWF  xF7
1286:  MOVLB  0
1288:  CALL   0522
....................                      
....................                     cizgiKontrolBaslat=FALSE; 
128C:  BCF    xF5.2
....................                     break; 
128E:  BRA    1292
....................                 } 
....................                 
....................             }while(1); 
1290:  BRA    11C2
....................              
....................         } 
....................          
....................         if (rfKontrol) { 
1292:  BTFSS  xF5.0
1294:  BRA    1308
....................             do { 
....................                 saga_don(SagMhiz, 100); //hýz, sure 
1296:  MOVFF  48,02
129A:  MOVFF  47,01
129E:  RRCF   02,F
12A0:  RRCF   01,F
12A2:  RRCF   02,F
12A4:  RRCF   01,F
12A6:  RRCF   02,F
12A8:  MOVFF  01,F67
12AC:  RRCF   02,F
12AE:  RRCF   02,W
12B0:  ANDLW  30
12B2:  MOVWF  00
12B4:  MOVF   F66,W
12B6:  ANDLW  CF
12B8:  IORWF  00,W
12BA:  MOVWF  F66
12BC:  MOVFF  48,308
12C0:  MOVFF  47,307
12C4:  MOVLB  3
12C6:  CLRF   x0A
12C8:  MOVLW  0A
12CA:  MOVWF  x09
12CC:  MOVLB  0
12CE:  RCALL  0BC2
12D0:  MOVFF  02,2F0
12D4:  MOVLB  2
12D6:  MOVFF  01,2EF
12DA:  RRCF   xF0,F
12DC:  RRCF   xEF,F
12DE:  RRCF   xF0,F
12E0:  RRCF   xEF,F
12E2:  RRCF   xF0,F
12E4:  MOVFF  2EF,FBE
12E8:  RRCF   xF0,F
12EA:  RRCF   xF0,W
12EC:  ANDLW  30
12EE:  MOVWF  00
12F0:  MOVF   FBD,W
12F2:  ANDLW  CF
12F4:  IORWF  00,W
12F6:  MOVWF  FBD
12F8:  MOVLW  64
12FA:  MOVLB  3
12FC:  MOVWF  x0A
12FE:  MOVLB  0
1300:  CALL   04F8
....................             } while (input(tus4)); 
1304:  BTFSC  F83.3
1306:  BRA    1296
....................         } 
....................  
....................     } 
....................     if (input(tus5))    // Kumanda : Durdurur ve uzun süre basýlýnca çizgi izleme moduna geçirir 
1308:  BTFSS  F83.4
130A:  BRA    1472
....................                         // Çizgi : Durdurur ve uzun süre basýlýnca kumanda ile kontrol moduna geçirir. 
....................     { 
....................        time_aku_sarj_seslendir=millis(); 
130C:  MOVFF  1D,41
1310:  MOVFF  1C,40
1314:  MOVFF  1B,3F
1318:  MOVFF  1A,3E
....................         bip_rf_var(); 
131C:  MOVLB  2
131E:  CLRF   xF5
1320:  MOVLW  32
1322:  MOVWF  xF4
1324:  MOVLW  02
1326:  MOVWF  xF6
1328:  MOVLW  7C
132A:  MOVWF  xF8
132C:  MOVLW  10
132E:  MOVWF  xF7
1330:  MOVLB  0
1332:  CALL   0522
....................         if (cizgiKontrolBaslat) { 
1336:  BTFSS  xF5.2
1338:  BRA    1368
....................             if (solMHiz < sagMhiz)sagMHiz = solMhiz; 
133A:  BTFSS  46.7
133C:  BRA    1344
133E:  BTFSS  48.7
1340:  BRA    1356
1342:  BRA    1348
1344:  BTFSC  48.7
1346:  BRA    1360
1348:  MOVF   46,W
134A:  SUBWF  48,W
134C:  BNC   1360
134E:  BNZ   1356
1350:  MOVF   47,W
1352:  SUBWF  45,W
1354:  BC    1360
1356:  MOVFF  46,48
135A:  MOVFF  45,47
135E:  BRA    1368
....................             else solMHiz = sagMhiz; 
1360:  MOVFF  48,46
1364:  MOVFF  47,45
....................         } 
....................  
....................         solMhiz = 0; 
1368:  CLRF   46
136A:  CLRF   45
....................         sagMhiz = 0; 
136C:  CLRF   48
136E:  CLRF   47
....................         trenDur(); 
1370:  CLRF   F67
1372:  CLRF   FBE
....................         tusBasSay++; 
1374:  MOVLB  2
1376:  INCF   xE5,F
....................         cizgiKontrolBaslat = FALSE; 
1378:  MOVLB  0
137A:  BCF    xF5.2
....................         mp3_stop_100mS(); 
137C:  CALL   0906
1380:  MOVLW  64
1382:  MOVLB  3
1384:  MOVWF  x0A
1386:  MOVLB  0
1388:  CALL   04F8
....................         fan_off(); 
138C:  BCF    F94.4
138E:  BCF    F8B.4
....................         if (tusBasSay > 10) { 
1390:  MOVLB  2
1392:  MOVF   xE5,W
1394:  SUBLW  0A
1396:  BC    1470
....................  
....................             if ((rfKontrol)&&(!cizgiKontrol)) { 
1398:  MOVLB  0
139A:  BTFSS  xF5.0
139C:  BRA    13A8
139E:  BTFSC  xF5.1
13A0:  BRA    13A8
....................  
....................                 rfKontrol = FALSE; 
13A2:  BCF    xF5.0
....................                 cizgiKontrol = TRUE; 
13A4:  BSF    xF5.1
....................  
....................             } else if ((!rfKontrol)&&(cizgiKontrol)) { 
13A6:  BRA    13B4
13A8:  BTFSC  xF5.0
13AA:  BRA    13B4
13AC:  BTFSS  xF5.1
13AE:  BRA    13B4
....................  
....................                 rfKontrol = TRUE; 
13B0:  BSF    xF5.0
....................                 cizgiKontrol = FALSE; 
13B2:  BCF    xF5.1
....................  
....................             } 
....................             if (cizgiKontrol) { 
13B4:  BTFSS  xF5.1
13B6:  BRA    1408
....................  
....................                 mp3_stop_100mS(); 
13B8:  CALL   0906
13BC:  MOVLW  64
13BE:  MOVLB  3
13C0:  MOVWF  x0A
13C2:  MOVLB  0
13C4:  CALL   04F8
....................                 mp3_set_volume(dfPlayerNSes); 
13C8:  MOVLW  14
13CA:  MOVLB  2
13CC:  MOVWF  xF3
13CE:  MOVLB  0
13D0:  CALL   06CA
....................                 delay_ms(30); 
13D4:  MOVLW  1E
13D6:  MOVLB  3
13D8:  MOVWF  x0A
13DA:  MOVLB  0
13DC:  CALL   04F8
....................                 mp3_play(ses_cizgiTakip); 
13E0:  MOVLB  2
13E2:  CLRF   xF5
13E4:  MOVLW  08
13E6:  MOVWF  xF4
13E8:  MOVLB  0
13EA:  CALL   0916
....................                 delay_ms(1000); 
13EE:  MOVLW  04
13F0:  MOVLB  2
13F2:  MOVWF  xEF
13F4:  MOVLW  FA
13F6:  MOVLB  3
13F8:  MOVWF  x0A
13FA:  MOVLB  0
13FC:  CALL   04F8
1400:  MOVLB  2
1402:  DECFSZ xEF,F
1404:  BRA    13F4
1406:  MOVLB  0
....................                 //mp3_stop(); 
....................             } 
....................             if (rfKontrol) { 
1408:  BTFSS  xF5.0
140A:  BRA    146C
....................  
....................                 mp3_stop_100mS(); 
140C:  CALL   0906
1410:  MOVLW  64
1412:  MOVLB  3
1414:  MOVWF  x0A
1416:  MOVLB  0
1418:  CALL   04F8
....................                 mp3_set_volume(dfPlayerNSes); 
141C:  MOVLW  14
141E:  MOVLB  2
1420:  MOVWF  xF3
1422:  MOVLB  0
1424:  CALL   06CA
....................                 delay_ms(30); 
1428:  MOVLW  1E
142A:  MOVLB  3
142C:  MOVWF  x0A
142E:  MOVLB  0
1430:  CALL   04F8
....................                 mp3_play(ses_kumandaKontrol); 
1434:  MOVLB  2
1436:  CLRF   xF5
1438:  MOVLW  07
143A:  MOVWF  xF4
143C:  MOVLB  0
143E:  CALL   0916
....................                 delay_ms(3000); 
1442:  MOVLW  0C
1444:  MOVLB  2
1446:  MOVWF  xEF
1448:  MOVLW  FA
144A:  MOVLB  3
144C:  MOVWF  x0A
144E:  MOVLB  0
1450:  CALL   04F8
1454:  MOVLB  2
1456:  DECFSZ xEF,F
1458:  BRA    1448
....................                 mp3_stop(); 
145A:  MOVLB  0
145C:  CALL   0906
....................                 delay_ms(100); 
1460:  MOVLW  64
1462:  MOVLB  3
1464:  MOVWF  x0A
1466:  MOVLB  0
1468:  CALL   04F8
....................              } 
....................  
....................             tusBasSay = 0; 
146C:  MOVLB  2
146E:  CLRF   xE5
1470:  MOVLB  0
....................  
....................         } 
....................  
....................     } 
....................  
....................     if (input(tus6))    // Kumanda : Uzun süre basýlýnca çalýþma süresi ayarlama iþlemini çalýþtýrýr. 
1472:  BTFSS  F83.5
1474:  BRA    1664
....................                         // çizgi ort hiz max deðerini kaydeder 
....................     { 
....................         time_aku_sarj_seslendir=millis(); 
1476:  MOVFF  1D,41
147A:  MOVFF  1C,40
147E:  MOVFF  1B,3F
1482:  MOVFF  1A,3E
....................         bip_rf_var(); 
1486:  MOVLB  2
1488:  CLRF   xF5
148A:  MOVLW  32
148C:  MOVWF  xF4
148E:  MOVLW  02
1490:  MOVWF  xF6
1492:  MOVLW  7C
1494:  MOVWF  xF8
1496:  MOVLW  10
1498:  MOVWF  xF7
149A:  MOVLB  0
149C:  CALL   0522
....................         tusBasAyarSay++; 
14A0:  MOVLB  2
14A2:  INCF   xE6,F
....................         mp3_stop_100mS(); 
14A4:  MOVLB  0
14A6:  CALL   0906
14AA:  MOVLW  64
14AC:  MOVLB  3
14AE:  MOVWF  x0A
14B0:  MOVLB  0
14B2:  CALL   04F8
....................  
....................         if (tusBasAyarSay > 5 && rfKontrol) { 
14B6:  MOVLB  2
14B8:  MOVF   xE6,W
14BA:  SUBLW  05
14BC:  BTFSC  FD8.0
14BE:  BRA    1664
14C0:  MOVLB  0
14C2:  BTFSC  xF5.0
14C4:  BRA    14CA
14C6:  MOVLB  2
14C8:  BRA    1664
....................  
....................             tusBasAyarSay = 0; 
14CA:  MOVLB  2
14CC:  CLRF   xE6
....................             mp3_set_volume(dfPlayerNSes); 
14CE:  MOVLW  14
14D0:  MOVWF  xF3
14D2:  MOVLB  0
14D4:  CALL   06CA
....................             mp3_stop_100mS(); 
14D8:  CALL   0906
14DC:  MOVLW  64
14DE:  MOVLB  3
14E0:  MOVWF  x0A
14E2:  MOVLB  0
14E4:  CALL   04F8
....................             mp3_play(ses_sureAyar); 
14E8:  MOVLB  2
14EA:  CLRF   xF5
14EC:  MOVLW  06
14EE:  MOVWF  xF4
14F0:  MOVLB  0
14F2:  CALL   0916
....................             delay_ms(3000); 
14F6:  MOVLW  0C
14F8:  MOVLB  2
14FA:  MOVWF  xEF
14FC:  MOVLW  FA
14FE:  MOVLB  3
1500:  MOVWF  x0A
1502:  MOVLB  0
1504:  CALL   04F8
1508:  MOVLB  2
150A:  DECFSZ xEF,F
150C:  BRA    14FC
....................  
....................             do { 
....................                 if (input(tus2)) { // süre ++++ 
150E:  BTFSS  F83.1
1510:  BRA    1560
....................                     delay_ms(100); 
1512:  MOVLW  64
1514:  MOVLB  3
1516:  MOVWF  x0A
1518:  MOVLB  0
151A:  CALL   04F8
....................                     bip_rf_var(); 
151E:  MOVLB  2
1520:  CLRF   xF5
1522:  MOVLW  32
1524:  MOVWF  xF4
1526:  MOVLW  02
1528:  MOVWF  xF6
152A:  MOVLW  7C
152C:  MOVWF  xF8
152E:  MOVLW  10
1530:  MOVWF  xF7
1532:  MOVLB  0
1534:  CALL   0522
....................                     jetonSureSesSay++; 
1538:  MOVLB  2
153A:  INCF   xE7,F
....................                     jetonSuresiSay += 5; 
153C:  MOVLW  05
153E:  ADDWF  xE8,F
....................  
....................                     if (jetonSuresiSay > 100)jetonSuresiSay = 100; 
1540:  MOVF   xE8,W
1542:  SUBLW  64
1544:  BC    154A
1546:  MOVLW  64
1548:  MOVWF  xE8
....................                     if (jetonSureSesSay > 25) jetonSureSesSay = 25; 
154A:  MOVF   xE7,W
154C:  SUBLW  19
154E:  BC    1554
1550:  MOVLW  19
1552:  MOVWF  xE7
....................                     // fprintf(softSerial,"\r\n\t ses:%u  \t sure:%u \r\n",jetonSureSesSay,jetonSuresiSay);  
....................                     JtnSureAyarSeslendir(jetonSureSesSay); 
1554:  MOVFF  2E7,2EF
1558:  MOVLB  0
155A:  CALL   0C3A
155E:  MOVLB  2
....................                 } 
....................                 if (input(tus4)) { // süre --- 
1560:  BTFSS  F83.3
1562:  BRA    15B2
....................                     delay_ms(100); 
1564:  MOVLW  64
1566:  MOVLB  3
1568:  MOVWF  x0A
156A:  MOVLB  0
156C:  CALL   04F8
....................                     bip_rf_var(); 
1570:  MOVLB  2
1572:  CLRF   xF5
1574:  MOVLW  32
1576:  MOVWF  xF4
1578:  MOVLW  02
157A:  MOVWF  xF6
157C:  MOVLW  7C
157E:  MOVWF  xF8
1580:  MOVLW  10
1582:  MOVWF  xF7
1584:  MOVLB  0
1586:  CALL   0522
....................                     jetonSureSesSay--; 
158A:  MOVLB  2
158C:  DECF   xE7,F
....................                     jetonSuresiSay -= 5; 
158E:  MOVLW  05
1590:  SUBWF  xE8,F
....................                     if (jetonSuresiSay < 20)jetonSuresiSay = 20; 
1592:  MOVF   xE8,W
1594:  SUBLW  13
1596:  BNC   159C
1598:  MOVLW  14
159A:  MOVWF  xE8
....................                     if (jetonSureSesSay < 9) jetonSureSesSay = 9; 
159C:  MOVF   xE7,W
159E:  SUBLW  08
15A0:  BNC   15A6
15A2:  MOVLW  09
15A4:  MOVWF  xE7
....................                     //fprintf(softSerial,"\r\n\t ses:%u  \t sure:%u \r\n",jetonSureSesSay,jetonSuresiSay);  
....................                     JtnSureAyarSeslendir(jetonSureSesSay); 
15A6:  MOVFF  2E7,2EF
15AA:  MOVLB  0
15AC:  CALL   0C3A
15B0:  MOVLB  2
....................                 } 
....................                 if (input(tus6)) { // kaydet ve çýk 
15B2:  BTFSS  F83.5
15B4:  BRA    1662
....................                     delay_ms(100); 
15B6:  MOVLW  64
15B8:  MOVLB  3
15BA:  MOVWF  x0A
15BC:  MOVLB  0
15BE:  CALL   04F8
....................                     bip_rf_var(); 
15C2:  MOVLB  2
15C4:  CLRF   xF5
15C6:  MOVLW  32
15C8:  MOVWF  xF4
15CA:  MOVLW  02
15CC:  MOVWF  xF6
15CE:  MOVLW  7C
15D0:  MOVWF  xF8
15D2:  MOVLW  10
15D4:  MOVWF  xF7
15D6:  MOVLB  0
15D8:  CALL   0522
....................                     mp3_stop_100mS(); 
15DC:  CALL   0906
15E0:  MOVLW  64
15E2:  MOVLB  3
15E4:  MOVWF  x0A
15E6:  MOVLB  0
15E8:  CALL   04F8
....................                     write_eeprom(ee_adr_jtn, jetonSuresiSay); //Configde eeprom yazmaya karþý korumalý olmamalý... 
15EC:  MOVF   FF2,W
15EE:  MOVWF  00
15F0:  BCF    FF2.7
15F2:  MOVLW  10
15F4:  MOVWF  FA9
15F6:  MOVFF  2E8,FA8
15FA:  BCF    FA6.6
15FC:  BCF    FA6.7
15FE:  BSF    FA6.2
1600:  MOVLB  F
1602:  MOVLW  55
1604:  MOVWF  FA7
1606:  MOVLW  AA
1608:  MOVWF  FA7
160A:  BSF    FA6.1
160C:  BTFSC  FA6.1
160E:  BRA    160C
1610:  BCF    FA6.2
1612:  MOVF   00,W
1614:  IORWF  FF2,F
....................                     delay_ms(100); 
1616:  MOVLW  64
1618:  MOVLB  3
161A:  MOVWF  x0A
161C:  MOVLB  0
161E:  CALL   04F8
....................                     //jetonSuresi=_mul(jetonSuresiSay,120000LL)/10; 
....................                     //fprintf(softSerial,"eesure:%u R0x00:%u \r\n",jetonSuresiSay,read_eeprom(0x10)); 
....................                     ee_jeton_suresi_deger=jetonSuresiSay; 
1622:  MOVFF  2E8,54
....................                     mp3_stop_100mS(); 
1626:  CALL   0906
162A:  MOVLW  64
162C:  MOVLB  3
162E:  MOVWF  x0A
1630:  MOVLB  0
1632:  CALL   04F8
....................                     mp3_play(ses_getReady); 
1636:  MOVLB  2
1638:  CLRF   xF5
163A:  MOVLW  03
163C:  MOVWF  xF4
163E:  MOVLB  0
1640:  CALL   0916
....................                     bip_yazildi(); 
1644:  MOVLB  2
1646:  CLRF   xF5
1648:  MOVLW  0A
164A:  MOVWF  xF4
164C:  MOVLW  14
164E:  MOVWF  xF6
1650:  MOVLW  7C
1652:  MOVWF  xF8
1654:  MOVLW  10
1656:  MOVWF  xF7
1658:  MOVLB  0
165A:  CALL   0522
....................                     break; 
165E:  BRA    1664
1660:  MOVLB  2
....................                 } 
....................  
....................             } while (1); 
1662:  BRA    150E
1664:  MOVLB  0
....................  
....................         } 
....................  
....................     } 
1666:  GOTO   3788 (RETURN)
.................... } 
.................... int sure_son_say = 0; 
....................  
.................... void sureSon() { 
....................  
....................     if (lfr_led == 0b00011000 || kontrol == 0 || sure_son_say > 10) //tren orta noktayý bulunca duracak. 
*
28D2:  MOVF   42,W
28D4:  SUBLW  18
28D6:  BZ    28EA
28D8:  MOVF   xEF,F
28DA:  BNZ   28E0
28DC:  MOVF   xF0,F
28DE:  BZ    28EA
28E0:  MOVLB  2
28E2:  MOVF   xEE,W
28E4:  SUBLW  0A
28E6:  BC    2980
28E8:  MOVLB  0
....................     { 
....................  
....................         solMhiz = 0; 
28EA:  CLRF   46
28EC:  CLRF   45
....................         sagMhiz = 0; 
28EE:  CLRF   48
28F0:  CLRF   47
....................         trenDur(); 
28F2:  CLRF   F67
28F4:  CLRF   FBE
....................          
....................         oyunSuresiSay = millis(); 
28F6:  MOVFF  1D,58
28FA:  MOVFF  1C,57
28FE:  MOVFF  1B,56
2902:  MOVFF  1A,55
....................         cizgiKontrolBaslat = FALSE; 
2906:  BCF    xF5.2
....................  
....................         mp3_stop_100mS(); 
2908:  CALL   0906
290C:  MOVLW  64
290E:  MOVLB  3
2910:  MOVWF  x0A
2912:  MOVLB  0
2914:  CALL   04F8
....................         mp3_play(TREN_DUDUK); 
2918:  MOVLB  2
291A:  CLRF   xF5
291C:  MOVLW  05
291E:  MOVWF  xF4
2920:  MOVLB  0
2922:  CALL   0916
....................         mp3_stop_100mS(); 
2926:  CALL   0906
292A:  MOVLW  64
292C:  MOVLB  3
292E:  MOVWF  x0A
2930:  MOVLB  0
2932:  CALL   04F8
....................         mp3_play(OYUN_SON_JENERIK); 
2936:  MOVLB  2
2938:  CLRF   xF5
293A:  MOVLW  02
293C:  MOVWF  xF4
293E:  MOVLB  0
2940:  CALL   0916
....................         delay_ms(3000); 
2944:  MOVLW  0C
2946:  MOVLB  2
2948:  MOVWF  xF0
294A:  MOVLW  FA
294C:  MOVLB  3
294E:  MOVWF  x0A
2950:  MOVLB  0
2952:  CALL   04F8
2956:  MOVLB  2
2958:  DECFSZ xF0,F
295A:  BRA    294A
....................          
....................         oyunBitti = TRUE; 
295C:  MOVLB  0
295E:  BSF    xF5.3
....................         fan_off(); 
2960:  BCF    F94.4
2962:  BCF    F8B.4
....................         sure_son_say = 0; 
2964:  MOVLB  2
2966:  CLRF   xEE
....................         dfPlayerNormSes(); 
2968:  MOVLW  14
296A:  MOVWF  xF3
296C:  MOVLB  0
296E:  CALL   06CA
2972:  MOVLW  64
2974:  MOVLB  3
2976:  MOVWF  x0A
2978:  MOVLB  0
297A:  CALL   04F8
297E:  MOVLB  2
....................  
....................     }  
....................     if (millis() - time_sure_son_say > 1000) { 
2980:  MOVF   xEA,W
2982:  SUBWF  1A,W
2984:  MOVWF  xF0
2986:  MOVF   xEB,W
2988:  SUBWFB 1B,W
298A:  MOVWF  xF1
298C:  MOVF   xEC,W
298E:  SUBWFB 1C,W
2990:  MOVWF  xF2
2992:  MOVF   xED,W
2994:  SUBWFB 1D,W
2996:  MOVWF  xF3
2998:  MOVF   xF3,F
299A:  BNZ   29B0
299C:  MOVF   xF2,F
299E:  BNZ   29B0
29A0:  MOVF   xF1,W
29A2:  SUBLW  02
29A4:  BC    29CA
29A6:  XORLW  FF
29A8:  BNZ   29B0
29AA:  MOVF   xF0,W
29AC:  SUBLW  E8
29AE:  BC    29CA
....................             sure_son_say++; 
29B0:  INCF   xEE,F
....................             ortHiz -= 5; 
29B2:  MOVLW  05
29B4:  SUBWF  49,F
29B6:  MOVLW  00
29B8:  SUBWFB 4A,F
....................             time_sure_son_say=millis(); 
29BA:  MOVFF  1D,2ED
29BE:  MOVFF  1C,2EC
29C2:  MOVFF  1B,2EB
29C6:  MOVFF  1A,2EA
....................     } 
....................      
....................     if(ortHiz<100) ortHiz=100; 
29CA:  MOVF   4A,F
29CC:  BNZ   29DA
29CE:  MOVF   49,W
29D0:  SUBLW  63
29D2:  BNC   29DA
29D4:  CLRF   4A
29D6:  MOVLW  64
29D8:  MOVWF  49
29DA:  MOVLB  0
29DC:  RETURN 0
....................  
.................... }// 
....................  
.................... void sureBul(int ee_deger) { 
....................  
....................     switch (ee_deger) { 
29DE:  MOVLB  2
29E0:  MOVF   xEF,W
29E2:  XORLW  14
29E4:  MOVLB  0
29E6:  BZ    2A48
29E8:  XORLW  0D
29EA:  BZ    2A8A
29EC:  XORLW  07
29EE:  BTFSC  FD8.2
29F0:  BRA    2ACC
29F2:  XORLW  3D
29F4:  BTFSC  FD8.2
29F6:  BRA    2B0E
29F8:  XORLW  0B
29FA:  BTFSC  FD8.2
29FC:  BRA    2B50
29FE:  XORLW  05
2A00:  BTFSC  FD8.2
2A02:  BRA    2B92
2A04:  XORLW  1F
2A06:  BTFSC  FD8.2
2A08:  BRA    2BD4
2A0A:  XORLW  05
2A0C:  BTFSC  FD8.2
2A0E:  BRA    2C16
2A10:  XORLW  0B
2A12:  BTFSC  FD8.2
2A14:  BRA    2C58
2A16:  XORLW  7D
2A18:  BTFSC  FD8.2
2A1A:  BRA    2C9A
2A1C:  XORLW  07
2A1E:  BTFSC  FD8.2
2A20:  BRA    2CDC
2A22:  XORLW  0D
2A24:  BTFSC  FD8.2
2A26:  BRA    2D1E
2A28:  XORLW  1B
2A2A:  BTFSC  FD8.2
2A2C:  BRA    2D60
2A2E:  XORLW  05
2A30:  BTFSC  FD8.2
2A32:  BRA    2DA2
2A34:  XORLW  0F
2A36:  BTFSC  FD8.2
2A38:  BRA    2DE4
2A3A:  XORLW  05
2A3C:  BTFSC  FD8.2
2A3E:  BRA    2E26
2A40:  XORLW  3B
2A42:  BTFSC  FD8.2
2A44:  BRA    2E68
2A46:  BRA    2EA8
....................         case 20: 
....................             if ((millis() - oyunSuresiSay)>(120000LL))//(240000LL))  
2A48:  MOVF   55,W
2A4A:  SUBWF  1A,W
2A4C:  MOVLB  2
2A4E:  MOVWF  xF0
2A50:  MOVF   56,W
2A52:  SUBWFB 1B,W
2A54:  MOVWF  xF1
2A56:  MOVF   57,W
2A58:  SUBWFB 1C,W
2A5A:  MOVWF  xF2
2A5C:  MOVF   58,W
2A5E:  SUBWFB 1D,W
2A60:  MOVWF  xF3
2A62:  MOVF   xF3,F
2A64:  BNZ   2A80
2A66:  MOVF   xF2,W
2A68:  SUBLW  00
2A6A:  BC    2A86
2A6C:  XORLW  FF
2A6E:  BNZ   2A80
2A70:  MOVF   xF1,W
2A72:  SUBLW  D3
2A74:  BC    2A86
2A76:  XORLW  FF
2A78:  BNZ   2A80
2A7A:  MOVF   xF0,W
2A7C:  SUBLW  C0
2A7E:  BC    2A86
....................             { 
....................                 sureSon(); 
2A80:  MOVLB  0
2A82:  RCALL  28D2
2A84:  MOVLB  2
....................             } 
....................             break; 
2A86:  MOVLB  0
2A88:  BRA    2EA8
....................         case 25: 
....................             if ((millis() - oyunSuresiSay)>(150000LL))//(300000LL))  
2A8A:  MOVF   55,W
2A8C:  SUBWF  1A,W
2A8E:  MOVLB  2
2A90:  MOVWF  xF0
2A92:  MOVF   56,W
2A94:  SUBWFB 1B,W
2A96:  MOVWF  xF1
2A98:  MOVF   57,W
2A9A:  SUBWFB 1C,W
2A9C:  MOVWF  xF2
2A9E:  MOVF   58,W
2AA0:  SUBWFB 1D,W
2AA2:  MOVWF  xF3
2AA4:  MOVF   xF3,F
2AA6:  BNZ   2AC2
2AA8:  MOVF   xF2,W
2AAA:  SUBLW  01
2AAC:  BC    2AC8
2AAE:  XORLW  FF
2AB0:  BNZ   2AC2
2AB2:  MOVF   xF1,W
2AB4:  SUBLW  48
2AB6:  BC    2AC8
2AB8:  XORLW  FF
2ABA:  BNZ   2AC2
2ABC:  MOVF   xF0,W
2ABE:  SUBLW  F0
2AC0:  BC    2AC8
....................             { 
....................                 sureSon(); 
2AC2:  MOVLB  0
2AC4:  RCALL  28D2
2AC6:  MOVLB  2
....................             } 
....................             break; 
2AC8:  MOVLB  0
2ACA:  BRA    2EA8
....................         case 30: 
....................             if ((millis() - oyunSuresiSay)>(180000LL)) //(360000LL))  
2ACC:  MOVF   55,W
2ACE:  SUBWF  1A,W
2AD0:  MOVLB  2
2AD2:  MOVWF  xF0
2AD4:  MOVF   56,W
2AD6:  SUBWFB 1B,W
2AD8:  MOVWF  xF1
2ADA:  MOVF   57,W
2ADC:  SUBWFB 1C,W
2ADE:  MOVWF  xF2
2AE0:  MOVF   58,W
2AE2:  SUBWFB 1D,W
2AE4:  MOVWF  xF3
2AE6:  MOVF   xF3,F
2AE8:  BNZ   2B04
2AEA:  MOVF   xF2,W
2AEC:  SUBLW  01
2AEE:  BC    2B0A
2AF0:  XORLW  FF
2AF2:  BNZ   2B04
2AF4:  MOVF   xF1,W
2AF6:  SUBLW  BE
2AF8:  BC    2B0A
2AFA:  XORLW  FF
2AFC:  BNZ   2B04
2AFE:  MOVF   xF0,W
2B00:  SUBLW  20
2B02:  BC    2B0A
....................             { 
....................                 sureSon(); 
2B04:  MOVLB  0
2B06:  RCALL  28D2
2B08:  MOVLB  2
....................             } 
....................             break; 
2B0A:  MOVLB  0
2B0C:  BRA    2EA8
....................         case 35: 
....................             if ((millis() - oyunSuresiSay)>(210000LL))//(420000LL))  
2B0E:  MOVF   55,W
2B10:  SUBWF  1A,W
2B12:  MOVLB  2
2B14:  MOVWF  xF0
2B16:  MOVF   56,W
2B18:  SUBWFB 1B,W
2B1A:  MOVWF  xF1
2B1C:  MOVF   57,W
2B1E:  SUBWFB 1C,W
2B20:  MOVWF  xF2
2B22:  MOVF   58,W
2B24:  SUBWFB 1D,W
2B26:  MOVWF  xF3
2B28:  MOVF   xF3,F
2B2A:  BNZ   2B46
2B2C:  MOVF   xF2,W
2B2E:  SUBLW  02
2B30:  BC    2B4C
2B32:  XORLW  FF
2B34:  BNZ   2B46
2B36:  MOVF   xF1,W
2B38:  SUBLW  33
2B3A:  BC    2B4C
2B3C:  XORLW  FF
2B3E:  BNZ   2B46
2B40:  MOVF   xF0,W
2B42:  SUBLW  50
2B44:  BC    2B4C
....................             { 
....................                 sureSon(); 
2B46:  MOVLB  0
2B48:  RCALL  28D2
2B4A:  MOVLB  2
....................             } 
....................             break; 
2B4C:  MOVLB  0
2B4E:  BRA    2EA8
....................         case 40: 
....................             if ((millis() - oyunSuresiSay)>(240000LL))//(480000LL))  
2B50:  MOVF   55,W
2B52:  SUBWF  1A,W
2B54:  MOVLB  2
2B56:  MOVWF  xF0
2B58:  MOVF   56,W
2B5A:  SUBWFB 1B,W
2B5C:  MOVWF  xF1
2B5E:  MOVF   57,W
2B60:  SUBWFB 1C,W
2B62:  MOVWF  xF2
2B64:  MOVF   58,W
2B66:  SUBWFB 1D,W
2B68:  MOVWF  xF3
2B6A:  MOVF   xF3,F
2B6C:  BNZ   2B88
2B6E:  MOVF   xF2,W
2B70:  SUBLW  02
2B72:  BC    2B8E
2B74:  XORLW  FF
2B76:  BNZ   2B88
2B78:  MOVF   xF1,W
2B7A:  SUBLW  A8
2B7C:  BC    2B8E
2B7E:  XORLW  FF
2B80:  BNZ   2B88
2B82:  MOVF   xF0,W
2B84:  SUBLW  80
2B86:  BC    2B8E
....................             { 
....................                 sureSon(); 
2B88:  MOVLB  0
2B8A:  RCALL  28D2
2B8C:  MOVLB  2
....................             } 
....................             break; 
2B8E:  MOVLB  0
2B90:  BRA    2EA8
....................         case 45: 
....................             if ((millis() - oyunSuresiSay)>(270000LL))//(540000LL))  
2B92:  MOVF   55,W
2B94:  SUBWF  1A,W
2B96:  MOVLB  2
2B98:  MOVWF  xF0
2B9A:  MOVF   56,W
2B9C:  SUBWFB 1B,W
2B9E:  MOVWF  xF1
2BA0:  MOVF   57,W
2BA2:  SUBWFB 1C,W
2BA4:  MOVWF  xF2
2BA6:  MOVF   58,W
2BA8:  SUBWFB 1D,W
2BAA:  MOVWF  xF3
2BAC:  MOVF   xF3,F
2BAE:  BNZ   2BCA
2BB0:  MOVF   xF2,W
2BB2:  SUBLW  03
2BB4:  BC    2BD0
2BB6:  XORLW  FF
2BB8:  BNZ   2BCA
2BBA:  MOVF   xF1,W
2BBC:  SUBLW  1D
2BBE:  BC    2BD0
2BC0:  XORLW  FF
2BC2:  BNZ   2BCA
2BC4:  MOVF   xF0,W
2BC6:  SUBLW  B0
2BC8:  BC    2BD0
....................             { 
....................                 sureSon(); 
2BCA:  MOVLB  0
2BCC:  RCALL  28D2
2BCE:  MOVLB  2
....................             } 
....................             break; 
2BD0:  MOVLB  0
2BD2:  BRA    2EA8
....................         case 50: 
....................             if ((millis() - oyunSuresiSay)>(300000LL))//(600000LL))  
2BD4:  MOVF   55,W
2BD6:  SUBWF  1A,W
2BD8:  MOVLB  2
2BDA:  MOVWF  xF0
2BDC:  MOVF   56,W
2BDE:  SUBWFB 1B,W
2BE0:  MOVWF  xF1
2BE2:  MOVF   57,W
2BE4:  SUBWFB 1C,W
2BE6:  MOVWF  xF2
2BE8:  MOVF   58,W
2BEA:  SUBWFB 1D,W
2BEC:  MOVWF  xF3
2BEE:  MOVF   xF3,F
2BF0:  BNZ   2C0C
2BF2:  MOVF   xF2,W
2BF4:  SUBLW  03
2BF6:  BC    2C12
2BF8:  XORLW  FF
2BFA:  BNZ   2C0C
2BFC:  MOVF   xF1,W
2BFE:  SUBLW  92
2C00:  BC    2C12
2C02:  XORLW  FF
2C04:  BNZ   2C0C
2C06:  MOVF   xF0,W
2C08:  SUBLW  E0
2C0A:  BC    2C12
....................             { 
....................                 sureSon(); 
2C0C:  MOVLB  0
2C0E:  RCALL  28D2
2C10:  MOVLB  2
....................             } 
....................             break; 
2C12:  MOVLB  0
2C14:  BRA    2EA8
....................         case 55: 
....................             if ((millis() - oyunSuresiSay)>(330000LL))//(660000LL))  
2C16:  MOVF   55,W
2C18:  SUBWF  1A,W
2C1A:  MOVLB  2
2C1C:  MOVWF  xF0
2C1E:  MOVF   56,W
2C20:  SUBWFB 1B,W
2C22:  MOVWF  xF1
2C24:  MOVF   57,W
2C26:  SUBWFB 1C,W
2C28:  MOVWF  xF2
2C2A:  MOVF   58,W
2C2C:  SUBWFB 1D,W
2C2E:  MOVWF  xF3
2C30:  MOVF   xF3,F
2C32:  BNZ   2C4E
2C34:  MOVF   xF2,W
2C36:  SUBLW  04
2C38:  BC    2C54
2C3A:  XORLW  FF
2C3C:  BNZ   2C4E
2C3E:  MOVF   xF1,W
2C40:  SUBLW  08
2C42:  BC    2C54
2C44:  XORLW  FF
2C46:  BNZ   2C4E
2C48:  MOVF   xF0,W
2C4A:  SUBLW  10
2C4C:  BC    2C54
....................             { 
....................                 sureSon(); 
2C4E:  MOVLB  0
2C50:  RCALL  28D2
2C52:  MOVLB  2
....................             } 
....................             break; 
2C54:  MOVLB  0
2C56:  BRA    2EA8
....................         case 60: 
....................             if ((millis() - oyunSuresiSay)>(360000LL))//(720000LL))  
2C58:  MOVF   55,W
2C5A:  SUBWF  1A,W
2C5C:  MOVLB  2
2C5E:  MOVWF  xF0
2C60:  MOVF   56,W
2C62:  SUBWFB 1B,W
2C64:  MOVWF  xF1
2C66:  MOVF   57,W
2C68:  SUBWFB 1C,W
2C6A:  MOVWF  xF2
2C6C:  MOVF   58,W
2C6E:  SUBWFB 1D,W
2C70:  MOVWF  xF3
2C72:  MOVF   xF3,F
2C74:  BNZ   2C90
2C76:  MOVF   xF2,W
2C78:  SUBLW  04
2C7A:  BC    2C96
2C7C:  XORLW  FF
2C7E:  BNZ   2C90
2C80:  MOVF   xF1,W
2C82:  SUBLW  7D
2C84:  BC    2C96
2C86:  XORLW  FF
2C88:  BNZ   2C90
2C8A:  MOVF   xF0,W
2C8C:  SUBLW  40
2C8E:  BC    2C96
....................             { 
....................                 sureSon(); 
2C90:  MOVLB  0
2C92:  RCALL  28D2
2C94:  MOVLB  2
....................             } 
....................             break; 
2C96:  MOVLB  0
2C98:  BRA    2EA8
....................         case 65: 
....................             if ((millis() - oyunSuresiSay)>(390000LL))//(780000LL))  
2C9A:  MOVF   55,W
2C9C:  SUBWF  1A,W
2C9E:  MOVLB  2
2CA0:  MOVWF  xF0
2CA2:  MOVF   56,W
2CA4:  SUBWFB 1B,W
2CA6:  MOVWF  xF1
2CA8:  MOVF   57,W
2CAA:  SUBWFB 1C,W
2CAC:  MOVWF  xF2
2CAE:  MOVF   58,W
2CB0:  SUBWFB 1D,W
2CB2:  MOVWF  xF3
2CB4:  MOVF   xF3,F
2CB6:  BNZ   2CD2
2CB8:  MOVF   xF2,W
2CBA:  SUBLW  04
2CBC:  BC    2CD8
2CBE:  XORLW  FF
2CC0:  BNZ   2CD2
2CC2:  MOVF   xF1,W
2CC4:  SUBLW  F2
2CC6:  BC    2CD8
2CC8:  XORLW  FF
2CCA:  BNZ   2CD2
2CCC:  MOVF   xF0,W
2CCE:  SUBLW  70
2CD0:  BC    2CD8
....................             { 
....................                 sureSon(); 
2CD2:  MOVLB  0
2CD4:  RCALL  28D2
2CD6:  MOVLB  2
....................             } 
....................             break; 
2CD8:  MOVLB  0
2CDA:  BRA    2EA8
....................         case 70: 
....................             if ((millis() - oyunSuresiSay)>(420000LL))//(840000LL))  
2CDC:  MOVF   55,W
2CDE:  SUBWF  1A,W
2CE0:  MOVLB  2
2CE2:  MOVWF  xF0
2CE4:  MOVF   56,W
2CE6:  SUBWFB 1B,W
2CE8:  MOVWF  xF1
2CEA:  MOVF   57,W
2CEC:  SUBWFB 1C,W
2CEE:  MOVWF  xF2
2CF0:  MOVF   58,W
2CF2:  SUBWFB 1D,W
2CF4:  MOVWF  xF3
2CF6:  MOVF   xF3,F
2CF8:  BNZ   2D14
2CFA:  MOVF   xF2,W
2CFC:  SUBLW  05
2CFE:  BC    2D1A
2D00:  XORLW  FF
2D02:  BNZ   2D14
2D04:  MOVF   xF1,W
2D06:  SUBLW  67
2D08:  BC    2D1A
2D0A:  XORLW  FF
2D0C:  BNZ   2D14
2D0E:  MOVF   xF0,W
2D10:  SUBLW  A0
2D12:  BC    2D1A
....................             { 
....................                 sureSon(); 
2D14:  MOVLB  0
2D16:  RCALL  28D2
2D18:  MOVLB  2
....................             } 
....................             break; 
2D1A:  MOVLB  0
2D1C:  BRA    2EA8
....................         case 75: 
....................             if ((millis() - oyunSuresiSay)>(450000LL))//(900000LL))  
2D1E:  MOVF   55,W
2D20:  SUBWF  1A,W
2D22:  MOVLB  2
2D24:  MOVWF  xF0
2D26:  MOVF   56,W
2D28:  SUBWFB 1B,W
2D2A:  MOVWF  xF1
2D2C:  MOVF   57,W
2D2E:  SUBWFB 1C,W
2D30:  MOVWF  xF2
2D32:  MOVF   58,W
2D34:  SUBWFB 1D,W
2D36:  MOVWF  xF3
2D38:  MOVF   xF3,F
2D3A:  BNZ   2D56
2D3C:  MOVF   xF2,W
2D3E:  SUBLW  05
2D40:  BC    2D5C
2D42:  XORLW  FF
2D44:  BNZ   2D56
2D46:  MOVF   xF1,W
2D48:  SUBLW  DC
2D4A:  BC    2D5C
2D4C:  XORLW  FF
2D4E:  BNZ   2D56
2D50:  MOVF   xF0,W
2D52:  SUBLW  D0
2D54:  BC    2D5C
....................             { 
....................                 sureSon(); 
2D56:  MOVLB  0
2D58:  RCALL  28D2
2D5A:  MOVLB  2
....................             } 
....................             break; 
2D5C:  MOVLB  0
2D5E:  BRA    2EA8
....................         case 80: 
....................             if ((millis() - oyunSuresiSay)>(480000LL))//(960000LL))  
2D60:  MOVF   55,W
2D62:  SUBWF  1A,W
2D64:  MOVLB  2
2D66:  MOVWF  xF0
2D68:  MOVF   56,W
2D6A:  SUBWFB 1B,W
2D6C:  MOVWF  xF1
2D6E:  MOVF   57,W
2D70:  SUBWFB 1C,W
2D72:  MOVWF  xF2
2D74:  MOVF   58,W
2D76:  SUBWFB 1D,W
2D78:  MOVWF  xF3
2D7A:  MOVF   xF3,F
2D7C:  BNZ   2D98
2D7E:  MOVF   xF2,W
2D80:  SUBLW  06
2D82:  BC    2D9E
2D84:  XORLW  FF
2D86:  BNZ   2D98
2D88:  MOVF   xF1,W
2D8A:  SUBLW  52
2D8C:  BC    2D9E
2D8E:  XORLW  FF
2D90:  BNZ   2D98
2D92:  MOVF   xF0,W
2D94:  SUBLW  00
2D96:  BC    2D9E
....................             { 
....................                 sureSon(); 
2D98:  MOVLB  0
2D9A:  RCALL  28D2
2D9C:  MOVLB  2
....................             } 
....................             break; 
2D9E:  MOVLB  0
2DA0:  BRA    2EA8
....................         case 85: 
....................             if ((millis() - oyunSuresiSay)>(510000LL))//(1020000LL))  
2DA2:  MOVF   55,W
2DA4:  SUBWF  1A,W
2DA6:  MOVLB  2
2DA8:  MOVWF  xF0
2DAA:  MOVF   56,W
2DAC:  SUBWFB 1B,W
2DAE:  MOVWF  xF1
2DB0:  MOVF   57,W
2DB2:  SUBWFB 1C,W
2DB4:  MOVWF  xF2
2DB6:  MOVF   58,W
2DB8:  SUBWFB 1D,W
2DBA:  MOVWF  xF3
2DBC:  MOVF   xF3,F
2DBE:  BNZ   2DDA
2DC0:  MOVF   xF2,W
2DC2:  SUBLW  06
2DC4:  BC    2DE0
2DC6:  XORLW  FF
2DC8:  BNZ   2DDA
2DCA:  MOVF   xF1,W
2DCC:  SUBLW  C7
2DCE:  BC    2DE0
2DD0:  XORLW  FF
2DD2:  BNZ   2DDA
2DD4:  MOVF   xF0,W
2DD6:  SUBLW  30
2DD8:  BC    2DE0
....................             { 
....................                 sureSon(); 
2DDA:  MOVLB  0
2DDC:  RCALL  28D2
2DDE:  MOVLB  2
....................             } 
....................             break; 
2DE0:  MOVLB  0
2DE2:  BRA    2EA8
....................         case 90: 
....................             if ((millis() - oyunSuresiSay)>(540000LL))//(1080000LL))  
2DE4:  MOVF   55,W
2DE6:  SUBWF  1A,W
2DE8:  MOVLB  2
2DEA:  MOVWF  xF0
2DEC:  MOVF   56,W
2DEE:  SUBWFB 1B,W
2DF0:  MOVWF  xF1
2DF2:  MOVF   57,W
2DF4:  SUBWFB 1C,W
2DF6:  MOVWF  xF2
2DF8:  MOVF   58,W
2DFA:  SUBWFB 1D,W
2DFC:  MOVWF  xF3
2DFE:  MOVF   xF3,F
2E00:  BNZ   2E1C
2E02:  MOVF   xF2,W
2E04:  SUBLW  07
2E06:  BC    2E22
2E08:  XORLW  FF
2E0A:  BNZ   2E1C
2E0C:  MOVF   xF1,W
2E0E:  SUBLW  3C
2E10:  BC    2E22
2E12:  XORLW  FF
2E14:  BNZ   2E1C
2E16:  MOVF   xF0,W
2E18:  SUBLW  60
2E1A:  BC    2E22
....................             { 
....................                 sureSon(); 
2E1C:  MOVLB  0
2E1E:  RCALL  28D2
2E20:  MOVLB  2
....................             } 
....................             break; 
2E22:  MOVLB  0
2E24:  BRA    2EA8
....................         case 95: 
....................             if ((millis() - oyunSuresiSay)>(570000LL))//(1140000LL))  
2E26:  MOVF   55,W
2E28:  SUBWF  1A,W
2E2A:  MOVLB  2
2E2C:  MOVWF  xF0
2E2E:  MOVF   56,W
2E30:  SUBWFB 1B,W
2E32:  MOVWF  xF1
2E34:  MOVF   57,W
2E36:  SUBWFB 1C,W
2E38:  MOVWF  xF2
2E3A:  MOVF   58,W
2E3C:  SUBWFB 1D,W
2E3E:  MOVWF  xF3
2E40:  MOVF   xF3,F
2E42:  BNZ   2E5E
2E44:  MOVF   xF2,W
2E46:  SUBLW  07
2E48:  BC    2E64
2E4A:  XORLW  FF
2E4C:  BNZ   2E5E
2E4E:  MOVF   xF1,W
2E50:  SUBLW  B1
2E52:  BC    2E64
2E54:  XORLW  FF
2E56:  BNZ   2E5E
2E58:  MOVF   xF0,W
2E5A:  SUBLW  90
2E5C:  BC    2E64
....................             { 
....................                 sureSon(); 
2E5E:  MOVLB  0
2E60:  RCALL  28D2
2E62:  MOVLB  2
....................             } 
....................             break; 
2E64:  MOVLB  0
2E66:  BRA    2EA8
....................         case 100: 
....................             if ((millis() - oyunSuresiSay)>(600000LL))//(1200000LL))  
2E68:  MOVF   55,W
2E6A:  SUBWF  1A,W
2E6C:  MOVLB  2
2E6E:  MOVWF  xF0
2E70:  MOVF   56,W
2E72:  SUBWFB 1B,W
2E74:  MOVWF  xF1
2E76:  MOVF   57,W
2E78:  SUBWFB 1C,W
2E7A:  MOVWF  xF2
2E7C:  MOVF   58,W
2E7E:  SUBWFB 1D,W
2E80:  MOVWF  xF3
2E82:  MOVF   xF3,F
2E84:  BNZ   2EA0
2E86:  MOVF   xF2,W
2E88:  SUBLW  08
2E8A:  BC    2EA6
2E8C:  XORLW  FF
2E8E:  BNZ   2EA0
2E90:  MOVF   xF1,W
2E92:  SUBLW  26
2E94:  BC    2EA6
2E96:  XORLW  FF
2E98:  BNZ   2EA0
2E9A:  MOVF   xF0,W
2E9C:  SUBLW  C0
2E9E:  BC    2EA6
....................             { 
....................                 sureSon(); 
2EA0:  MOVLB  0
2EA2:  RCALL  28D2
2EA4:  MOVLB  2
....................             } 
....................             break; 
2EA6:  MOVLB  0
....................     } 
2EA8:  GOTO   3A9C (RETURN)
....................      
.................... } 
....................  
....................  
....................  
....................  
.................... void main() { 
*
33A0:  CLRF   FF8
33A2:  BCF    FF1.2
33A4:  BSF    FD0.7
33A6:  BSF    07.7
33A8:  MOVLW  70
33AA:  MOVWF  FD3
33AC:  BSF    F9B.6
33AE:  BCF    F9B.7
33B0:  BSF    F70.3
33B2:  MOVLW  82
33B4:  MOVWF  F75
33B6:  MOVLW  06
33B8:  MOVWF  F76
33BA:  MOVLW  A6
33BC:  MOVWF  F72
33BE:  MOVLW  90
33C0:  MOVWF  F71
33C2:  CLRF   19
33C4:  BSF    FB8.3
33C6:  MOVLW  82
33C8:  MOVWF  FAF
33CA:  MOVLW  06
33CC:  MOVWF  FB0
33CE:  MOVLW  A6
33D0:  MOVWF  FAC
33D2:  MOVLW  90
33D4:  MOVWF  FAB
33D6:  CLRF   1D
33D8:  CLRF   1C
33DA:  CLRF   1B
33DC:  CLRF   1A
33DE:  MOVLW  0F
33E0:  MOVWF  24
33E2:  MOVLW  13
33E4:  MOVWF  25
33E6:  CLRF   2F
33E8:  CLRF   3D
33EA:  CLRF   3C
33EC:  CLRF   3B
33EE:  CLRF   3A
33F0:  CLRF   41
33F2:  CLRF   40
33F4:  CLRF   3F
33F6:  CLRF   3E
33F8:  CLRF   42
33FA:  CLRF   44
33FC:  CLRF   43
33FE:  CLRF   46
3400:  CLRF   45
3402:  CLRF   48
3404:  CLRF   47
3406:  CLRF   4A
3408:  MOVLW  96
340A:  MOVWF  49
340C:  CLRF   4C
340E:  MOVLW  C8
3410:  MOVWF  4B
3412:  BCF    4D.0
3414:  CLRF   4E
3416:  CLRF   4F
3418:  BCF    4D.1
341A:  BCF    4D.2
341C:  BCF    4D.3
341E:  BCF    4D.4
3420:  CLRF   53
3422:  CLRF   52
3424:  CLRF   51
3426:  CLRF   50
3428:  MOVLW  19
342A:  MOVWF  54
342C:  CLRF   58
342E:  CLRF   57
3430:  CLRF   56
3432:  CLRF   55
3434:  CLRF   5C
3436:  CLRF   5B
3438:  CLRF   5A
343A:  CLRF   59
343C:  CLRF   5E
343E:  CLRF   5D
3440:  CLRF   5F
3442:  BCF    4D.5
3444:  CLRF   xE8
3446:  CLRF   xEA
3448:  CLRF   xE9
344A:  CLRF   xEC
344C:  CLRF   xEB
344E:  CLRF   xEE
3450:  CLRF   xED
3452:  CLRF   xF0
3454:  CLRF   xEF
3456:  CLRF   xF4
3458:  CLRF   xF3
345A:  CLRF   xF2
345C:  CLRF   xF1
345E:  BCF    4D.6
3460:  BCF    4D.7
3462:  BSF    xF5.0
3464:  BCF    xF5.1
3466:  BCF    xF5.2
3468:  BSF    xF5.3
346A:  CLRF   xF6
346C:  CLRF   xF8
346E:  CLRF   xF7
3470:  CLRF   xFA
3472:  CLRF   xF9
3474:  MOVLB  2
3476:  CLRF   xDC
3478:  CLRF   xDB
347A:  CLRF   xDE
347C:  CLRF   xDD
347E:  CLRF   xE0
3480:  CLRF   xDF
3482:  CLRF   xE2
3484:  CLRF   xE1
3486:  CLRF   xE3
3488:  CLRF   xE4
348A:  MOVLB  0
348C:  BCF    xF5.4
348E:  BCF    xF5.5
3490:  MOVLB  2
3492:  CLRF   xE5
3494:  CLRF   xE6
3496:  MOVLW  09
3498:  MOVWF  xE7
349A:  MOVLW  14
349C:  MOVWF  xE8
349E:  CLRF   xE9
34A0:  CLRF   xED
34A2:  CLRF   xEC
34A4:  CLRF   xEB
34A6:  CLRF   xEA
34A8:  CLRF   xEE
34AA:  MOVLB  F
34AC:  CLRF   x38
34AE:  CLRF   x39
34B0:  CLRF   x3A
34B2:  CLRF   x3B
34B4:  CLRF   x3C
34B6:  CLRF   F77
34B8:  CLRF   F78
34BA:  CLRF   F79
34BC:  BRA    34C8
34BE:  DATA 02,00
34C0:  DATA 1E,00
34C2:  DATA 00,28
34C4:  DATA 40,C0
34C6:  DATA 00,00
34C8:  MOVLW  00
34CA:  MOVWF  FF8
34CC:  MOVLW  34
34CE:  MOVWF  FF7
34D0:  MOVLW  BE
34D2:  MOVWF  FF6
34D4:  TBLRD*+
34D6:  MOVF   FF5,W
34D8:  MOVWF  00
34DA:  XORLW  00
34DC:  BZ    3504
34DE:  TBLRD*+
34E0:  MOVF   FF5,W
34E2:  MOVWF  01
34E4:  BTFSC  FE8.7
34E6:  BRA    34F2
34E8:  ANDLW  0F
34EA:  MOVWF  FEA
34EC:  TBLRD*+
34EE:  MOVFF  FF5,FE9
34F2:  BTFSC  01.6
34F4:  TBLRD*+
34F6:  BTFSS  01.6
34F8:  TBLRD*+
34FA:  MOVFF  FF5,FEE
34FE:  DCFSNZ 00,F
3500:  BRA    34D4
3502:  BRA    34F6
3504:  CLRF   FF8
....................     // setup_oscillator(OSC_32MHZ); 
....................     setup_oscillator(OSC_64MHZ); 
3506:  MOVLW  70
3508:  MOVWF  FD3
350A:  BSF    F9B.6
350C:  BCF    F9B.7
....................  
....................     setup_dac(DAC_OFF); 
350E:  CLRF   x41
....................     setup_comparator(NC_NC_NC_NC); 
3510:  CLRF   F77
3512:  MOVLW  04
3514:  MOVWF  F78
3516:  MOVWF  F79
....................     setup_vref(FALSE); 
3518:  CLRF   x42
....................     //setup_adc(ADC_OFF); 
....................  
....................     setup_ccp1(CCP_PWM); // Configure CCP1 as standard PWM 
351A:  BCF    F94.2
351C:  BCF    F8B.2
351E:  MOVLW  0C
3520:  MOVWF  FBD
3522:  CLRF   FB7
3524:  CLRF   FB6
3526:  MOVLW  01
3528:  MOVWF  FB9
352A:  MOVLW  FC
352C:  ANDWF  x49,F
352E:  MOVLW  00
3530:  IORWF  x49,F
....................     setup_ccp2(CCP_PWM); // Configure CCP2 as standard PWM 
3532:  BCF    F94.1
3534:  BCF    F8B.1
3536:  MOVLW  0C
3538:  MOVWF  F66
353A:  CLRF   F65
353C:  CLRF   F64
353E:  MOVLW  01
3540:  MOVWF  F63
3542:  MOVLW  E7
3544:  ANDWF  x49,F
3546:  MOVLW  00
3548:  IORWF  x49,F
....................     setup_ccp3(CCP_OFF); 
354A:  MOVLW  F0
354C:  ANDWF  x5D,F
....................     setup_ccp4(CCP_OFF); 
354E:  ANDWF  x57,F
....................     setup_ccp5(CCP_OFF); 
3550:  ANDWF  x54,F
....................  
....................     setup_timer_1(T1_DISABLED); 
3552:  CLRF   FCD
3554:  CLRF   FCC
....................     //setup_timer_2(T2_DIV_BY_16, 250, 1);   // 40MHz fosc ile 2.5KHz yaklaþýk(div_16) 
....................     setup_timer_4(T4_DISABLED, 0, 1); 
3556:  MOVLW  00
3558:  MOVWF  x51
355A:  MOVLW  00
355C:  MOVWF  x52
....................     setup_timer_5(T5_DISABLED); 
355E:  CLRF   x4D
3560:  CLRF   x4E
....................     setup_timer_6(T6_DISABLED, 0, 1); 
3562:  MOVWF  x4A
3564:  MOVLW  00
3566:  MOVWF  x4B
....................  
....................     // setup_adc(ADC_CLOCK_DIV_16);  
....................     setup_adc(ADC_CLOCK_INTERNAL); //  9 bit (max 511) okuyan adc bu þekilde 10 bit oldu..... 
3568:  MOVF   FC0,W
356A:  ANDLW  C0
356C:  IORLW  07
356E:  MOVWF  FC0
3570:  BSF    FC0.7
3572:  BSF    FC2.0
....................     setup_adc_ports(sAN0 | sAN1 | sAN2 | sAN3 | sAN4 | sAN5 | sAN6 | sAN7 | sAN8, VSS_VDD); 
3574:  MOVF   FC1,W
3576:  ANDLW  F0
3578:  MOVWF  FC1
357A:  MOVLW  2F
357C:  MOVWF  x38
357E:  MOVLW  07
3580:  MOVWF  x3C
3582:  MOVLW  04
3584:  MOVWF  x39
3586:  MOVLW  00
3588:  MOVWF  x3A
358A:  MOVWF  x3B
....................     /* PWM Hakkýnda : 
....................         setup_timer_2(T2_DIV_BY_16, 124, 1); komut satýrý ile 10 bit PWM 
....................      *  2500Hz için ayarlanmýþ oldu  
....................      */ 
....................     //setup_timer_2(T2_DIV_BY_16, 124, 1);   // Set PWM frequency to 2500Hz(div_16) max Pwm deger 500 
....................     //setup_timer_2(T2_DIV_BY_1, 249, 1);   //20KHz max PWM deger 500 
....................  
....................     setup_timer_2(T2_DIV_BY_16, 199, 1);      //5Khz max PWM deger=200 peryot kadar osilaskop sonucu 22.01.20 bu uygulamada olmadý 
358C:  IORLW  06
358E:  MOVWF  FBA
3590:  MOVLW  C7
3592:  MOVWF  FBB
....................                                               // 17.01.2020 : Ugulamada  700 deðeri hesaplamaya göre görüldü 22.01.20 evet.... 
....................                                               // excell hesabýnda %50 duty deðeri 400 çýkýyor. 5KHz PWM  
....................      
....................     //setup_timer_2(T2_DIV_BY_4, 124, 1);     //10HzKhz max PWM deger 460 
....................  
....................     sagMotor_hiz(0) ;     //set_pwm1_duty(100); 
3594:  CLRF   FBE
....................     solMotor_hiz(0);      // //set_pwm2_duty(100); 
3596:  CLRF   F67
....................     
....................    // set_tris_d(10111111); 
....................  
....................     buzzer_off(); 
3598:  BCF    F94.0
359A:  BCF    F8B.0
....................     bip_rf_var(); 
359C:  MOVLB  2
359E:  CLRF   xF5
35A0:  MOVLW  32
35A2:  MOVWF  xF4
35A4:  MOVLW  02
35A6:  MOVWF  xF6
35A8:  MOVLW  7C
35AA:  MOVWF  xF8
35AC:  MOVLW  10
35AE:  MOVWF  xF7
35B0:  MOVLB  0
35B2:  CALL   0522
....................     fan_off(); 
35B6:  BCF    F94.4
35B8:  BCF    F8B.4
....................     // led1_off(); //kullanýlmamalý 
....................     led2_off(); 
35BA:  BCF    F92.6
35BC:  BCF    F89.6
....................  
....................     millis_kurulum(); 
35BE:  GOTO   05E0
....................     delay_m_us(100); 
35C2:  MOVLB  2
35C4:  CLRF   xF0
35C6:  MOVLW  64
35C8:  MOVWF  xEF
35CA:  MOVLB  0
35CC:  GOTO   05F4
....................      
....................     if(read_eeprom(ee_adr_jtn)!=0xFF) 
35D0:  MOVFF  FF2,2EF
35D4:  BCF    FF2.7
35D6:  MOVLW  10
35D8:  MOVWF  FA9
35DA:  BCF    FA6.6
35DC:  BCF    FA6.7
35DE:  BSF    FA6.0
35E0:  MOVF   FA8,W
35E2:  MOVLB  2
35E4:  BTFSC  xEF.7
35E6:  BSF    FF2.7
35E8:  SUBLW  FF
35EA:  BZ    3606
....................         ee_jeton_suresi_deger=read_eeprom(ee_adr_jtn); 
35EC:  MOVFF  FF2,2EF
35F0:  BCF    FF2.7
35F2:  MOVLW  10
35F4:  MOVWF  FA9
35F6:  BCF    FA6.6
35F8:  BCF    FA6.7
35FA:  BSF    FA6.0
35FC:  MOVF   FA8,W
35FE:  BTFSC  xEF.7
3600:  BSF    FF2.7
3602:  MOVWF  54
3604:  BRA    360A
....................     else ee_jeton_suresi_deger=25; // 2.5 dak 
3606:  MOVLW  19
3608:  MOVWF  54
....................      
....................     if(read_eeprom(ee_adr_ortHiz_H)!=0xFF && read_eeprom(ee_adr_ortHiz_L)!=0xFF) 
360A:  MOVFF  FF2,2EF
360E:  BCF    FF2.7
3610:  CLRF   FA9
3612:  BCF    FA6.6
3614:  BCF    FA6.7
3616:  BSF    FA6.0
3618:  MOVF   FA8,W
361A:  BTFSC  xEF.7
361C:  BSF    FF2.7
361E:  SUBLW  FF
3620:  BZ    3674
3622:  MOVFF  FF2,2F0
3626:  BCF    FF2.7
3628:  MOVLW  01
362A:  MOVWF  FA9
362C:  BCF    FA6.6
362E:  BCF    FA6.7
3630:  BSF    FA6.0
3632:  MOVF   FA8,W
3634:  BTFSC  xF0.7
3636:  BSF    FF2.7
3638:  SUBLW  FF
363A:  BZ    3674
....................     { 
....................         ortHiz_max=make16(read_eeprom(ee_adr_ortHiz_H), read_eeprom(ee_adr_ortHiz_L)); 
363C:  MOVFF  FF2,2EF
3640:  BCF    FF2.7
3642:  CLRF   FA9
3644:  BCF    FA6.6
3646:  BCF    FA6.7
3648:  BSF    FA6.0
364A:  MOVF   FA8,W
364C:  BTFSC  xEF.7
364E:  BSF    FF2.7
3650:  MOVWF  xF0
3652:  MOVFF  FF2,2F1
3656:  BCF    FF2.7
3658:  MOVLW  01
365A:  MOVWF  FA9
365C:  BCF    FA6.6
365E:  BCF    FA6.7
3660:  BSF    FA6.0
3662:  MOVF   FA8,W
3664:  BTFSC  xF1.7
3666:  BSF    FF2.7
3668:  MOVWF  xF2
366A:  MOVFF  2F0,4C
366E:  MOVFF  2F2,4B
....................     }else { 
3672:  BRA    367C
....................         ortHiz_max=350; 
3674:  MOVLW  01
3676:  MOVWF  4C
3678:  MOVLW  5E
367A:  MOVWF  4B
.................... //        ortHiz_max=350; 
.................... //        ortHiz_max=450; 
....................     } 
....................      
....................     if(read_eeprom(ee_adr_df_ses)!=0xFF) 
367C:  MOVFF  FF2,2EF
3680:  BCF    FF2.7
3682:  MOVLW  02
3684:  MOVWF  FA9
3686:  BCF    FA6.6
3688:  BCF    FA6.7
368A:  BSF    FA6.0
368C:  MOVF   FA8,W
368E:  BTFSC  xEF.7
3690:  BSF    FF2.7
3692:  SUBLW  FF
3694:  BZ    36B0
....................         df_player_ses=read_eeprom(ee_adr_df_ses); 
3696:  MOVFF  FF2,2EF
369A:  BCF    FF2.7
369C:  MOVLW  02
369E:  MOVWF  FA9
36A0:  BCF    FA6.6
36A2:  BCF    FA6.7
36A4:  BSF    FA6.0
36A6:  MOVF   FA8,W
36A8:  BTFSC  xEF.7
36AA:  BSF    FF2.7
36AC:  MOVWF  24
36AE:  BRA    36B4
....................     else df_player_ses=dfPlayerNSes; 
36B0:  MOVLW  14
36B2:  MOVWF  24
....................      
....................     mp3_set_volume(df_player_ses);delay_ms(100); 
36B4:  MOVFF  24,2F3
36B8:  MOVLB  0
36BA:  CALL   06CA
36BE:  MOVLW  64
36C0:  MOVLB  3
36C2:  MOVWF  x0A
36C4:  MOVLB  0
36C6:  CALL   04F8
....................      //fprintf(usbSerial, "Basla...\r\n"); 
....................       
....................      memset(ir_sens_ort_deger, 0, SENS_SAYISI); 
36CA:  CLRF   FEA
36CC:  MOVLW  70
36CE:  MOVWF  FE9
36D0:  CLRF   00
36D2:  CLRF   02
36D4:  MOVLW  08
36D6:  MOVWF  01
36D8:  CALL   06DC
....................     ir_led_off(); 
36DC:  BCF    F94.3
36DE:  BSF    F8B.3
....................     //kalibrasyon(); 
....................     k_means_baslangic_esik_olustur(); 
36E0:  CALL   0812
....................  
....................     srand(MP3_SD_RASTGELE_MAX_SAYI); // everytime this is called the seed will be initialized and the random sequence will be started  
36E4:  MOVLB  2
36E6:  CLRF   xF2
36E8:  CLRF   xF1
36EA:  CLRF   xF0
36EC:  MOVLW  09
36EE:  MOVWF  xEF
36F0:  MOVLB  0
36F2:  GOTO   089C
....................     // time_aku_ornek=millis(); 
....................     time_aku_ornek = time_aku_sarj_seslendir=millis(); 
36F6:  MOVFF  1D,41
36FA:  MOVFF  1C,40
36FE:  MOVFF  1B,3F
3702:  MOVFF  1A,3E
3706:  MOVFF  41,53
370A:  MOVFF  40,52
370E:  MOVFF  3F,51
3712:  MOVFF  3E,50
....................     lfr_led_goster(lfr_led=0); 
3716:  CLRF   42
3718:  MOVLB  2
371A:  CLRF   xF3
371C:  MOVFF  42,2F2
3720:  MOVLW  08
3722:  MOVWF  xF4
3724:  MOVLB  0
3726:  CALL   08B0
....................      
....................     ortHiz=ORT_HIZ_MIN;      //150     //max pwm=700 
372A:  CLRF   4A
372C:  MOVLW  64
372E:  MOVWF  49
....................     time_ort_hiz=millis(); 
3730:  MOVFF  1B,FA
3734:  MOVFF  1A,F9
....................      
....................     while (TRUE) { 
....................  
.................... //        if(!input(ACIL_DUR_SENS_PIN)){ 
.................... //            ileri_git(0,0); //tren acil dur 
.................... //            mp3_stop_100mS(); 
.................... //            mp3_play(TREN_DUDUK); 
.................... //            delay_ms(1000); 
.................... //            mp3_play(TREN_DUDUK); 
.................... //            delay_ms(1000); 
.................... //        }              
.................... //        else  
....................          
....................         ileri_git(solMhiz,sagMhiz);     // *** hýzda devemlýlýðý saðlýyor. 
3738:  MOVFF  46,02
373C:  MOVFF  45,01
3740:  RRCF   02,F
3742:  RRCF   01,F
3744:  RRCF   02,F
3746:  RRCF   01,F
3748:  RRCF   02,F
374A:  MOVFF  01,F67
374E:  RRCF   02,F
3750:  RRCF   02,W
3752:  ANDLW  30
3754:  MOVWF  00
3756:  MOVF   F66,W
3758:  ANDLW  CF
375A:  IORWF  00,W
375C:  MOVWF  F66
375E:  MOVFF  48,02
3762:  MOVFF  47,01
3766:  RRCF   02,F
3768:  RRCF   01,F
376A:  RRCF   02,F
376C:  RRCF   01,F
376E:  RRCF   02,F
3770:  MOVFF  01,FBE
3774:  RRCF   02,F
3776:  RRCF   02,W
3778:  ANDLW  30
377A:  MOVWF  00
377C:  MOVF   FBD,W
377E:  ANDLW  CF
3780:  IORWF  00,W
3782:  MOVWF  FBD
....................          
....................         rf_islemler() ; 
3784:  GOTO   0C6C
....................  
....................         if (rfKontrol || oyunBitti)  
3788:  BTFSC  xF5.0
378A:  BRA    3790
378C:  BTFSS  xF5.3
378E:  BRA    37C2
....................         { 
....................             if (input(DF_BUSY_PIN) && 
....................                 (!input(tus1) && !input(tus2) && !input(tus3) && !input(tus4) && !input(tus5) && !input(tus6)) 
3790:  BSF    F94.5
3792:  BTFSS  F82.5
3794:  BRA    37C2
3796:  BTFSC  F83.0
3798:  BRA    37C2
379A:  BTFSC  F83.1
379C:  BRA    37C2
379E:  BTFSC  F83.2
37A0:  BRA    37C2
37A2:  BTFSC  F83.3
37A4:  BRA    37C2
37A6:  BTFSC  F83.4
37A8:  BRA    37C2
37AA:  BTFSC  F83.5
37AC:  BRA    37C2
....................                )  
....................             { 
....................                 if(solMhiz==0 && sagMhiz ==0) 
37AE:  MOVF   45,F
37B0:  BNZ   37C2
37B2:  MOVF   46,F
37B4:  BNZ   37C2
37B6:  MOVF   47,F
37B8:  BNZ   37C2
37BA:  MOVF   48,F
37BC:  BNZ   37C2
....................                         mp3_rastgele(); 
37BE:  CALL   0A86
....................             } 
....................         } 
....................          
....................         if(rfKontrol && k_means_yeni_veri) //!rfKontrol)// normal çalýþýrken  
37C2:  BTFSS  xF5.0
37C4:  BRA    37D8
37C6:  BTFSS  xF5.4
37C8:  BRA    37D8
....................         { 
....................             k_means_max_min_esik(); 
37CA:  CALL   1702
....................             sens_cizgi_durum_getir(); 
37CE:  CALL   1B42
....................             sens_led_goster(); 
37D2:  CALL   1FB2
....................             k_means_yeni_veri = FALSE; 
37D6:  BCF    xF5.4
....................         } 
....................          
....................         if (k_means_yeni_veri && cizgiKontrolBaslat) { 
37D8:  BTFSS  xF5.4
37DA:  BRA    3B1C
37DC:  BTFSS  xF5.2
37DE:  BRA    3B1C
....................              
....................             k_means_max_min_esik(); 
37E0:  CALL   1702
....................             sens_cizgi_durum_getir(); 
37E4:  CALL   1B42
....................             sens_led_goster(); 
37E8:  CALL   1FB2
....................              
....................             ir_sens_pos_digital = agirlikliPosGetir(DIGITAL_DEGER); 
37EC:  MOVLW  42
37EE:  MOVLB  2
37F0:  MOVWF  xEF
37F2:  MOVLB  0
37F4:  GOTO   2104
37F8:  MOVFF  02,44
37FC:  MOVFF  01,43
....................              
....................            // ir_sens_pos_digital = agirlikliPosGetir(ORTALAMA_DEGER);         
....................            // fprintf(usbSerial,"ort:%lu \t ht:%ld\r\n",ir_sens_pos_digital,hata); 
....................              
....................             hata = HATA_REF - ir_sens_pos_digital; 
3800:  MOVLW  D6
3802:  BSF    FD8.0
3804:  SUBFWB 43,W
3806:  MOVWF  00
3808:  MOVLW  06
380A:  SUBFWB 44,W
380C:  MOVFF  00,E9
3810:  MOVWF  xEA
....................             hata_deg=hata-son_hata; 
3812:  MOVF   xEB,W
3814:  SUBWF  xE9,W
3816:  MOVWF  xED
3818:  MOVF   xEC,W
381A:  SUBWFB xEA,W
381C:  MOVWF  xEE
....................              
....................             //ortHiz=200;      //150     //max pwm=700 
....................              
....................             kP=(float)(((float)ortHiz)/((float)MAX_HATA_DEGERI));// 150/1750=0,08571    0.1143f; 
381E:  MOVFF  4A,30A
3822:  MOVFF  49,309
3826:  CALL   2216
382A:  MOVFF  03,2F2
382E:  MOVFF  02,2F1
3832:  MOVFF  01,2F0
3836:  MOVFF  00,2EF
383A:  MOVFF  03,30C
383E:  MOVFF  02,30B
3842:  MOVFF  01,30A
3846:  MOVFF  00,309
384A:  MOVLB  3
384C:  CLRF   x10
384E:  MOVLW  C0
3850:  MOVWF  x0F
3852:  MOVLW  5A
3854:  MOVWF  x0E
3856:  MOVLW  89
3858:  MOVWF  x0D
385A:  MOVLB  0
385C:  CALL   224C
3860:  MOVFF  03,F4
3864:  MOVFF  02,F3
3868:  MOVFF  01,F2
386C:  MOVFF  00,F1
....................              
....................             kontrol=pdKontrol(hata, hata_deg,son_hata, kP,(kP/8.0)); 
3870:  MOVFF  F4,30C
3874:  MOVFF  F3,30B
3878:  MOVFF  F2,30A
387C:  MOVFF  F1,309
3880:  MOVLB  3
3882:  CLRF   x10
3884:  CLRF   x0F
3886:  CLRF   x0E
3888:  MOVLW  82
388A:  MOVWF  x0D
388C:  MOVLB  0
388E:  CALL   224C
3892:  MOVFF  03,2F2
3896:  MOVFF  02,2F1
389A:  MOVFF  01,2F0
389E:  MOVFF  00,2EF
38A2:  MOVFF  EA,2F4
38A6:  MOVFF  E9,2F3
38AA:  MOVFF  EE,2F6
38AE:  MOVFF  ED,2F5
38B2:  MOVFF  EC,2F8
38B6:  MOVFF  EB,2F7
38BA:  MOVFF  F4,2FC
38BE:  MOVFF  F3,2FB
38C2:  MOVFF  F2,2FA
38C6:  MOVFF  F1,2F9
38CA:  MOVFF  03,300
38CE:  MOVFF  02,2FF
38D2:  MOVFF  01,2FE
38D6:  MOVFF  00,2FD
38DA:  GOTO   2582
38DE:  MOVFF  02,F0
38E2:  MOVFF  01,EF
....................              
....................             fprintf(usbSerial,"pos:%lu\tkont:%ld\r\n",ir_sens_pos_digital,kontrol); 
38E6:  MOVLW  E8
38E8:  MOVWF  FF6
38EA:  MOVLW  00
38EC:  MOVWF  FF7
38EE:  MOVLW  04
38F0:  MOVLB  2
38F2:  MOVWF  xF0
38F4:  MOVLB  0
38F6:  CALL   1A6E
38FA:  MOVLW  10
38FC:  MOVWF  FE9
38FE:  MOVFF  44,2F0
3902:  MOVFF  43,2EF
3906:  GOTO   272E
390A:  MOVLW  EF
390C:  MOVWF  FF6
390E:  MOVLW  00
3910:  MOVWF  FF7
3912:  MOVLW  06
3914:  MOVLB  2
3916:  MOVWF  xF0
3918:  MOVLB  0
391A:  CALL   1A6E
391E:  MOVLW  10
3920:  MOVWF  FE9
3922:  MOVFF  F0,2F0
3926:  MOVFF  EF,2EF
392A:  GOTO   27E4
392E:  MOVLW  0D
3930:  BTFSS  FA4.4
3932:  BRA    3930
3934:  MOVWF  F73
3936:  MOVLW  0A
3938:  BTFSS  FA4.4
393A:  BRA    3938
393C:  MOVWF  F73
....................  
....................             if (kontrol < 0) //// araba sola kaymýþ durumda sol motora güç ver 
393E:  BTFSS  xF0.7
3940:  BRA    39A0
....................             { 
....................                 solMhiz = ortHiz; 
3942:  MOVFF  4A,46
3946:  MOVFF  49,45
....................                 sagMhiz = ortHiz + kontrol; // kontrol negatif sayý 
394A:  MOVF   xEF,W
394C:  ADDWF  49,W
394E:  MOVWF  47
3950:  MOVF   xF0,W
3952:  ADDWFC 4A,W
3954:  MOVWF  48
....................  
....................                 if (sagMHiz < 0)sagMhiz = 0; 
3956:  BTFSS  48.7
3958:  BRA    395E
395A:  CLRF   48
395C:  CLRF   47
....................                 if (solMHiz < 0)solMhiz = 0; 
395E:  BTFSS  46.7
3960:  BRA    3966
3962:  CLRF   46
3964:  CLRF   45
....................                 if (sagMHiz > pwmMaxDeger)sagMhiz = pwmMaxDeger; 
3966:  BTFSC  48.7
3968:  BRA    3982
396A:  MOVF   48,W
396C:  SUBLW  01
396E:  BC    3982
3970:  XORLW  FF
3972:  BNZ   397A
3974:  MOVF   47,W
3976:  SUBLW  BC
3978:  BC    3982
397A:  MOVLW  02
397C:  MOVWF  48
397E:  MOVLW  BC
3980:  MOVWF  47
....................                 if (solMHiz > pwmMaxDeger)solMhiz = pwmMaxDeger; 
3982:  BTFSC  46.7
3984:  BRA    399E
3986:  MOVF   46,W
3988:  SUBLW  01
398A:  BC    399E
398C:  XORLW  FF
398E:  BNZ   3996
3990:  MOVF   45,W
3992:  SUBLW  BC
3994:  BC    399E
3996:  MOVLW  02
3998:  MOVWF  46
399A:  MOVLW  BC
399C:  MOVWF  45
....................  
....................             } else if (kontrol > 0) //araba saða kaymýþ sað motora güç ver  
399E:  BRA    3A24
39A0:  BTFSC  xF0.7
39A2:  BRA    3A0C
39A4:  MOVF   xF0,F
39A6:  BNZ   39AE
39A8:  MOVF   xEF,W
39AA:  SUBLW  00
39AC:  BC    3A0C
....................             { 
....................                  
....................                 solMhiz = ortHiz - kontrol; 
39AE:  MOVF   xEF,W
39B0:  SUBWF  49,W
39B2:  MOVWF  45
39B4:  MOVF   xF0,W
39B6:  SUBWFB 4A,W
39B8:  MOVWF  46
....................                 sagMhiz = ortHiz; 
39BA:  MOVFF  4A,48
39BE:  MOVFF  49,47
....................  
....................                 if (sagMHiz < 0)sagMhiz = 0; 
39C2:  BTFSS  48.7
39C4:  BRA    39CA
39C6:  CLRF   48
39C8:  CLRF   47
....................                 if (solMHiz < 0)solMhiz = 0; 
39CA:  BTFSS  46.7
39CC:  BRA    39D2
39CE:  CLRF   46
39D0:  CLRF   45
....................                 if (sagMHiz > pwmMaxDeger)sagMhiz = pwmMaxDeger; 
39D2:  BTFSC  48.7
39D4:  BRA    39EE
39D6:  MOVF   48,W
39D8:  SUBLW  01
39DA:  BC    39EE
39DC:  XORLW  FF
39DE:  BNZ   39E6
39E0:  MOVF   47,W
39E2:  SUBLW  BC
39E4:  BC    39EE
39E6:  MOVLW  02
39E8:  MOVWF  48
39EA:  MOVLW  BC
39EC:  MOVWF  47
....................                 if (solMHiz > pwmMaxDeger)solMhiz = pwmMaxDeger; 
39EE:  BTFSC  46.7
39F0:  BRA    3A0A
39F2:  MOVF   46,W
39F4:  SUBLW  01
39F6:  BC    3A0A
39F8:  XORLW  FF
39FA:  BNZ   3A02
39FC:  MOVF   45,W
39FE:  SUBLW  BC
3A00:  BC    3A0A
3A02:  MOVLW  02
3A04:  MOVWF  46
3A06:  MOVLW  BC
3A08:  MOVWF  45
....................                  
....................             } else if (kontrol == 0) // 
3A0A:  BRA    3A24
3A0C:  MOVF   xEF,F
3A0E:  BNZ   3A24
3A10:  MOVF   xF0,F
3A12:  BNZ   3A24
....................             { 
....................                 sagMhiz = ortHiz; 
3A14:  MOVFF  4A,48
3A18:  MOVFF  49,47
....................                 solMhiz = ortHiz; 
3A1C:  MOVFF  4A,46
3A20:  MOVFF  49,45
....................             } 
....................             if(sens_hepsi_siyah)    //Sekiz þeklinde çizilmiþ pist için... 
3A24:  BTFSS  4D.7
3A26:  BRA    3A38
....................             { 
....................                 sagMhiz = ortHiz; 
3A28:  MOVFF  4A,48
3A2C:  MOVFF  49,47
....................                 solMhiz = ortHiz; 
3A30:  MOVFF  4A,46
3A34:  MOVFF  49,45
....................             } 
....................             if(sens_hepsi_beyaz) { 
3A38:  BTFSS  4D.6
3A3A:  BRA    3A48
....................                 solMhiz=sagMhiz=0; 
3A3C:  CLRF   48
3A3E:  CLRF   47
3A40:  MOVFF  48,46
3A44:  MOVFF  47,45
....................             } 
....................              
....................             ileri_git(solMhiz,sagMhiz); //motorlara yeni hýz bilgisi gonderiliyor.... 
3A48:  MOVFF  46,02
3A4C:  MOVFF  45,01
3A50:  RRCF   02,F
3A52:  RRCF   01,F
3A54:  RRCF   02,F
3A56:  RRCF   01,F
3A58:  RRCF   02,F
3A5A:  MOVFF  01,F67
3A5E:  RRCF   02,F
3A60:  RRCF   02,W
3A62:  ANDLW  30
3A64:  MOVWF  00
3A66:  MOVF   F66,W
3A68:  ANDLW  CF
3A6A:  IORWF  00,W
3A6C:  MOVWF  F66
3A6E:  MOVFF  48,02
3A72:  MOVFF  47,01
3A76:  RRCF   02,F
3A78:  RRCF   01,F
3A7A:  RRCF   02,F
3A7C:  RRCF   01,F
3A7E:  RRCF   02,F
3A80:  MOVFF  01,FBE
3A84:  RRCF   02,F
3A86:  RRCF   02,W
3A88:  ANDLW  30
3A8A:  MOVWF  00
3A8C:  MOVF   FBD,W
3A8E:  ANDLW  CF
3A90:  IORWF  00,W
3A92:  MOVWF  FBD
....................              
....................             sureBul(ee_jeton_suresi_deger); //oyun suresi bitiþi kontrol ediliyor... 
3A94:  MOVFF  54,2EF
3A98:  GOTO   29DE
....................              
....................             son_hata = hata; 
3A9C:  MOVFF  EA,EC
3AA0:  MOVFF  E9,EB
....................             k_means_yeni_veri = FALSE; 
3AA4:  BCF    xF5.4
....................              
....................             if (input(DF_BUSY_PIN) && cizgiKontrolBaslat) 
3AA6:  BSF    F94.5
3AA8:  BTFSS  F82.5
3AAA:  BRA    3ABE
3AAC:  BTFSS  xF5.2
3AAE:  BRA    3ABE
....................             { 
....................                 mp3_play(ses_miniko); 
3AB0:  MOVLB  2
3AB2:  CLRF   xF5
3AB4:  MOVLW  01
3AB6:  MOVWF  xF4
3AB8:  MOVLB  0
3ABA:  CALL   0916
....................             } 
....................  
....................             if((millis()-time_ort_hiz>100) && !soft_kalkis)   //soft kalkýþ için hýzýn arttýrýlmasý 
3ABE:  MOVF   xF9,W
3AC0:  SUBWF  1A,W
3AC2:  MOVLB  2
3AC4:  MOVWF  xEF
3AC6:  MOVLB  0
3AC8:  MOVF   xFA,W
3ACA:  SUBWFB 1B,W
3ACC:  MOVLB  2
3ACE:  MOVWF  xF0
3AD0:  MOVLW  00
3AD2:  SUBWFB 1C,W
3AD4:  MOVWF  xF1
3AD6:  MOVLW  00
3AD8:  SUBWFB 1D,W
3ADA:  MOVWF  xF2
3ADC:  MOVF   xF2,F
3ADE:  BNZ   3AEE
3AE0:  MOVF   xF1,F
3AE2:  BNZ   3AEE
3AE4:  MOVF   xF0,F
3AE6:  BNZ   3AEE
3AE8:  MOVF   xEF,W
3AEA:  SUBLW  64
3AEC:  BC    3B1A
3AEE:  BTFSC  4D.0
3AF0:  BRA    3B1A
....................             { 
....................                 ortHiz+=10; 
3AF2:  MOVLW  0A
3AF4:  ADDWF  49,F
3AF6:  MOVLW  00
3AF8:  ADDWFC 4A,F
....................                  
....................                 if(ortHiz>=ortHiz_max){ 
3AFA:  MOVF   4C,W
3AFC:  SUBWF  4A,W
3AFE:  BNC   3B12
3B00:  BNZ   3B08
3B02:  MOVF   4B,W
3B04:  SUBWF  49,W
3B06:  BNC   3B12
....................                     ortHiz=ortHiz_max; 
3B08:  MOVFF  4C,4A
3B0C:  MOVFF  4B,49
....................                     soft_kalkis=TRUE; 
3B10:  BSF    4D.0
....................                 } 
....................                 time_ort_hiz=millis(); 
3B12:  MOVFF  1B,FA
3B16:  MOVFF  1A,F9
3B1A:  MOVLB  0
....................             } 
....................              
....................             /* 
....................             //fprintf(usbSerial, "t:%Lu\r\n", millis() - time_sens_deger_goster); 
....................             //time_sens_deger_goster = millis(); 
....................             */ 
....................              
....................         }//çizgi kontrol 
....................  
....................         if(((millis()-time_aku_ornek)>50))//&& !cizgiKontrolBaslat) 
3B1C:  MOVF   50,W
3B1E:  SUBWF  1A,W
3B20:  MOVLB  2
3B22:  MOVWF  xEF
3B24:  MOVF   51,W
3B26:  SUBWFB 1B,W
3B28:  MOVWF  xF0
3B2A:  MOVF   52,W
3B2C:  SUBWFB 1C,W
3B2E:  MOVWF  xF1
3B30:  MOVF   53,W
3B32:  SUBWFB 1D,W
3B34:  MOVWF  xF2
3B36:  MOVF   xF2,F
3B38:  BNZ   3B48
3B3A:  MOVF   xF1,F
3B3C:  BNZ   3B48
3B3E:  MOVF   xF0,F
3B40:  BNZ   3B48
3B42:  MOVF   xEF,W
3B44:  SUBLW  32
3B46:  BC    3B70
....................         { 
....................             v_aku_oku(aku_ornek_say++); 
3B48:  MOVF   4E,W
3B4A:  INCF   4E,F
3B4C:  MOVWF  xEF
3B4E:  MOVWF  xF0
3B50:  MOVLB  0
3B52:  GOTO   2ED0
....................     
....................             if(aku_ornek_say>19){ 
3B56:  MOVF   4E,W
3B58:  SUBLW  13
3B5A:  BC    3B5E
....................                 aku_ornek_say=0; 
3B5C:  CLRF   4E
....................             } 
....................             
....................             time_aku_ornek=millis(); 
3B5E:  MOVFF  1D,53
3B62:  MOVFF  1C,52
3B66:  MOVFF  1B,51
3B6A:  MOVFF  1A,50
3B6E:  MOVLB  2
....................         } 
....................          
....................         if(((millis()-time_aku_sarj_seslendir)>150000LL))// && !cizgiKontrolBaslat)  
3B70:  MOVF   3E,W
3B72:  SUBWF  1A,W
3B74:  MOVWF  xEF
3B76:  MOVF   3F,W
3B78:  SUBWFB 1B,W
3B7A:  MOVWF  xF0
3B7C:  MOVF   40,W
3B7E:  SUBWFB 1C,W
3B80:  MOVWF  xF1
3B82:  MOVF   41,W
3B84:  SUBWFB 1D,W
3B86:  MOVWF  xF2
3B88:  MOVF   xF2,F
3B8A:  BNZ   3BA6
3B8C:  MOVF   xF1,W
3B8E:  SUBLW  01
3B90:  BC    3BE6
3B92:  XORLW  FF
3B94:  BNZ   3BA6
3B96:  MOVF   xF0,W
3B98:  SUBLW  48
3B9A:  BC    3BE6
3B9C:  XORLW  FF
3B9E:  BNZ   3BA6
3BA0:  MOVF   xEF,W
3BA2:  SUBLW  F0
3BA4:  BC    3BE6
....................             // 5 dakikada bir ve tren duruyorken 
....................         {   
....................             if((solMhiz==0 && sagMhiz==0) && rfKontrol){ 
3BA6:  MOVF   45,F
3BA8:  BNZ   3BD6
3BAA:  MOVF   46,F
3BAC:  BNZ   3BD6
3BAE:  MOVF   47,F
3BB0:  BNZ   3BD6
3BB2:  MOVF   48,F
3BB4:  BNZ   3BD6
3BB6:  MOVLB  0
3BB8:  BTFSC  xF5.0
3BBA:  BRA    3BC0
3BBC:  MOVLB  2
3BBE:  BRA    3BD6
....................                  aku_sarj_seslendir(v_aku); 
3BC0:  MOVFF  5C,2F2
3BC4:  MOVFF  5B,2F1
3BC8:  MOVFF  5A,2F0
3BCC:  MOVFF  59,2EF
3BD0:  GOTO   3030
3BD4:  MOVLB  2
....................             } 
....................                 
....................              
....................             time_aku_sarj_seslendir=millis(); 
3BD6:  MOVFF  1D,41
3BDA:  MOVFF  1C,40
3BDE:  MOVFF  1B,3F
3BE2:  MOVFF  1A,3E
....................         } 
3BE6:  MOVLB  0
3BE8:  BRA    3738
.................... //         
....................         //test_donanim(); 
....................         
....................     }//while loop 
....................  
.................... }//main 
....................  
3BEA:  SLEEP 
.................... //////// 
....................  
.................... unsigned int16 agirlikliPosGetir(char ortDigital) { 
*
2104:  MOVLB  2
2106:  CLRF   xF4
2108:  CLRF   xF3
210A:  CLRF   xF2
210C:  CLRF   xF1
210E:  CLRF   xF6
2110:  CLRF   xF5
.................... #define AGIRLIK_KATSAYI 500 
....................     //çarpma yada bölme iþleminde uygun  deðiþken tipi belirlenmezse  inerrupt larýn deisable edildiðine dair uyarý verir..... 
....................     unsigned int8 x; 
....................     unsigned int32 topAgirlik_int = 0; 
....................     unsigned int16 toplam_int = 0; 
....................  
....................     for (x = 0; x < SENS_SAYISI; x++) { 
2112:  CLRF   xF0
2114:  MOVF   xF0,W
2116:  SUBLW  07
2118:  BNC   21E4
....................  
....................         if (ortDigital == ORTALAMA_DEGER) { 
211A:  MOVF   xEF,W
211C:  SUBLW  4F
211E:  BNZ   219C
....................  
....................             topAgirlik_int += _mul(_mul((unsigned int16) ir_sens_ort_deger[x], x), AGIRLIK_KATSAYI); 
2120:  BCF    FD8.0
2122:  RLCF   xF0,W
2124:  CLRF   03
2126:  ADDLW  70
2128:  MOVWF  FE9
212A:  MOVLW  00
212C:  ADDWFC 03,W
212E:  MOVWF  FEA
2130:  MOVFF  FEC,2FC
2134:  MOVF   FED,F
2136:  MOVFF  FEF,2FB
213A:  CLRF   xFE
213C:  MOVFF  2F0,2FD
2140:  MOVLB  0
2142:  RCALL  20A0
2144:  MOVF   01,W
2146:  MOVFF  03,2FA
214A:  MOVFF  02,2F9
214E:  MOVFF  01,2F8
2152:  MOVFF  00,2F7
2156:  MOVFF  01,2FC
215A:  MOVFF  00,2FB
215E:  MOVLW  01
2160:  MOVLB  2
2162:  MOVWF  xFE
2164:  MOVLW  F4
2166:  MOVWF  xFD
2168:  MOVLB  0
216A:  RCALL  20A0
216C:  MOVF   00,W
216E:  MOVLB  2
2170:  ADDWF  xF1,F
2172:  MOVF   01,W
2174:  ADDWFC xF2,F
2176:  MOVF   02,W
2178:  ADDWFC xF3,F
217A:  MOVF   03,W
217C:  ADDWFC xF4,F
....................             toplam_int += ir_sens_ort_deger[x]; 
217E:  BCF    FD8.0
2180:  RLCF   xF0,W
2182:  CLRF   03
2184:  ADDLW  70
2186:  MOVWF  FE9
2188:  MOVLW  00
218A:  ADDWFC 03,W
218C:  MOVWF  FEA
218E:  MOVFF  FEC,03
2192:  MOVF   FED,F
2194:  MOVF   FEF,W
2196:  ADDWF  xF5,F
2198:  MOVF   03,W
219A:  ADDWFC xF6,F
....................         } 
....................  
....................         if (ortDigital == DIGITAL_DEGER) { 
219C:  MOVF   xEF,W
219E:  SUBLW  42
21A0:  BNZ   21E0
....................             if (bit_test(lfr_led, x)) { 
21A2:  MOVFF  42,00
21A6:  MOVF   xF0,W
21A8:  MOVWF  01
21AA:  BZ    21B4
21AC:  BCF    FD8.0
21AE:  RRCF   00,F
21B0:  DECFSZ 01,F
21B2:  BRA    21AC
21B4:  BTFSS  00.0
21B6:  BRA    21E0
....................                 topAgirlik_int += 1 * (x * AGIRLIK_KATSAYI); 
21B8:  CLRF   xF8
21BA:  MOVFF  2F0,2F7
21BE:  MOVLW  01
21C0:  MOVWF  xFA
21C2:  MOVLW  F4
21C4:  MOVWF  xF9
21C6:  MOVLB  0
21C8:  BRA    20E0
21CA:  MOVF   01,W
21CC:  MOVLB  2
21CE:  ADDWF  xF1,F
21D0:  MOVF   02,W
21D2:  ADDWFC xF2,F
21D4:  MOVLW  00
21D6:  ADDWFC xF3,F
21D8:  ADDWFC xF4,F
....................                 toplam_int++; 
21DA:  INCF   xF5,F
21DC:  BTFSC  FD8.2
21DE:  INCF   xF6,F
....................             } 
....................  
....................             //topAgirlik+=_mul(_mul(ir_sens_sayisal_deger[x],x),AGIRLIK_KATSAYI); 
....................         } 
21E0:  INCF   xF0,F
21E2:  BRA    2114
....................         //topAgirlik+=(sensorDeger[.x])*(x*500); 
....................         //toplam+= sensorDeger[x]; 
....................  
....................     } 
....................     return (unsigned int16) (topAgirlik_int / toplam_int); 
21E4:  BCF    FD8.1
21E6:  MOVFF  2F4,300
21EA:  MOVFF  2F3,2FF
21EE:  MOVFF  2F2,2FE
21F2:  MOVFF  2F1,2FD
21F6:  MOVLB  3
21F8:  CLRF   x04
21FA:  CLRF   x03
21FC:  MOVFF  2F6,302
2200:  MOVFF  2F5,301
2204:  MOVLB  0
2206:  CALL   166A
220A:  MOVFF  01,02
220E:  MOVFF  00,01
2212:  GOTO   37F8 (RETURN)
....................  
....................     //fprintf(usbSerial,"A:%Lu\tT:%Lu\t pos=%Lu \r\n",topAgirlik,toplam,sonDeger); 
....................  
....................  
.................... } 
....................  
.................... void ir_sens_adc_oku(BOOLEAN e_on) { 
*
00FC:  MOVLB  3
00FE:  CLRF   x1C
0100:  CLRF   x1B
0102:  CLRF   x1D
....................     unsigned int16 ir_adc = 0; 
....................     int i = 0; 
....................  
....................     for (i = 0; i < 8; i++) { 
0104:  CLRF   x1D
0106:  MOVF   x1D,W
0108:  SUBLW  07
010A:  BNC   0154
....................         set_adc_channel(i); 
010C:  RLCF   x1D,W
010E:  MOVWF  00
0110:  RLCF   00,F
0112:  MOVLW  FC
0114:  ANDWF  00,F
0116:  MOVF   FC2,W
0118:  ANDLW  83
011A:  IORWF  00,W
011C:  MOVWF  FC2
....................         delay_us(20); 
011E:  MOVLW  6A
0120:  MOVWF  00
0122:  DECFSZ 00,F
0124:  BRA    0122
0126:  NOP   
....................         ir_adc = read_adc(); 
0128:  BSF    FC2.1
012A:  BTFSC  FC2.1
012C:  BRA    012A
012E:  MOVFF  FC3,31B
0132:  MOVFF  FC4,31C
....................         ir_sens_adc_ham_deger[i] = ir_adc; 
0136:  BCF    FD8.0
0138:  RLCF   x1D,W
013A:  CLRF   03
013C:  ADDLW  60
013E:  MOVWF  FE9
0140:  MOVLW  00
0142:  ADDWFC 03,W
0144:  MOVWF  FEA
0146:  MOVFF  31C,FEC
014A:  MOVF   FED,F
014C:  MOVFF  31B,FEF
0150:  INCF   x1D,F
0152:  BRA    0106
....................     } 
....................  
....................     if (e_on == 1) { 
0154:  DECFSZ x1A,W
0156:  BRA    0198
....................  
....................         ir_sens_ort_deger_e_on[0] = ir_sens_adc_ham_deger[0]; 
0158:  MOVFF  61,81
015C:  MOVFF  60,80
....................         ir_sens_ort_deger_e_on[1] = ir_sens_adc_ham_deger[1]; 
0160:  MOVFF  63,83
0164:  MOVFF  62,82
....................         ir_sens_ort_deger_e_on[2] = ir_sens_adc_ham_deger[2]; 
0168:  MOVFF  65,85
016C:  MOVFF  64,84
....................         ir_sens_ort_deger_e_on[3] = ir_sens_adc_ham_deger[3]; 
0170:  MOVFF  67,87
0174:  MOVFF  66,86
....................         ir_sens_ort_deger_e_on[4] = ir_sens_adc_ham_deger[4]; 
0178:  MOVFF  69,89
017C:  MOVFF  68,88
....................         ir_sens_ort_deger_e_on[5] = ir_sens_adc_ham_deger[5]; 
0180:  MOVFF  6B,8B
0184:  MOVFF  6A,8A
....................         ir_sens_ort_deger_e_on[6] = ir_sens_adc_ham_deger[6]; 
0188:  MOVFF  6D,8D
018C:  MOVFF  6C,8C
....................         ir_sens_ort_deger_e_on[7] = ir_sens_adc_ham_deger[7]; 
0190:  MOVFF  6F,8F
0194:  MOVFF  6E,8E
....................     } 
....................     if (e_on == 0) { 
0198:  MOVF   x1A,F
019A:  BNZ   01DC
....................         ir_sens_ort_deger_e_off[0] = ir_sens_adc_ham_deger[0]; 
019C:  MOVFF  61,91
01A0:  MOVFF  60,90
....................         ir_sens_ort_deger_e_off[1] = ir_sens_adc_ham_deger[1]; 
01A4:  MOVFF  63,93
01A8:  MOVFF  62,92
....................         ir_sens_ort_deger_e_off[2] = ir_sens_adc_ham_deger[2]; 
01AC:  MOVFF  65,95
01B0:  MOVFF  64,94
....................         ir_sens_ort_deger_e_off[3] = ir_sens_adc_ham_deger[3]; 
01B4:  MOVFF  67,97
01B8:  MOVFF  66,96
....................         ir_sens_ort_deger_e_off[4] = ir_sens_adc_ham_deger[4]; 
01BC:  MOVFF  69,99
01C0:  MOVFF  68,98
....................         ir_sens_ort_deger_e_off[5] = ir_sens_adc_ham_deger[5]; 
01C4:  MOVFF  6B,9B
01C8:  MOVFF  6A,9A
....................         ir_sens_ort_deger_e_off[6] = ir_sens_adc_ham_deger[6]; 
01CC:  MOVFF  6D,9D
01D0:  MOVFF  6C,9C
....................         ir_sens_ort_deger_e_off[7] = ir_sens_adc_ham_deger[7]; 
01D4:  MOVFF  6F,9F
01D8:  MOVFF  6E,9E
....................     } 
....................  
....................  
....................     hareketli_ort_orn_say++; 
01DC:  INCF   5F,F
01DE:  MOVLB  0
01E0:  RETURN 0
....................  
.................... } 
....................  
.................... void millis_kurulum() { 
....................  
....................     setup_timer_0(T0_INTERNAl | T0_8_BIT | T0_DIV_64);    //32 idi  
*
05E0:  MOVLW  C5
05E2:  MOVWF  FD5
....................     set_timer0(0x05); //1000uS 64MHZ  T0_DIV_64 ile 1mS   
05E4:  CLRF   FD7
05E6:  MOVLW  05
05E8:  MOVWF  FD6
....................                       //0x05, T0_8_BIT | T0_DIV_64 -> 500uS son hesapta, kontrol edilecek. uygulamada  
....................                       // 17.01.2020 : T0_8_BIT | T0_DIV_64 500uS çýkýyor. 
....................          
....................     /* set_timer0(0xC0);            //1000uS 16MHZ 
....................  
....................     //    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
....................     //    set_timer1(0xFB1D);   //64285 1000uS div_8 ile kesme    
....................     //    setup_timer_3(T3_INTERNAL|T3_DIV_BY_8); 
....................     //    set_timer3(0xFB1D); 
....................     //    clear_interrupt(INT_TIMER3); 
....................     //    enable_interrupts(INT_TIMER3);  
....................     //    disable_interrupts(INT_TIMER3); 
....................     //    enable_interrupts(PERIPH);- 
....................     //    enable_interrupts(INT_TIMER1); 
....................      */ 
....................  
....................     enable_interrupts(INT_TIMER0); 
05EA:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
05EC:  MOVLW  C0
05EE:  IORWF  FF2,F
05F0:  GOTO   35C2 (RETURN)
....................  
.................... } 
....................  
.................... #INT_TIMER0 //HIGH                    //Timer0 Kesmesi 
....................  
.................... void Timer0_int() { 
....................     // set_timer0(0x43);            //1000uS 16Mhz 
....................     // set_timer0(0x82);            //1000uS 32MHZ 
....................      
....................     set_timer0(0x05); //1000uS 64MHZ  // 0x05:500uSson hesapta kokontorl edilecek. uygulamada  
*
045C:  CLRF   FD7
045E:  MOVLW  05
0460:  MOVWF  FD6
....................      
....................     // set_timer0(0xC0);            //1000uS 16MHZ 
....................     // output_toggle(clock); 
....................  
....................     if (sens_emiter_on_off == 0) { 
0462:  MOVF   xE8,F
0464:  BNZ   046A
....................         ir_led_off(); // Anotlara +5V ver ve 1mS sonra on dðeri oku 
0466:  BCF    F94.3
0468:  BSF    F8B.3
....................     } 
....................     if (sens_emiter_on_off == 1) { 
046A:  DECFSZ xE8,W
046C:  BRA    0476
....................         ir_sens_adc_oku(EMITTER_OFF); // off deðeri oku 
046E:  MOVLB  3
0470:  CLRF   x1A
0472:  MOVLB  0
0474:  RCALL  00FC
....................     } 
....................     if (sens_emiter_on_off == 2) { 
0476:  MOVF   xE8,W
0478:  SUBLW  02
047A:  BNZ   0480
....................         ir_led_on(); 
047C:  BCF    F94.3
047E:  BCF    F8B.3
....................     } 
....................     if (sens_emiter_on_off == 3) { 
0480:  MOVF   xE8,W
0482:  SUBLW  03
0484:  BNZ   0494
....................  
....................         ir_sens_adc_oku(EMITTER_ON); // on deðeri oku 
0486:  MOVLW  01
0488:  MOVLB  3
048A:  MOVWF  x1A
048C:  MOVLB  0
048E:  RCALL  00FC
....................         sens_yeni_deger = 1; 
0490:  BSF    4D.5
....................  
....................         //sens_cizgi_durum_getir();       // sensör çizgi durum güncelle   
....................         k_means_veri_havuzu_olustur(); 
0492:  BRA    01E2
....................  
....................         // ir_led_off();                       //Anotlar dan +5V kes ve 1mS sonra aff deðeri oku... 
....................     } 
....................  
....................     sens_emiter_on_off++; 
0494:  INCF   xE8,F
....................     if (sens_emiter_on_off > 3) sens_emiter_on_off = 0; 
0496:  MOVF   xE8,W
0498:  SUBLW  03
049A:  BC    049E
049C:  CLRF   xE8
....................  
....................     timerIntSay++; 
049E:  MOVLW  01
04A0:  ADDWF  1A,F
04A2:  BTFSC  FD8.0
04A4:  INCF   1B,F
04A6:  BTFSC  FD8.2
04A8:  INCF   1C,F
04AA:  BTFSC  FD8.2
04AC:  INCF   1D,F
....................  
....................     clear_interrupt(INT_TIMER0); 
04AE:  BCF    FF2.2
....................      
04B0:  BCF    FF2.2
04B2:  GOTO   0070
.................... }// 
....................  
.................... void sens_led_goster() { 
*
1FB2:  MOVLB  2
1FB4:  CLRF   xF0
1FB6:  CLRF   xF1
....................  
....................     int i, say_siyah = 0, say_beyaz = 0; 
....................  
....................     for (i = 0; i < SENS_SAYISI; i++) { 
1FB8:  CLRF   xEF
1FBA:  MOVF   xEF,W
1FBC:  SUBLW  07
1FBE:  BNC   206A
....................  
....................         if (ir_sens_ort_deger[i] < baslangic_esik_ort_deger) ++say_siyah;  
1FC0:  BCF    FD8.0
1FC2:  RLCF   xEF,W
1FC4:  CLRF   03
1FC6:  ADDLW  70
1FC8:  MOVWF  FE9
1FCA:  MOVLW  00
1FCC:  ADDWFC 03,W
1FCE:  MOVWF  FEA
1FD0:  MOVFF  FEC,2F3
1FD4:  MOVF   FED,F
1FD6:  MOVFF  FEF,2F2
1FDA:  MOVF   xF3,W
1FDC:  SUBWF  xE2,W
1FDE:  BNC   1FEA
1FE0:  BNZ   1FE8
1FE2:  MOVF   xE1,W
1FE4:  SUBWF  xF2,W
1FE6:  BC    1FEA
1FE8:  INCF   xF0,F
....................         if (ir_sens_ort_deger[i] > baslangic_esik_ort_deger) ++say_beyaz; 
1FEA:  BCF    FD8.0
1FEC:  RLCF   xEF,W
1FEE:  CLRF   03
1FF0:  ADDLW  70
1FF2:  MOVWF  FE9
1FF4:  MOVLW  00
1FF6:  ADDWFC 03,W
1FF8:  MOVWF  FEA
1FFA:  MOVFF  FEC,2F3
1FFE:  MOVF   FED,F
2000:  MOVFF  FEF,2F2
2004:  MOVF   xE2,W
2006:  SUBWF  xF3,W
2008:  BNC   2014
200A:  BNZ   2012
200C:  MOVF   xF2,W
200E:  SUBWF  xE1,W
2010:  BC    2014
2012:  INCF   xF1,F
....................  
....................         if (ir_sens_sayisal_deger[i] == 1) { 
2014:  CLRF   03
2016:  MOVF   xEF,W
2018:  ADDLW  E0
201A:  MOVWF  FE9
201C:  MOVLW  00
201E:  ADDWFC 03,W
2020:  MOVWF  FEA
2022:  DECFSZ FEF,W
2024:  BRA    203C
....................             bit_set(lfr_led, i); 
2026:  MOVLW  01
2028:  MOVWF  00
202A:  MOVF   xEF,W
202C:  MOVWF  01
202E:  BZ    2038
2030:  BCF    FD8.0
2032:  RLCF   00,F
2034:  DECFSZ 01,F
2036:  BRA    2030
2038:  MOVF   00,W
203A:  IORWF  42,F
....................            // lfr_led_goster(lfr_led); 
....................         } 
....................         if (ir_sens_sayisal_deger[i] == 0) { 
203C:  CLRF   03
203E:  MOVF   xEF,W
2040:  ADDLW  E0
2042:  MOVWF  FE9
2044:  MOVLW  00
2046:  ADDWFC 03,W
2048:  MOVWF  FEA
204A:  MOVF   FEF,F
204C:  BNZ   2066
....................  
....................             bit_clear(lfr_led, i); 
204E:  MOVLW  01
2050:  MOVWF  00
2052:  MOVF   xEF,W
2054:  MOVWF  01
2056:  BZ    2060
2058:  BCF    FD8.0
205A:  RLCF   00,F
205C:  DECFSZ 01,F
205E:  BRA    2058
2060:  MOVF   00,W
2062:  XORLW  FF
2064:  ANDWF  42,F
....................             // lfr_led_goster(lfr_led); 
....................         } 
2066:  INCF   xEF,F
2068:  BRA    1FBA
....................     } 
....................      
....................     if (say_siyah >= 8) { 
206A:  MOVF   xF0,W
206C:  SUBLW  07
206E:  BC    2074
....................         sens_hepsi_siyah = 1; 
2070:  BSF    4D.7
....................     } else sens_hepsi_siyah = 0; 
2072:  BRA    2076
2074:  BCF    4D.7
....................  
....................     if (say_beyaz >= 8 ) { 
2076:  MOVF   xF1,W
2078:  SUBLW  07
207A:  BC    2080
....................         sens_hepsi_beyaz = 1; 
207C:  BSF    4D.6
....................     } else sens_hepsi_beyaz = 0; 
207E:  BRA    2082
2080:  BCF    4D.6
....................  
....................     if (sens_hepsi_siyah) { 
2082:  BTFSS  4D.7
2084:  BRA    2088
....................         lfr_led = 0xFF; 
2086:  SETF   42
....................        // lfr_led_goster(lfr_led); 
....................     } 
....................     if (sens_hepsi_beyaz) { 
2088:  BTFSS  4D.6
208A:  BRA    208E
....................         lfr_led = 0x00; 
208C:  CLRF   42
....................         //lfr_led_goster(lfr_led); 
....................     } 
....................      
....................     lfr_led_goster(lfr_led); 
208E:  CLRF   xF3
2090:  MOVFF  42,2F2
2094:  MOVLW  08
2096:  MOVWF  xF4
2098:  MOVLB  0
209A:  CALL   08B0
209E:  RETURN 0
....................      
.................... }// 
....................  
.................... //unsigned int16 hareketli_ortalama(int ornek_say, unsigned int16 an_deger, unsigned int16 *moving_dizi) { 
.................... //    int x = 0; 
.................... //    unsigned int16 ort = 0, toplam = 0; 
.................... //    ; 
.................... //    int payda = 0; 
.................... // 
.................... //    if (ornek_sayisi < ORNEK_SAYISI) { 
.................... //        moving_dizi[ornek_say] = an_deger; // filtre ilk degerlerde pasif 
.................... //        ort = an_deger; 
.................... //    } else { // filtre aktif. 
.................... // 
.................... //        for (x = 0; x < ORNEK_SAYISI; x++) { 
.................... // 
.................... //            if (moving_dizi[x] != 0) payda++; // sýfýr sayýsýna göre payda deðerini belrile 
.................... //            toplam += moving_dizi[x]; 
.................... //        } 
.................... //        if (payda == 0) return an_deger; 
.................... // 
.................... //        ort = toplam / payda; 
.................... // 
.................... //        for (x = 1; x < ORNEK_SAYISI - 1; x++) // en eski deðeri çýkar ortalamaya yeni deðeri ekle. 
.................... //            moving_dizi[x - 1] = moving_dizi[x]; 
.................... // 
.................... //        moving_dizi[ORNEK_SAYISI - 1] = an_deger; 
.................... //    } 
.................... //    return ort; 
.................... //} 
....................  
.................... void test_donanim() { 
....................      
....................     int8 led_say = 0; 
....................      
....................     if (millis() - time_led > 250) { 
....................  
....................         if (led_say >= 7) { 
....................  
....................             led_say = 0; 
....................             lfr_led = 0; 
....................  
....................             //bip_rf_var(); 
....................             output_toggle(FAN_PIN); 
....................             // output_toggle(IR_LED_ANOT_PIN); 
....................  
....................             //fprintf(usbSerial,"Vaku(24V)=%f V\r\n",v_aku); 
....................             //v_aku_oku(); 
....................  
....................             //debug_ir_sens(ORT_DEGER, GERILIM_VAR); 
....................         } 
....................  
....................  
....................         if (led_say == 2) { 
....................             output_toggle(LED2_PIN); 
....................         } 
....................  
....................         if (led_say == 6) { 
....................             //output_toggle(LED1_PIN); 
....................         } 
....................  
....................         led_say++; 
....................         // bit_set(lfr_led,led_say); 
....................         //lfr_led_goster(lfr_led); 
....................  
....................         time_led = millis(); 
....................     } 
.................... } 
....................  
.................... void bipp(unsigned int16 sure, int sayi, long pin) { 
*
0522:  MOVLB  2
0524:  CLRF   xF9
....................     int a = 0; 
....................     for (a = 0; a < sayi; a++) { 
0526:  CLRF   xF9
0528:  MOVF   xF6,W
052A:  SUBWF  xF9,W
052C:  BC    05DC
....................  
....................         output_high(pin); 
052E:  MOVFF  2F7,2FA
0532:  MOVLW  01
0534:  MOVWF  xFB
0536:  MOVLW  0F
0538:  MOVWF  xFD
053A:  MOVLW  89
053C:  MOVWF  xFC
053E:  MOVLB  0
0540:  RCALL  04B6
0542:  MOVFF  2F7,2FA
0546:  MOVLB  2
0548:  CLRF   xFB
054A:  MOVLW  0F
054C:  MOVWF  xFD
054E:  MOVLW  92
0550:  MOVWF  xFC
0552:  MOVLB  0
0554:  RCALL  04B6
....................         delay_ms(sure / 2); 
0556:  BCF    FD8.0
0558:  MOVLB  2
055A:  RRCF   xF5,W
055C:  MOVWF  xFB
055E:  RRCF   xF4,W
0560:  MOVWF  xFA
0562:  MOVFF  2FB,2FC
0566:  INCF   xFC,F
0568:  DECF   xFC,F
056A:  BTFSC  FD8.2
056C:  BRA    057A
056E:  MOVLB  3
0570:  SETF   x0A
0572:  MOVLB  0
0574:  RCALL  04F8
0576:  MOVLB  2
0578:  BRA    0568
057A:  MOVFF  2FA,30A
057E:  MOVLB  0
0580:  RCALL  04F8
....................         output_low(pin); 
0582:  MOVFF  2F7,2FA
0586:  MOVLB  2
0588:  CLRF   xFB
058A:  MOVLW  0F
058C:  MOVWF  xFD
058E:  MOVLW  89
0590:  MOVWF  xFC
0592:  MOVLB  0
0594:  RCALL  04B6
0596:  MOVFF  2F7,2FA
059A:  MOVLB  2
059C:  CLRF   xFB
059E:  MOVLW  0F
05A0:  MOVWF  xFD
05A2:  MOVLW  92
05A4:  MOVWF  xFC
05A6:  MOVLB  0
05A8:  RCALL  04B6
....................         delay_ms(sure / 2); 
05AA:  BCF    FD8.0
05AC:  MOVLB  2
05AE:  RRCF   xF5,W
05B0:  MOVWF  xFB
05B2:  RRCF   xF4,W
05B4:  MOVWF  xFA
05B6:  MOVFF  2FB,2FC
05BA:  INCF   xFC,F
05BC:  DECF   xFC,F
05BE:  BTFSC  FD8.2
05C0:  BRA    05CE
05C2:  MOVLB  3
05C4:  SETF   x0A
05C6:  MOVLB  0
05C8:  RCALL  04F8
05CA:  MOVLB  2
05CC:  BRA    05BC
05CE:  MOVFF  2FA,30A
05D2:  MOVLB  0
05D4:  RCALL  04F8
05D6:  MOVLB  2
05D8:  INCF   xF9,F
05DA:  BRA    0528
....................     } 
05DC:  MOVLB  0
05DE:  RETURN 0
.................... }// 
....................  
.................... void delay_m_us(unsigned int16 n) { 
....................  
....................     for (; n != 0; n--) 
*
05F4:  MOVLB  2
05F6:  MOVF   xEF,F
05F8:  BNZ   05FE
05FA:  MOVF   xF0,F
05FC:  BZ    0614
....................         delay_us(1000); 
05FE:  MOVLW  01
0600:  MOVLB  3
0602:  MOVWF  x0A
0604:  MOVLB  0
0606:  RCALL  04F8
0608:  MOVLB  2
060A:  MOVF   xEF,W
060C:  BTFSC  FD8.2
060E:  DECF   xF0,F
0610:  DECF   xEF,F
0612:  BRA    05F6
0614:  MOVLB  0
0616:  GOTO   35D0 (RETURN)
.................... } 
....................  
....................  
....................  
.................... v_aku_oku(int orn_say) 
.................... { 
....................     set_adc_channel(AN_CHANNEL_AKU); //0,1,2,....16.. 
*
2ED0:  MOVLW  20
2ED2:  MOVWF  01
2ED4:  MOVF   FC2,W
2ED6:  ANDLW  83
2ED8:  IORWF  01,W
2EDA:  MOVWF  FC2
....................     delay_us(50); 
2EDC:  MOVLW  32
2EDE:  MOVLB  2
2EE0:  MOVWF  xF1
2EE2:  MOVLB  0
2EE4:  RCALL  2EAC
....................     aku_adc_toplam+= read_adc(); 
2EE6:  BSF    FC2.1
2EE8:  BTFSC  FC2.1
2EEA:  BRA    2EE8
2EEC:  MOVF   FC3,W
2EEE:  ADDWF  5D,F
2EF0:  MOVF   FC4,W
2EF2:  ADDWFC 5E,F
....................     delay_us(50); 
2EF4:  MOVLW  32
2EF6:  MOVLB  2
2EF8:  MOVWF  xF1
2EFA:  MOVLB  0
2EFC:  RCALL  2EAC
....................      
....................     if(orn_say>=19){ 
2EFE:  MOVLB  2
2F00:  MOVF   xF0,W
2F02:  SUBLW  12
2F04:  BC    2FB0
....................        //aku_adc_toplam=aku_adc_toplam>>4; 
....................         aku_adc_toplam=(unsigned int16 )(aku_adc_toplam/20); 
2F06:  MOVFF  5E,2F7
2F0A:  MOVFF  5D,2F6
2F0E:  CLRF   xF9
2F10:  MOVLW  14
2F12:  MOVWF  xF8
2F14:  MOVLB  0
2F16:  CALL   09CE
2F1A:  MOVFF  02,5E
2F1E:  MOVFF  01,5D
....................         //v_aku_deger=(float)(aku_adc_toplam*(5.0/1024.0)*6.0); //  Vadc=Vaku*(R1/(R1+R2)--> Vaku=Vadc*((R1+R2)/R1)), (R1+R2)/R1=(10+50)Kohm/10Kohm=6 
....................         v_aku=(float)(((float)(aku_adc_toplam))*(0.004792948)); // ADC çözünürlek deðeri 5/1024 yerine ölçü aleti ile yapýlan ölçümler sonucu  
2F22:  MOVFF  5E,30A
2F26:  MOVFF  5D,309
2F2A:  CALL   2216
2F2E:  MOVFF  03,2F4
2F32:  MOVFF  02,2F3
2F36:  MOVFF  01,2F2
2F3A:  MOVFF  00,2F1
2F3E:  MOVFF  03,30C
2F42:  MOVFF  02,30B
2F46:  MOVFF  01,30A
2F4A:  MOVFF  00,309
2F4E:  MOVLW  29
2F50:  MOVLB  3
2F52:  MOVWF  x10
2F54:  MOVLW  0E
2F56:  MOVWF  x0F
2F58:  MOVLW  1D
2F5A:  MOVWF  x0E
2F5C:  MOVLW  77
2F5E:  MOVWF  x0D
2F60:  MOVLB  0
2F62:  CALL   23FA
2F66:  MOVFF  03,5C
2F6A:  MOVFF  02,5B
2F6E:  MOVFF  01,5A
2F72:  MOVFF  00,59
....................                                                                 // escellde belirlenen ortalama deðer alýndý. (muhtemel fark direnc toleranslarý)) 
....................         v_aku*=6.0;                                             // *** 
2F76:  MOVFF  5C,30C
2F7A:  MOVFF  5B,30B
2F7E:  MOVFF  5A,30A
2F82:  MOVFF  59,309
2F86:  MOVLB  3
2F88:  CLRF   x10
2F8A:  CLRF   x0F
2F8C:  MOVLW  40
2F8E:  MOVWF  x0E
2F90:  MOVLW  81
2F92:  MOVWF  x0D
2F94:  MOVLB  0
2F96:  CALL   23FA
2F9A:  MOVFF  03,5C
2F9E:  MOVFF  02,5B
2FA2:  MOVFF  01,5A
2FA6:  MOVFF  00,59
....................          
....................        // fprintf(usbSerial,"aku_adc:%Lu\r\n",aku_adc_toplam); 
....................        // fprintf(usbSerial,"Vaku(24V)=%f V\r\n",v_aku); 
....................         aku_adc_toplam=0; 
2FAA:  CLRF   5E
2FAC:  CLRF   5D
2FAE:  MOVLB  2
....................  
....................     } 
2FB0:  MOVLB  0
2FB2:  GOTO   3B56 (RETURN)
....................      
.................... } 
....................  
.................... #define AKU_SARJ_SES_DELAY 2000 
....................  
.................... void aku_sarj_seslendir(float aku_gerilim){ 
*
3030:  MOVLB  2
3032:  CLRF   xF3
....................  
....................     int x=0; 
....................     //Vaku > 12,60      %100        25,2 
....................     //     12,60-12,40  %75-50      25,2-24,80 
....................     //     12,20-12,00  %50-25      24,40-24,00 
....................     //     12,00-11,70  %25-00      24,00-23,40 
....................     //      <11,70      Derin þarj 
....................     // Bu ideal deðerlere göre mevcut durumdaki akülerin  
....................     // gerilimlerine göre seviye belirlemesi yapýldý 
....................      
....................     if(aku_gerilim>24.00){ 
3034:  CLRF   xF7
3036:  CLRF   xF6
3038:  MOVLW  40
303A:  MOVWF  xF5
303C:  MOVLW  83
303E:  MOVWF  xF4
3040:  MOVFF  2F2,2FB
3044:  MOVFF  2F1,2FA
3048:  MOVFF  2F0,2F9
304C:  MOVFF  2EF,2F8
3050:  MOVLB  0
3052:  RCALL  2FB6
3054:  BNC   3060
....................         aku_sarj_seslendir_say=0; 
3056:  CLRF   4F
....................         aku_yuzde_25=FALSE; 
3058:  BCF    4D.2
....................         aku_yuzde_50=FALSE; 
305A:  BCF    4D.1
....................         aku_dusuk=FALSE; 
305C:  BCF    4D.3
....................         aku_sarja_tak=FALSE; 
305E:  BCF    4D.4
....................     } 
....................  
....................     if ((aku_gerilim < 24.00 && aku_gerilim >= 23.00) && !aku_yuzde_50) { 
3060:  MOVFF  2F2,2F7
3064:  MOVFF  2F1,2F6
3068:  MOVFF  2F0,2F5
306C:  MOVFF  2EF,2F4
3070:  MOVLB  2
3072:  CLRF   xFB
3074:  CLRF   xFA
3076:  MOVLW  40
3078:  MOVWF  xF9
307A:  MOVLW  83
307C:  MOVWF  xF8
307E:  MOVLB  0
3080:  RCALL  2FB6
3082:  BNC   3138
3084:  MOVLB  2
3086:  CLRF   xF7
3088:  CLRF   xF6
308A:  MOVLW  38
308C:  MOVWF  xF5
308E:  MOVLW  83
3090:  MOVWF  xF4
3092:  MOVFF  2F2,2FB
3096:  MOVFF  2F1,2FA
309A:  MOVFF  2F0,2F9
309E:  MOVFF  2EF,2F8
30A2:  MOVLB  0
30A4:  RCALL  2FB6
30A6:  BC    30AA
30A8:  BNZ   3138
30AA:  BTFSC  4D.1
30AC:  BRA    3138
....................         bip_hata(); 
30AE:  MOVLB  2
30B0:  CLRF   xF5
30B2:  MOVLW  03
30B4:  MOVWF  xF4
30B6:  MOVLW  64
30B8:  MOVWF  xF6
30BA:  MOVLW  7C
30BC:  MOVWF  xF8
30BE:  MOVLW  10
30C0:  MOVWF  xF7
30C2:  MOVLB  0
30C4:  CALL   0522
....................         delay_ms(750); 
30C8:  MOVLW  03
30CA:  MOVLB  2
30CC:  MOVWF  xF4
30CE:  MOVLW  FA
30D0:  MOVLB  3
30D2:  MOVWF  x0A
30D4:  MOVLB  0
30D6:  CALL   04F8
30DA:  MOVLB  2
30DC:  DECFSZ xF4,F
30DE:  BRA    30CE
....................          
....................         if (aku_sarj_seslendir_say < 3) { 
30E0:  MOVF   4F,W
30E2:  SUBLW  02
30E4:  BNC   312A
....................             for (x = 0; x < 3; x++) { 
30E6:  CLRF   xF3
30E8:  MOVF   xF3,W
30EA:  SUBLW  02
30EC:  BNC   312A
....................                 mp3_stop_100mS(); 
30EE:  MOVLB  0
30F0:  CALL   0906
30F4:  MOVLW  64
30F6:  MOVLB  3
30F8:  MOVWF  x0A
30FA:  MOVLB  0
30FC:  CALL   04F8
....................                 mp3_play(SES_AKU_SARJ_50); 
3100:  MOVLB  2
3102:  CLRF   xF5
3104:  MOVLW  1A
3106:  MOVWF  xF4
3108:  MOVLB  0
310A:  CALL   0916
....................                 delay_ms(AKU_SARJ_SES_DELAY); 
310E:  MOVLW  08
3110:  MOVLB  2
3112:  MOVWF  xF4
3114:  MOVLW  FA
3116:  MOVLB  3
3118:  MOVWF  x0A
311A:  MOVLB  0
311C:  CALL   04F8
3120:  MOVLB  2
3122:  DECFSZ xF4,F
3124:  BRA    3114
3126:  INCF   xF3,F
3128:  BRA    30E8
....................             } 
....................              
....................         } 
....................          
....................         aku_sarj_seslendir_say++; 
312A:  INCF   4F,F
....................         if (aku_sarj_seslendir_say >= 3){ 
312C:  MOVF   4F,W
312E:  SUBLW  02
3130:  BC    3136
....................             aku_sarj_seslendir_say = 0; 
3132:  CLRF   4F
....................             aku_yuzde_50=TRUE; 
3134:  BSF    4D.1
3136:  MOVLB  0
....................         } 
....................     } 
....................  
....................     if ((aku_gerilim < 23.00 && aku_gerilim >= 22.50) && !aku_yuzde_25) { 
3138:  MOVFF  2F2,2F7
313C:  MOVFF  2F1,2F6
3140:  MOVFF  2F0,2F5
3144:  MOVFF  2EF,2F4
3148:  MOVLB  2
314A:  CLRF   xFB
314C:  CLRF   xFA
314E:  MOVLW  38
3150:  MOVWF  xF9
3152:  MOVLW  83
3154:  MOVWF  xF8
3156:  MOVLB  0
3158:  RCALL  2FB6
315A:  BNC   3210
315C:  MOVLB  2
315E:  CLRF   xF7
3160:  CLRF   xF6
3162:  MOVLW  34
3164:  MOVWF  xF5
3166:  MOVLW  83
3168:  MOVWF  xF4
316A:  MOVFF  2F2,2FB
316E:  MOVFF  2F1,2FA
3172:  MOVFF  2F0,2F9
3176:  MOVFF  2EF,2F8
317A:  MOVLB  0
317C:  RCALL  2FB6
317E:  BC    3182
3180:  BNZ   3210
3182:  BTFSC  4D.2
3184:  BRA    3210
....................         bip_hata(); 
3186:  MOVLB  2
3188:  CLRF   xF5
318A:  MOVLW  03
318C:  MOVWF  xF4
318E:  MOVLW  64
3190:  MOVWF  xF6
3192:  MOVLW  7C
3194:  MOVWF  xF8
3196:  MOVLW  10
3198:  MOVWF  xF7
319A:  MOVLB  0
319C:  CALL   0522
....................         delay_ms(750); 
31A0:  MOVLW  03
31A2:  MOVLB  2
31A4:  MOVWF  xF4
31A6:  MOVLW  FA
31A8:  MOVLB  3
31AA:  MOVWF  x0A
31AC:  MOVLB  0
31AE:  CALL   04F8
31B2:  MOVLB  2
31B4:  DECFSZ xF4,F
31B6:  BRA    31A6
....................  
....................         if (aku_sarj_seslendir_say < 3) { 
31B8:  MOVF   4F,W
31BA:  SUBLW  02
31BC:  BNC   3202
....................             for (x = 0; x < 3; x++) { 
31BE:  CLRF   xF3
31C0:  MOVF   xF3,W
31C2:  SUBLW  02
31C4:  BNC   3202
....................                 mp3_stop_100mS(); 
31C6:  MOVLB  0
31C8:  CALL   0906
31CC:  MOVLW  64
31CE:  MOVLB  3
31D0:  MOVWF  x0A
31D2:  MOVLB  0
31D4:  CALL   04F8
....................                 mp3_play(SES_AKU_SARJ_25); 
31D8:  MOVLB  2
31DA:  CLRF   xF5
31DC:  MOVLW  1B
31DE:  MOVWF  xF4
31E0:  MOVLB  0
31E2:  CALL   0916
....................                 delay_ms(AKU_SARJ_SES_DELAY); 
31E6:  MOVLW  08
31E8:  MOVLB  2
31EA:  MOVWF  xF4
31EC:  MOVLW  FA
31EE:  MOVLB  3
31F0:  MOVWF  x0A
31F2:  MOVLB  0
31F4:  CALL   04F8
31F8:  MOVLB  2
31FA:  DECFSZ xF4,F
31FC:  BRA    31EC
31FE:  INCF   xF3,F
3200:  BRA    31C0
....................             } 
....................         } 
....................          
....................         aku_sarj_seslendir_say++; 
3202:  INCF   4F,F
....................         if (aku_sarj_seslendir_say >= 3){ 
3204:  MOVF   4F,W
3206:  SUBLW  02
3208:  BC    320E
....................             aku_sarj_seslendir_say = 0; 
320A:  CLRF   4F
....................             aku_yuzde_25=TRUE; 
320C:  BSF    4D.2
320E:  MOVLB  0
....................         } 
....................     } 
....................  
....................     if ((aku_gerilim < 22.50 && aku_gerilim >= 22.00) && !aku_dusuk) { 
3210:  MOVFF  2F2,2F7
3214:  MOVFF  2F1,2F6
3218:  MOVFF  2F0,2F5
321C:  MOVFF  2EF,2F4
3220:  MOVLB  2
3222:  CLRF   xFB
3224:  CLRF   xFA
3226:  MOVLW  34
3228:  MOVWF  xF9
322A:  MOVLW  83
322C:  MOVWF  xF8
322E:  MOVLB  0
3230:  RCALL  2FB6
3232:  BNC   32E8
3234:  MOVLB  2
3236:  CLRF   xF7
3238:  CLRF   xF6
323A:  MOVLW  30
323C:  MOVWF  xF5
323E:  MOVLW  83
3240:  MOVWF  xF4
3242:  MOVFF  2F2,2FB
3246:  MOVFF  2F1,2FA
324A:  MOVFF  2F0,2F9
324E:  MOVFF  2EF,2F8
3252:  MOVLB  0
3254:  RCALL  2FB6
3256:  BC    325A
3258:  BNZ   32E8
325A:  BTFSC  4D.3
325C:  BRA    32E8
....................         bip_hata(); 
325E:  MOVLB  2
3260:  CLRF   xF5
3262:  MOVLW  03
3264:  MOVWF  xF4
3266:  MOVLW  64
3268:  MOVWF  xF6
326A:  MOVLW  7C
326C:  MOVWF  xF8
326E:  MOVLW  10
3270:  MOVWF  xF7
3272:  MOVLB  0
3274:  CALL   0522
....................         delay_ms(750); 
3278:  MOVLW  03
327A:  MOVLB  2
327C:  MOVWF  xF4
327E:  MOVLW  FA
3280:  MOVLB  3
3282:  MOVWF  x0A
3284:  MOVLB  0
3286:  CALL   04F8
328A:  MOVLB  2
328C:  DECFSZ xF4,F
328E:  BRA    327E
....................         if (aku_sarj_seslendir_say < 3) { 
3290:  MOVF   4F,W
3292:  SUBLW  02
3294:  BNC   32DA
....................             for (x = 0; x < 3; x++) { 
3296:  CLRF   xF3
3298:  MOVF   xF3,W
329A:  SUBLW  02
329C:  BNC   32DA
....................                 mp3_stop_100mS(); 
329E:  MOVLB  0
32A0:  CALL   0906
32A4:  MOVLW  64
32A6:  MOVLB  3
32A8:  MOVWF  x0A
32AA:  MOVLB  0
32AC:  CALL   04F8
....................                 mp3_play(SES_AKU_SARJ_DUSUK); 
32B0:  MOVLB  2
32B2:  CLRF   xF5
32B4:  MOVLW  1C
32B6:  MOVWF  xF4
32B8:  MOVLB  0
32BA:  CALL   0916
....................                 delay_ms(AKU_SARJ_SES_DELAY); 
32BE:  MOVLW  08
32C0:  MOVLB  2
32C2:  MOVWF  xF4
32C4:  MOVLW  FA
32C6:  MOVLB  3
32C8:  MOVWF  x0A
32CA:  MOVLB  0
32CC:  CALL   04F8
32D0:  MOVLB  2
32D2:  DECFSZ xF4,F
32D4:  BRA    32C4
32D6:  INCF   xF3,F
32D8:  BRA    3298
....................             } 
....................         } 
....................          
....................         aku_sarj_seslendir_say++; 
32DA:  INCF   4F,F
....................         if (aku_sarj_seslendir_say >= 3){ 
32DC:  MOVF   4F,W
32DE:  SUBLW  02
32E0:  BC    32E6
....................             aku_sarj_seslendir_say = 0; 
32E2:  CLRF   4F
....................             aku_dusuk = TRUE; 
32E4:  BSF    4D.3
32E6:  MOVLB  0
....................         } 
....................     } 
....................  
....................     if (aku_gerilim < 21.90 && !aku_sarja_tak) { 
32E8:  MOVFF  2F2,2F7
32EC:  MOVFF  2F1,2F6
32F0:  MOVFF  2F0,2F5
32F4:  MOVFF  2EF,2F4
32F8:  MOVLW  33
32FA:  MOVLB  2
32FC:  MOVWF  xFB
32FE:  MOVWF  xFA
3300:  MOVLW  2F
3302:  MOVWF  xF9
3304:  MOVLW  83
3306:  MOVWF  xF8
3308:  MOVLB  0
330A:  RCALL  2FB6
330C:  BNC   339A
330E:  BTFSC  4D.4
3310:  BRA    339A
....................  
....................         bip_hata(); 
3312:  MOVLB  2
3314:  CLRF   xF5
3316:  MOVLW  03
3318:  MOVWF  xF4
331A:  MOVLW  64
331C:  MOVWF  xF6
331E:  MOVLW  7C
3320:  MOVWF  xF8
3322:  MOVLW  10
3324:  MOVWF  xF7
3326:  MOVLB  0
3328:  CALL   0522
....................         delay_ms(750); 
332C:  MOVLW  03
332E:  MOVLB  2
3330:  MOVWF  xF4
3332:  MOVLW  FA
3334:  MOVLB  3
3336:  MOVWF  x0A
3338:  MOVLB  0
333A:  CALL   04F8
333E:  MOVLB  2
3340:  DECFSZ xF4,F
3342:  BRA    3332
....................          
....................         if (aku_sarj_seslendir_say < 3) { 
3344:  MOVF   4F,W
3346:  SUBLW  02
3348:  BNC   338E
....................             for (x = 0; x < 3; x++) { 
334A:  CLRF   xF3
334C:  MOVF   xF3,W
334E:  SUBLW  02
3350:  BNC   338E
....................                 mp3_stop_100mS(); 
3352:  MOVLB  0
3354:  CALL   0906
3358:  MOVLW  64
335A:  MOVLB  3
335C:  MOVWF  x0A
335E:  MOVLB  0
3360:  CALL   04F8
....................                 mp3_play(SES_AKU_SARJ_TAK); 
3364:  MOVLB  2
3366:  CLRF   xF5
3368:  MOVLW  1D
336A:  MOVWF  xF4
336C:  MOVLB  0
336E:  CALL   0916
....................                 delay_ms(AKU_SARJ_SES_DELAY); 
3372:  MOVLW  08
3374:  MOVLB  2
3376:  MOVWF  xF4
3378:  MOVLW  FA
337A:  MOVLB  3
337C:  MOVWF  x0A
337E:  MOVLB  0
3380:  CALL   04F8
3384:  MOVLB  2
3386:  DECFSZ xF4,F
3388:  BRA    3378
338A:  INCF   xF3,F
338C:  BRA    334C
....................             } 
....................         } 
....................  
....................         aku_sarj_seslendir_say++; 
338E:  INCF   4F,F
....................         if (aku_sarj_seslendir_say >= 3){ 
3390:  MOVF   4F,W
3392:  SUBLW  02
3394:  BC    339A
....................             aku_sarj_seslendir_say = 0; 
3396:  CLRF   4F
....................             aku_sarja_tak = TRUE; 
3398:  BSF    4D.4
339A:  MOVLB  0
....................         } 
....................     } 
339C:  GOTO   3BD4 (RETURN)
....................  
.................... }// 
....................  
....................  
....................  
.................... //        if (millis() - time_sens_deger_goster > 500) { 
.................... // 
.................... //            //debug_ir_sens(ORT_DEGER, GERILIM_VAR); 
.................... //            //debug_ir_sens(HAM_DEGER, GERILIM_VAR); 
.................... //            //             debug_ir_sens_dizi(ir_sens_ort_deger_e_on); 
.................... //            //             debug_ir_sens_dizi(ir_sens_ort_deger_e_off); 
.................... //            // debug_ir_sens_dizi(ir_sens_ort_deger); 
.................... //            // debug_ir_sens_dizi(ir_sens_baslangic_esik_deger); 
.................... //            //  debug_ir_sens_dizi(ir_sens_sayisal_deger); 
.................... // 
.................... //            // fprintf(usbSerial,"\r\n"); 
.................... // 
.................... //            //  debug_ir_sens(MAX_DEGER, GERILIM_VAR);  
.................... //            //  debug_ir_sens(MIN_DEGER, GERILIM_VAR); 
.................... // 
.................... //            //max min deðerleri yeni ortam bilgisi için resetle 
.................... //            //  dizi_set(ir_sens_ort_max_deger,0,SENS_SAYISI); 
.................... //            // dizi_set(ir_sens_ort_min_deger,1023,SENS_SAYISI); 
.................... // 
.................... //            //  fprintf(usbSerial,"pos=%u \r\n",lfr_led); 
.................... //            // fprintf(usbSerial,"posDig=%Lu\thata=%Ld\r\n",ir_sens_pos_digital,hata); 
.................... // 
.................... //            // fprintf(usbSerial,"fisPOS:%f", g_fisOutput[0]); 
.................... //            // sens_deger_sayisal(); 
.................... //            time_sens_deger_goster = millis(); 
.................... //        } 
....................  
.................... //        if (sens_yeni_deger) { 
.................... //            //pozisyon bul PID algoritam çalýþtýr  
.................... //            //ir_sens_pos_ort=agirlikliPosGetir(ORTALAMA_DEGER); 
.................... //             
.................... // 
.................... //            // sens_led_goster(); 
.................... // 
.................... //            sens_yeni_deger = 0; 
.................... // 
.................... //        } 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: A800   INTRC_IO NOPLLEN PRIMARY_ON NOFCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV19 WDT_SW WDT128
   Word  3: B500   CCP2C1 NOPBADEN CCP3B5 NOHFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
